{"version":3,"names":[],"mappings":"","sources":["kit.js"],"sourcesContent":["var utils = (function () {\n\n    // These are general, home-grown javascript functions for common functions used withing the app.\n\n    function setCookie(name, value, minutes) {\n        if (minutes) {\n            var date = new Date();\n            date.setTime(date.getTime() + (minutes * 60 * 1000));\n            var expires = \"; expires=\" + date.toUTCString();\n        }\n        else var expires = \"\";\n        document.cookie = name + \"=\" + value + expires + \"; path=/\";\n    }\n\n    function getCookie(name) {\n        if (document.cookie.length > 0) {\n            c_start = document.cookie.indexOf(name + \"=\");\n            if (c_start != -1) {\n                c_start = c_start + name.length + 1;\n                c_end = document.cookie.indexOf(\";\", c_start);\n                if (c_end == -1) {\n                    c_end = document.cookie.length;\n                }\n                return unescape(document.cookie.substring(c_start, c_end));\n            }\n        }\n        return null;\n    }\n\n    function deleteCookie(name) {\n        setCookie(name, \"\", -60);\n    }\n\n    function resetCookieExpiration(name, minutes) {\n\n        var value = getCookie(name);\n\n        if (value != null) {\n            setCookie(name, value, minutes);\n        }\n\n    }\n\n    function getPageHashParameters() {\n\n        return getHashParameters(window.location.href);\n\n    }\n\n    function getHashParameters(url) {\n\n        var hashParameters = {};\n\n        if (url.indexOf(\"#\") == -1) {\n            return hashParameters;\n        }\n\n        var e,\n            a = /\\+/g,  // Regex for replacing addition symbol with a space\n            r = /([^&;=]+)=?([^&;]*)/g,\n            d = function (s) { return decodeURIComponent(s.replace(a, \" \")); },\n            q = url.substring(url.indexOf(\"#\") + 1);\n\n        while (e = r.exec(q))\n            hashParameters[d(e[1])] = d(e[2]);\n\n        return hashParameters;\n    }\n\n    function getPageQueryParameters() {\n\n        return getQueryParameters(window.location.href);\n\n    }\n\n    function getQueryParameters(url) {\n\n        if (url.indexOf(\"?\") == -1) {\n            return {};\n        }\n\n        q = url.substring(url.indexOf(\"?\") + 1);\n\n        // Strip off any hash parameters\n        if (q.indexOf(\"#\") > 0) {\n            q = q.substring(0, q.indexOf(\"#\"));\n        }\n\n        return parseQueryParameters(q);\n    }\n\n    function parseQueryParameters(query) {\n\n        var queryParameters = {};\n\n        if (isNullOrEmpty(query)) {\n            return queryParameters;\n        }\n\n        var e,\n        a = /\\+/g,  // Regex for replacing addition symbol with a space\n        r = /([^&;=]+)=?([^&;]*)/g,\n        d = function (s) { return decodeURIComponent(s.replace(a, \" \")); }\n        queryParameters = {};\n\n        while (e = r.exec(query))\n            queryParameters[d(e[1])] = d(e[2]);\n\n        return queryParameters;\n\n    }\n\n    function appendParams(url, params) {\n\n        if (params.length == 0) {\n            return url;\n        }\n\n        url += \"?\";\n\n        _.each(params, function (item, index) {\n            url += index + \"=\" + item + \"&\";\n        });\n\n        // remove the trailing ampersand\n        url = url.substring(0, (url.length - 1));\n\n        return url;\n\n    }\n\n    function left(str, n) {\n        if (n <= 0)\n            return \"\";\n        else if (n > String(str).length)\n            return str;\n        else\n            return String(str).substring(0, n);\n    }\n\n    function right(str, n) {\n        if (n <= 0)\n            return \"\";\n        else if (n > String(str).length)\n            return str;\n        else {\n            var iLen = String(str).length;\n            return String(str).substring(iLen, iLen - n);\n        }\n    }\n\n    function isValidNumber(value) {\n        return !isNaN(parseFloat(value)) && isFinite(value);\n    }\n\n    function isValidInteger(value) {\n\n        if (isValidNumber(value) == false) {\n            return false;\n        }\n\n        value = parseFloat(value);\n\n        var result = (value === (parseInt(value) | 0));\n\n        return result;\n    }\n\n    function isValidEmail(value) {\n\n        // http://stackoverflow.com/a/46181/2002383 anystring@anystring.anystring\n        return /\\S+@\\S+\\.\\S+/.test(value);\n\n    }\n\n    function getRandom() {\n        return Math.floor((Math.random() * 10000000) + 1);\n    }\n\n    function hasProperty(obj, prop) {\n\n        // Determine if an object has a particular property http://stackoverflow.com/a/136411/2002383\n\n        if (obj != null) {\n            var proto = obj.__proto__ || obj.constructor.prototype;\n            return (prop in obj) &&\n                (!(prop in proto) || proto[prop] !== obj[prop]);\n        }\n\n        return false;\n    }\n\n    function sumProperties(collection, prop) {\n\n        // Get the sum of a particular property from a collection\n        var sum = 0;\n\n        _.each(collection, function (item) {\n            if (hasProperty(item, prop)) {\n                sum += item[prop];\n            }\n        });\n\n        return sum;\n    }\n\n    function areEqual() {\n        \n        // For an unlimited number of parameters, determines if they are all equal, i.e. areEqual(x, y, z, ...)\n        var len = arguments.length;\n        for (var i = 1; i < len; i++) {\n            if (arguments[i] == null || arguments[i] != arguments[i - 1])\n                return false;\n        }\n\n        return true;\n    }\n\n    function isNullOrEmpty(string) {\n\n        if (string == null || string == undefined) {\n            return true;\n        }\n\n        if (string == \"\") {\n            return true;\n        }\n\n        if (removeWhitespace(string) == null) {\n            return true;\n        }\n\n        return false;\n\n    }\n\n    function stringsToBool(object) {\n\n        // This converts all properties with \"true\" and \"false\" values to true and false, respectively.\n\n        for (var property in object) {\n            if (object.hasOwnProperty(property)) {\n                if (object[property] === \"false\") {\n                    object[property] = false;\n                }\n                if (object[property] === \"true\") {\n                    object[property] = true;\n                }\n            }\n        }\n    }\n\n    function stringToBool(string) {\n        return (string == \"true\");\n    }\n\n    function removeWhitespace(string) {\n        return string.replace(/ /g, '');\n    }\n    \n    function convert(money, rate) {\n        return Math.round((money * rate) * 100) / 100;\n    }\n\n    function luhnCheck(value) {\n\n        var nCheck = 0, nDigit = 0, bEven = false;\n        value = value.replace(/\\D/g, \"\");\n\n        for (var n = value.length - 1; n >= 0; n--) {\n            var cDigit = value.charAt(n);\n            nDigit = parseInt(cDigit, 10);\n\n            if (bEven) {\n                if ((nDigit *= 2) > 9) nDigit -= 9;\n            }\n\n            nCheck += nDigit;\n            bEven = !bEven;\n        }\n\n        return (nCheck % 10) == 0;\n    }\n\n    function undefinedToNull(object) {\n        for (var property in object) {\n            if (object.hasOwnProperty(property)) {\n\n                // If an object, run through all its properties\n                if (Object.prototype.toString.call(object[property]) === '[object Object]') {\n                    undefinedToNull(object[property]);\n                }\n\n                // If an array, run through all items in the array\n                if (Object.prototype.toString.call(object[property]) === '[object Array]') {\n                    for (var obj in object[property]) {\n                        undefinedToNull(obj);\n                    }\n                }\n\n                // Otherwise, convert to null\n                if (object[property] === undefined) {\n                    object[property] = null;\n                }\n            }\n        }\n    }\n\n    function getChildrenElements(n, skipMe, type) {\n        // Get children elements from an HTML element\n        var r = [];\n        for (; n; n = n.nextSibling)\n            if (n.nodeType == 1 && n != skipMe)\n                if (type) {\n                    if (type.toUpperCase() == n.nodeName.toUpperCase()) {\n                        r.push(n);\n                    }\n                } else {\n                    r.push(n);\n                }\n        return r;\n    };\n\n    function getSiblingElements(n, type) {\n        // Get sibling elements from an HTML element, excluding self.\n        return getChildrenElements(n.parentNode.firstChild, n, type);\n    }\n    \n    function getCurrentIsoDate(atStartOfDay) {\n\n        var date = new Date();\n        \n        function pad(number) {\n            var r = String(number);\n            if (r.length === 1) {\n                r = '0' + r;\n            }\n            return r;\n        }\n        \n        var hours = \"00\";\n        var minutes = \"00\";\n        var seconds = \"00\"\n        \n        if (!atStartOfDay) {\n            hours = date.getUTCHours();\n            minutes = date.getUTCMinutes();\n            seconds = date.getUTCSeconds();\n        }\n\n        return date.getUTCFullYear() \n        + '-' + pad(date.getUTCMonth() + 1) \n        + '-' + pad(date.getUTCDate())\n        + 'T' + pad(hours) \n        + ':' + pad(minutes) \n        + ':' + pad(seconds) \n        + 'Z';\n    };\n    \n    function repeat(char, number) {\n        var e = \"\";\n        for (i = 0; i < number; i++) {\n            e += char;\n        }\n        return e;\n    }\n    \n    function mergeParams(params, required, expand) {\n        \n        // If you have a string, parse it into an object\n        if (_.isString(params)) {\n            params = parseQueryParameters(params);\n        }\n\n        // If null, set as an empty object\n        params = params || {};\n        \n        // Takes parameters, removes any hidden that are listed in required from the existing, adds any supplied expand parameters.\n\n        var currentHide = String((params.hide || \"\")).split(\",\");\n        var currentExpand = String((params.expand || \"\")).split(\",\");\n        \n        var newRequired = String((required || \"\")).split(\",\");\n        var newExpand = String((expand || \"\")).split(\",\");\n\n        // Remove items from hide that are in newRequired\n        currentHide = _.reject(currentHide, function (val) {\n            return (newRequired.indexOf(val) >= 0);\n        });\n        \n        // Concat expand\n        currentExpand = currentExpand.concat(newExpand);\n        currentExpand = _.uniq(currentExpand);\n\n        // Return\n        params.hide = currentHide.join(\",\");\n        params.expand = currentExpand.join(\",\");\n        \n        // Remove any leading or trailing commas\n        params.hide = TrimIf(params.hide, \",\");\n        params.expand = TrimIf(params.expand, \",\");\n\n        return params;\n\n    }\n    \n    function LeftTrimIf(str, char) {\n        if (str) {\n            if (str.substring(0, 1) == char) {\n                str = str.substring(1);\n            }\n        }\n        return str;\n    }\n    \n    function RightTrimIf(str, char) {\n        if (str) {\n            if (str.charAt(str.length - 1) == \"/\") {\n                str = str.substr(0, str.length - 1)\n            }\n        }\n        return str;\n    }\n    \n    function deDuplicateCsv(csv) {\n        var array = csv.split(',');\n        var unique = _.uniq(array);\n        return unique.join(\",\");\n    }\n    \n    function TrimIf(str, char) {\n        return (RightTrimIf(LeftTrimIf(str, char), char));\n    }\n    \n    function cleanPrice(price) {\n        // Strip everything except numbers and decimals\n\n        if (typeof price === 'undefined' || price == null) {\n            return \"\";\n        }\n\n        var cleanedPrice = price.toString().replace(/[^0-9\\.\\s]/g, '').trim();\n\n        if (isNaN(cleanedPrice) == true || cleanedPrice.trim() == \"\") {\n            // The value is not reasonably close enough for it to be a valid price. Just return the original input.\n            return price;\n        } else {\n            // Truncate at two decimal places.\n            return parseFloat(cleanedPrice).toFixed(2);\n        }\n    }\n    \n    return {\n        setCookie: setCookie,\n        getCookie: getCookie,\n        deleteCookie: deleteCookie,\n        getPageHashParameters: getPageHashParameters,\n        getHashParameters: getHashParameters,\n        getPageQueryParameters: getPageQueryParameters,\n        getQueryParameters: getQueryParameters,\n        appendParams: appendParams,\n        left: left,\n        right: right,\n        isValidNumber: isValidNumber,\n        isValidInteger: isValidInteger,\n        getRandom: getRandom,\n        stringsToBool: stringsToBool,\n        stringToBool: stringToBool,\n        hasProperty: hasProperty,\n        areEqual: areEqual,\n        sumProperties: sumProperties,\n        isNullOrEmpty: isNullOrEmpty,\n        resetCookieExpiration: resetCookieExpiration,\n        removeWhitespace: removeWhitespace,\n        luhnCheck: luhnCheck,\n        undefinedToNull: undefinedToNull,\n        parseQueryParameters: parseQueryParameters,\n        isValidEmail: isValidEmail,\n        getChildrenElements: getChildrenElements,\n        getSiblingElements: getSiblingElements,\n        convert: convert,\n        getCurrentIsoDate: getCurrentIsoDate,\n        repeat: repeat,\n        mergeParams: mergeParams,\n        deDuplicateCsv: deDuplicateCsv,\n        cleanPrice: cleanPrice\n    };\n\n})();\n\n// Prototypes\nString.prototype.replaceAll = function (f, r) {\n    return this.split(f).join(r);\n}\n\n// The following code needs to run after app.js and after utilities.js are loaded but before any directive, controller, etc. are run. This bootstraps the app at run time with the initial settings and configurations.\n// This is included in kit.js\n\napp.run(['$rootScope', '$http', 'SettingsService', 'StorageService', 'LanguageService', 'ApiService', function ($rootScope, $http, SettingsService, StorageService, LanguageService, ApiService) {\n\n    // Get the settings\n    var settings = SettingsService.get();\n\n    // Enable CORS when running in development environments.\n    if (settings.config.development) {\n        $http.defaults.useXDomain = true;\n    }\n\n    // Establish the app language\n    LanguageService.establishLanguage($rootScope.languagesPath);\n\n    // Establish the pageview load code. This is used to send Analytics data to the platform.\n    var loadPageview = function () {\n\n        // Find the pageview script in the DOM. If present, append the pageview analytics source to the page. Replace any previous to not pollute the page with each pageview.\n        var app_pageview = document.getElementById(\"app_pageview\");\n\n        if (app_pageview && settings.config.development != true) {\n            var head = document.getElementsByTagName(\"head\")[0];\n            var js = document.createElement(\"script\");\n            js.id = \"app_pageviewload\";\n            js.type = \"text/javascript\";\n            js.src = \"analytics/pageview.js\";\n\n            // Remove any existing\n            if (document.getElementById(\"app_pageviewload\") != null) {\n                head.removeChild(document.getElementById(\"app_pageviewload\"));\n            }\n\n            // Add again to force reload.\n            head.appendChild(js);\n        }\n    }\n\n}]);\nvar amazonPay = (function () {\n\n    var url = \"https://static-na.payments-amazon.com/OffAmazonPayments/us/js/Widgets.js\";\n    if (window.__settings.account.test) {\n        url = \"https://static-na.payments-amazon.com/OffAmazonPayments/us/sandbox/js/Widgets.js\";\n    }\n\n    var access_token = null;\n    var order_reference_id = null;\n    var billing_agreement_id = null;\n    var loaded = false;\n    var consent_status = false;\n\n    var address_book;\n\n    // Load the Amazon Pay SDK, if available for this account.\n    if (isAvailable()) {\n        loadScript(url, function () {\n            loaded = true;\n        });\n    }\n\n    function createPaymentButton(client_id, seller_id, target_id, type, color, size, callback) {\n\n        // client_id: The Amazon Pay client ID\n        // seller_id: The Amazon Pay seller ID\n        // target_id: The id of the HTML element the button should be placed within\n        // type, color, size: Button customizations, see function code for possibilities\n        // callback(error, data): The function that is called when the button is created, data returns the access_token, which needs to be passed to the API when submitting the payment.\n\n        // Load the SDK, if not already loaded.\n        if (!loaded) {\n            loadScript(url, function () {\n                loaded = true;\n            });\n        }\n\n        // Run now if ready, otherwise wait till ready.\n        if (!window.amazon) {\n            window.onAmazonLoginReady = function () {\n                _createPaymentButton(target_id, type, color, size, callback);\n            }\n        } else {\n            _createPaymentButton(target_id, type, color, size, callback);\n        }\n\n        function _createPaymentButton(target_id, type, color, size, callback) {\n\n            // Set the ids\n            amazon.Login.setClientId(client_id);\n            amazon.Login.setUseCookie(true);\n\n            // Create the payment button\n            OffAmazonPayments.Button(target_id, seller_id, {\n\n                // https://pay.amazon.com/us/developer/documentation/lpwa/201953980\n                type: type || \"PwA\", // \"PwA\", \"Pay\", \"A\"\n                color: color || \"Gold\", // \"Gold\", \"LightGray\", \"DarkGray\"\n                size: size || \"medium\", // \"small\", \"medium\", \"large\", \"x-large\"\n                authorization: function () {\n                    var loginOptions = { scope: 'profile payments:widget payments:shipping_address' };\n                    authRequest = amazon.Login.authorize(loginOptions, function (response) {\n                        access_token = response.access_token;\n                    });\n                },\n                onSignIn: function (orderReferenece) {\n\n                    // Return the order reference and the access token that was previously generated\n                    if (callback) {\n                        callback(null, { access_token: access_token, order_reference_id: null, billing_agreement_id: null, seller_id: seller_id });\n                    }\n                },\n                onError: function (error) {\n                    callback(\"There was a problem attempting to load the Amazon Pay button.\");\n                    console.log(error.getErrorMessage());\n                }\n\n            });\n        }\n    }\n\n    function loadWidgets(client_id, seller_id, requires_billing_agreement, address_id, wallet_id, consent_id, onAddressSelect, onPaymentMethodSelect, onConsentChange, design_mode, display_mode, callback) {\n\n        // client_id: The Amazon Pay client ID\n        // seller_id: The Amazon Pay seller ID\n        // requires_billing_agreement: indicates if the transaction requires establishing a billing agreement, which will generate a consent box for the user to select\n        // address_id: The id of the HTML element (div) that will hold the address widget\n        // wallet_id: The id of the HTML element (div) that will hold the wallet widget\n        // consent_id: The id of the HTML element (div) that will hold the consent widget in the case of establishing a billing agreement\n        // onAddressSelect: Fires when an address has been selected by the user\n        // onPaymentMethodSelect: Fires when a payment method has been selected by the user\n        // onConsentChange: Fires when the consent has been toggled by the user. A callback parameter of 'status' true / false indicates the state of the conset checkbox\n        // design_mode: Indicates the design mode of the widgets, 'responsive' is used if not provided.\n        // callback(error, data): The function that is called when the button is created, data returns an object that contains the access_token and the order_reference_id or billing_agreement_id, depending on establishment of a billing agreement\n\n        if (requires_billing_agreement) {\n            loadWidgetsWithBillingAgreement(seller_id, address_id, wallet_id, consent_id, design_mode, display_mode)\n        } else {\n            billing_agreement_id = null;\n            loadWidgetsWithoutBillingAgreement(seller_id, address_id, wallet_id, design_mode, display_mode)\n        }\n\n        function loadWidgetsWithoutBillingAgreement(seller_id, address_id, wallet_id, design_mode, display_mode) {\n            address_book = new OffAmazonPayments.Widgets.AddressBook({\n                sellerId: seller_id,\n                onOrderReferenceCreate: function (orderReference) {\n                    order_reference_id = orderReference.getAmazonOrderReferenceId();\n                },\n                onAddressSelect: function (data) {\n                    if (onAddressSelect) {\n                        onAddressSelect();\n                    }\n                },\n                display_mode: display_mode || \"Edit\",\n                design: { designMode: design_mode || \"responsive\" },\n                onReady: function (orderReference) {\n                    callback(null, { access_token: access_token, order_reference_id: order_reference_id, billing_agreement_id: null, seller_id: seller_id });\n                },\n                onError: function (error) {\n                    callback(\"There was a problem attempting to load the Amazon Pay address book.\");\n                    console.log(error.getErrorMessage());\n                }\n            }).bind(address_id);\n            wallet = new OffAmazonPayments.Widgets.Wallet({\n                sellerId: seller_id,\n                onPaymentSelect: function () {\n                    if (onPaymentMethodSelect) {\n                        onPaymentMethodSelect();\n                    }\n                },\n                display_mode: display_mode || \"Edit\",\n                design: {\n                    designMode: design_mode || \"responsive\"\n                },\n                onError: function (error) {\n                    callback(\"There was a problem attempting to load the Amazon Pay wallet.\");\n                    console.log(error.getErrorMessage());\n                }\n            }).bind(wallet_id);\n        }\n\n        function loadWidgetsWithBillingAgreement(seller_id, address_id, wallet_id, consent_id, design_mode, display_mode) {\n\n            var payload = {\n                sellerId: seller_id,\n                agreementType: \"BillingAgreement\",\n                onReady: function (billingAgreement) {\n                    billing_agreement_id = billingAgreement.getAmazonBillingAgreementId();\n                    wallet = new OffAmazonPayments.Widgets.Wallet({\n                        sellerId: seller_id,\n                        amazonBillingAgreementId: billing_agreement_id,\n                        onReady: function () {\n                            callback(null, { access_token: access_token, billing_agreement_id: billing_agreement_id, seller_id: seller_id });\n                        },\n                        onPaymentSelect: function (billingAgreement) {\n                            if (onPaymentMethodSelect) {\n                                onPaymentMethodSelect();\n                            }\n                            consent = new OffAmazonPayments.Widgets.Consent({\n                                sellerId: seller_id,\n                                amazonBillingAgreementId: billing_agreement_id,\n                                design: { designMode: design_mode || \"responsive\" },\n                                onReady: function (billingAgreementConsentStatus) {\n                                    if (billingAgreementConsentStatus.getConsentStatus) {\n                                        if (consent_status !== utils.stringToBool(billingAgreementConsentStatus.getConsentStatus())) {\n                                            consent_status = !consent_status;\n                                            if (onConsentChange) {\n                                                onConsentChange(consent_status);\n                                            }\n                                        }\n                                    }\n                                },\n                                onConsent: function (billingAgreementConsentStatus) {\n                                    if (consent_status !== utils.stringToBool(billingAgreementConsentStatus.getConsentStatus())) {\n                                        consent_status = !consent_status;\n                                        if (onConsentChange) {\n                                            onConsentChange(consent_status);\n                                        }\n                                    }\n                                },\n                                onError: function (error) {\n                                    callback(\"There was a problem attempting to load the Amazon Pay wallet.\");\n                                    console.log(error.getErrorMessage());\n                                }\n                            }).bind(consent_id);\n                        },\n                        display_mode: display_mode || \"Edit\",\n                        design: { designMode: design_mode || \"responsive\" },\n                        onError: function (error) {\n                            callback(\"There was a problem attempting to load the Amazon Pay wallet.\");\n                            console.log(error.getErrorMessage());\n                        }\n                    }).bind(wallet_id);\n                },\n                onAddressSelect: function (billingAgreement) {\n                    if (onAddressSelect) {\n                        onAddressSelect();\n                    }\n                },\n                display_mode: display_mode || \"Edit\",\n                design: { designMode: design_mode || \"responsive\" },\n                onError: function (error) {\n                    callback(\"There was a problem attempting to load the Amazon Pay wallet.\");\n                    console.log(error.getErrorMessage());\n                }\n            };\n            address_book = new OffAmazonPayments.Widgets.AddressBook(payload).bind(address_id);\n\n        }\n\n    }\n\n    function reRenderWidgets(client_id, seller_id, order_reference_id, billing_agreement_id, wallet_id, onPaymentMethodSelect, design_mode, callback) {\n\n        // seller_id: The Amazon Pay seller ID\n        // order_reference_id: The order_reference_id for the transaction. Required if billing_agreement_id is null.\n        // billing_agreement_id: The billing_agreement_id for the transaction. Required if order_reference_id is null.\n        // wallet_id: The id of the HTML element (div) that will hold the wallet widget.\n        // onPaymentMethodSelect: Fires when a payment method has been selected by the user.\n        // design_mode: Indicates the design mode of the widgets, 'responsive' is used if not provided.\n        // callback(error): The function that is called when the widget is refreshed, including a parameter 'error' that is populated if an error occurs when refreshing the widget.\n\n        amazon.Login.setClientId(client_id);\n        amazon.Login.setUseCookie(true);\n\n        if (billing_agreement_id) {\n            reRenderWidgetsWithBillingAgreement(seller_id, billing_agreement_id, wallet_id, onPaymentMethodSelect, callback);\n        } else {\n            reRenderWidgetsWithoutBillingAgreement(seller_id, order_reference_id, wallet_id, onPaymentMethodSelect, callback);\n        }\n\n        function reRenderWidgetsWithoutBillingAgreement(seller_id, order_reference_id, wallet_id, onPaymentMethodSelect, callback) {\n\n            new OffAmazonPayments.Widgets.Wallet({\n                sellerId: seller_id,\n\n                amazonOrderReferenceId: order_reference_id,\n\n                onPaymentSelect: function (orderReference) {\n                    if (onPaymentMethodSelect) {\n                        onPaymentMethodSelect();\n                    }\n                },\n                design: {\n                    designMode: design_mode || \"responsive\"\n                },\n\n                onError: function (error) {\n                    callback(\"There was a problem attempting to load the Amazon Pay wallet.\");\n                    console.log(error.getErrorMessage());\n                }\n            }).bind(wallet_id);\n\n        }\n\n        function reRenderWidgetsWithBillingAgreement(seller_id, billing_agreement_id, wallet_id, onPaymentMethodSelect, callback) {\n\n            new OffAmazonPayments.Widgets.Wallet({\n                sellerId: seller_id,\n\n                billingAgreementId: billing_agreement_id,\n\n                onPaymentSelect: function (orderReference) {\n                    if (onPaymentMethodSelect) {\n                        onPaymentMethodSelect();\n                    }\n                },\n                design: {\n                    designMode: design_mode || \"responsive\"\n                },\n\n                onError: function (error) {\n                    callback(\"There was a problem attempting to load the Amazon Pay wallet.\");\n                    console.log(error.getErrorMessage());\n                }\n            }).bind(wallet_id);\n\n        }\n    }\n\n    function logout() {\n        access_token = null;\n        order_reference_id = null;\n        billing_agreement_id = null;\n\n        if (amazon) {\n            amazon.Login.logout();\n        }\n    }\n\n    function loadScript(url, callback) {\n        // Appends a script to the DOM\n        var head = document.getElementsByTagName(\"head\")[0], done = false;\n        var script = document.createElement(\"script\");\n        script.src = url;\n        script.type = \"text/javascript\";\n        script.async = 1;\n        // Attach handlers for all browsers\n        script.onload = script.onreadystatechange = function () {\n            if (!done && (!this.readyState || this.readyState === \"loaded\" || this.readyState === \"complete\")) {\n                done = true;\n                // Initialize\n                if (typeof callback === 'function') callback();\n            }\n        };\n        head.appendChild(script);\n    }\n\n    function isAvailable() {\n        // Indicates if Amazon Pay is an available payment method\n        if (window.__settings && window.__settings.account && window.__settings.account.payment_method_types.indexOf(\"amazon_pay\") > -1) {\n            return true;\n        }\n        return false;\n    }\n\n    function showWidgets(address_id, wallet_id, consent_id, recurring) {\n\n        // Show the widgets\n        var addressWidget = document.getElementById(address_id);\n        var walletWidget = document.getElementById(wallet_id);\n        var consentWidget = document.getElementById(consent_id);\n\n        if (addressWidget)\n            addressWidget.style.removeProperty(\"display\");\n\n        if (walletWidget)\n            walletWidget.style.removeProperty(\"display\");\n\n        if (consentWidget && recurring)\n            consentWidget.style.removeProperty(\"display\");\n    }\n\n    function hideWidgets(address_id, wallet_id, consent_id) {\n\n        // Hide the widgets\n        var addressWidget = document.getElementById(address_id);\n        var walletWidget = document.getElementById(wallet_id);\n        var consentWidget = document.getElementById(consent_id);\n\n        // Destroy the contents of each and then hide the element\n        if (addressWidget) {\n            addressWidget.style.display = \"none\";\n            addressWidget.innerHTML = \"\";\n        }\n\n        if (walletWidget) {\n            walletWidget.style.display = \"none\";\n            walletWidget.innerHTML = \"\";\n        }\n\n        if (consentWidget) {\n            consentWidget.style.display = \"none\";\n            consentWidget.innerHTML = \"\";\n        }\n\n    }\n\n    function getConsentStatus() {\n        return consent_status;\n    }\n\n    // Public API\n    return {\n        createPaymentButton: createPaymentButton,\n        loadWidgets: loadWidgets,\n        showWidgets: showWidgets,\n        hideWidgets: hideWidgets,\n        reRenderWidgets: reRenderWidgets,\n        logout: logout,\n        getConsentStatus: getConsentStatus\n    };\n\n})();\n/* FileSaver.js\n * A saveAs() FileSaver implementation.\n * 1.3.0\n *\n * By Eli Grey, http://eligrey.com\n * License: MIT\n *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md\n */\n\n/*global self */\n/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */\n\nvar saveAs = saveAs || (function(view) {\n\t\"use strict\";\n\t// IE <10 is explicitly unsupported\n\tif (typeof view === \"undefined\" || typeof navigator !== \"undefined\" && /MSIE [1-9]\\./.test(navigator.userAgent)) {\n\t\treturn;\n\t}\n\tvar\n\t\t  doc = view.document\n\t\t  // only get URL when necessary in case Blob.js hasn't overridden it yet\n\t\t, get_URL = function() {\n\t\t\treturn view.URL || view.webkitURL || view;\n\t\t}\n\t\t, save_link = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\n\t\t, can_use_save_link = \"download\" in save_link\n\t\t, click = function(node) {\n\t\t\tvar event = new MouseEvent(\"click\");\n\t\t\tnode.dispatchEvent(event);\n\t\t}\n\t\t, is_safari = /constructor/i.test(view.HTMLElement)\n\t\t, throw_outside = function(ex) {\n\t\t\t(view.setImmediate || view.setTimeout)(function() {\n\t\t\t\tthrow ex;\n\t\t\t}, 0);\n\t\t}\n\t\t, force_saveable_type = \"application/octet-stream\"\n\t\t// the Blob API is fundamentally broken as there is no \"downloadfinished\" event to subscribe to\n\t\t, arbitrary_revoke_timeout = 1000 * 40 // in ms\n\t\t, revoke = function(file) {\n\t\t\tvar revoker = function() {\n\t\t\t\tif (typeof file === \"string\") { // file is an object URL\n\t\t\t\t\tget_URL().revokeObjectURL(file);\n\t\t\t\t} else { // file is a File\n\t\t\t\t\tfile.remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\tsetTimeout(revoker, arbitrary_revoke_timeout);\n\t\t}\n\t\t, dispatch = function(filesaver, event_types, event) {\n\t\t\tevent_types = [].concat(event_types);\n\t\t\tvar i = event_types.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar listener = filesaver[\"on\" + event_types[i]];\n\t\t\t\tif (typeof listener === \"function\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlistener.call(filesaver, event || filesaver);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tthrow_outside(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t, auto_bom = function(blob) {\n\t\t\t// prepend BOM for UTF-8 XML and text/* types (including HTML)\n\t\t\t// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n\t\t\tif (/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n\t\t\t\treturn new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});\n\t\t\t}\n\t\t\treturn blob;\n\t\t}\n\t\t, FileSaver = function(blob, name, no_auto_bom) {\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\t// First try a.download, then web filesystem, then object URLs\n\t\t\tvar\n\t\t\t\t  filesaver = this\n\t\t\t\t, type = blob.type\n\t\t\t\t, force = type === force_saveable_type\n\t\t\t\t, object_url\n\t\t\t\t, dispatch_all = function() {\n\t\t\t\t\tdispatch(filesaver, \"writestart progress write writeend\".split(\" \"));\n\t\t\t\t}\n\t\t\t\t// on any filesys errors revert to saving with object URLs\n\t\t\t\t, fs_error = function() {\n\t\t\t\t\tif (force && is_safari && view.FileReader) {\n\t\t\t\t\t\t// Safari doesn't allow downloading of blob urls\n\t\t\t\t\t\tvar reader = new FileReader();\n\t\t\t\t\t\treader.onloadend = function() {\n\t\t\t\t\t\t\tvar base64Data = reader.result;\n\t\t\t\t\t\t\tview.location.href = \"data:attachment/file\" + base64Data.slice(base64Data.search(/[,;]/));\n\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\tdispatch_all();\n\t\t\t\t\t\t};\n\t\t\t\t\t\treader.readAsDataURL(blob);\n\t\t\t\t\t\tfilesaver.readyState = filesaver.INIT;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// don't create more object URLs than needed\n\t\t\t\t\tif (!object_url) {\n\t\t\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\t\t}\n\t\t\t\t\tif (force) {\n\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar opened = view.open(object_url, \"_blank\");\n\t\t\t\t\t\tif (!opened) {\n\t\t\t\t\t\t\t// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html\n\t\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t}\n\t\t\t;\n\t\t\tfilesaver.readyState = filesaver.INIT;\n\n\t\t\tif (can_use_save_link) {\n\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tsave_link.href = object_url;\n\t\t\t\t\tsave_link.download = name;\n\t\t\t\t\tclick(save_link);\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfs_error();\n\t\t}\n\t\t, FS_proto = FileSaver.prototype\n\t\t, saveAs = function(blob, name, no_auto_bom) {\n\t\t\treturn new FileSaver(blob, name || blob.name || \"download\", no_auto_bom);\n\t\t}\n\t;\n\t// IE 10+ (native saveAs)\n\tif (typeof navigator !== \"undefined\" && navigator.msSaveOrOpenBlob) {\n\t\treturn function(blob, name, no_auto_bom) {\n\t\t\tname = name || blob.name || \"download\";\n\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\treturn navigator.msSaveOrOpenBlob(blob, name);\n\t\t};\n\t}\n\n\tFS_proto.abort = function(){};\n\tFS_proto.readyState = FS_proto.INIT = 0;\n\tFS_proto.WRITING = 1;\n\tFS_proto.DONE = 2;\n\n\tFS_proto.error =\n\tFS_proto.onwritestart =\n\tFS_proto.onprogress =\n\tFS_proto.onwrite =\n\tFS_proto.onabort =\n\tFS_proto.onerror =\n\tFS_proto.onwriteend =\n\t\tnull;\n\n\treturn saveAs;\n}(\n\t   typeof self !== \"undefined\" && self\n\t|| typeof window !== \"undefined\" && window\n\t|| this.content\n));\n// `self` is undefined in Firefox for Android content script context\n// while `this` is nsIContentFrameMessageManager\n// with an attribute `content` that corresponds to the window\n\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports.saveAs = saveAs;\n} else if ((typeof define !== \"undefined\" && define !== null) && (define.amd !== null)) {\n  define([], function() {\n    return saveAs;\n  });\n}\n\n//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n(function () { function n(n) { function t(t, r, e, u, i, o) { for (; i >= 0 && o > i; i += n) { var a = u ? u[i] : i; e = r(e, t[a], a, t) } return e } return function (r, e, u, i) { e = b(e, i, 4); var o = !k(r) && m.keys(r), a = (o || r).length, c = n > 0 ? 0 : a - 1; return arguments.length < 3 && (u = r[o ? o[c] : c], c += n), t(r, e, u, o, c, a) } } function t(n) { return function (t, r, e) { r = x(r, e); for (var u = O(t), i = n > 0 ? 0 : u - 1; i >= 0 && u > i; i += n) if (r(t[i], i, t)) return i; return -1 } } function r(n, t, r) { return function (e, u, i) { var o = 0, a = O(e); if (\"number\" == typeof i) n > 0 ? o = i >= 0 ? i : Math.max(i + a, o) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1; else if (r && i && a) return i = r(e, u), e[i] === u ? i : -1; if (u !== u) return i = t(l.call(e, o, a), m.isNaN), i >= 0 ? i + o : -1; for (i = n > 0 ? o : a - 1; i >= 0 && a > i; i += n) if (e[i] === u) return i; return -1 } } function e(n, t) { var r = I.length, e = n.constructor, u = m.isFunction(e) && e.prototype || a, i = \"constructor\"; for (m.has(n, i) && !m.contains(t, i) && t.push(i) ; r--;) i = I[r], i in n && n[i] !== u[i] && !m.contains(t, i) && t.push(i) } var u = this, i = u._, o = Array.prototype, a = Object.prototype, c = Function.prototype, f = o.push, l = o.slice, s = a.toString, p = a.hasOwnProperty, h = Array.isArray, v = Object.keys, g = c.bind, y = Object.create, d = function () { }, m = function (n) { return n instanceof m ? n : this instanceof m ? void (this._wrapped = n) : new m(n) }; \"undefined\" != typeof exports ? (\"undefined\" != typeof module && module.exports && (exports = module.exports = m), exports._ = m) : u._ = m, m.VERSION = \"1.8.3\"; var b = function (n, t, r) { if (t === void 0) return n; switch (null == r ? 3 : r) { case 1: return function (r) { return n.call(t, r) }; case 2: return function (r, e) { return n.call(t, r, e) }; case 3: return function (r, e, u) { return n.call(t, r, e, u) }; case 4: return function (r, e, u, i) { return n.call(t, r, e, u, i) } } return function () { return n.apply(t, arguments) } }, x = function (n, t, r) { return null == n ? m.identity : m.isFunction(n) ? b(n, t, r) : m.isObject(n) ? m.matcher(n) : m.property(n) }; m.iteratee = function (n, t) { return x(n, t, 1 / 0) }; var _ = function (n, t) { return function (r) { var e = arguments.length; if (2 > e || null == r) return r; for (var u = 1; e > u; u++) for (var i = arguments[u], o = n(i), a = o.length, c = 0; a > c; c++) { var f = o[c]; t && r[f] !== void 0 || (r[f] = i[f]) } return r } }, j = function (n) { if (!m.isObject(n)) return {}; if (y) return y(n); d.prototype = n; var t = new d; return d.prototype = null, t }, w = function (n) { return function (t) { return null == t ? void 0 : t[n] } }, A = Math.pow(2, 53) - 1, O = w(\"length\"), k = function (n) { var t = O(n); return \"number\" == typeof t && t >= 0 && A >= t }; m.each = m.forEach = function (n, t, r) { t = b(t, r); var e, u; if (k(n)) for (e = 0, u = n.length; u > e; e++) t(n[e], e, n); else { var i = m.keys(n); for (e = 0, u = i.length; u > e; e++) t(n[i[e]], i[e], n) } return n }, m.map = m.collect = function (n, t, r) { t = x(t, r); for (var e = !k(n) && m.keys(n), u = (e || n).length, i = Array(u), o = 0; u > o; o++) { var a = e ? e[o] : o; i[o] = t(n[a], a, n) } return i }, m.reduce = m.foldl = m.inject = n(1), m.reduceRight = m.foldr = n(-1), m.find = m.detect = function (n, t, r) { var e; return e = k(n) ? m.findIndex(n, t, r) : m.findKey(n, t, r), e !== void 0 && e !== -1 ? n[e] : void 0 }, m.filter = m.select = function (n, t, r) { var e = []; return t = x(t, r), m.each(n, function (n, r, u) { t(n, r, u) && e.push(n) }), e }, m.reject = function (n, t, r) { return m.filter(n, m.negate(x(t)), r) }, m.every = m.all = function (n, t, r) { t = x(t, r); for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) { var o = e ? e[i] : i; if (!t(n[o], o, n)) return !1 } return !0 }, m.some = m.any = function (n, t, r) { t = x(t, r); for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) { var o = e ? e[i] : i; if (t(n[o], o, n)) return !0 } return !1 }, m.contains = m.includes = m.include = function (n, t, r, e) { return k(n) || (n = m.values(n)), (\"number\" != typeof r || e) && (r = 0), m.indexOf(n, t, r) >= 0 }, m.invoke = function (n, t) { var r = l.call(arguments, 2), e = m.isFunction(t); return m.map(n, function (n) { var u = e ? t : n[t]; return null == u ? u : u.apply(n, r) }) }, m.pluck = function (n, t) { return m.map(n, m.property(t)) }, m.where = function (n, t) { return m.filter(n, m.matcher(t)) }, m.findWhere = function (n, t) { return m.find(n, m.matcher(t)) }, m.max = function (n, t, r) { var e, u, i = -1 / 0, o = -1 / 0; if (null == t && null != n) { n = k(n) ? n : m.values(n); for (var a = 0, c = n.length; c > a; a++) e = n[a], e > i && (i = e) } else t = x(t, r), m.each(n, function (n, r, e) { u = t(n, r, e), (u > o || u === -1 / 0 && i === -1 / 0) && (i = n, o = u) }); return i }, m.min = function (n, t, r) { var e, u, i = 1 / 0, o = 1 / 0; if (null == t && null != n) { n = k(n) ? n : m.values(n); for (var a = 0, c = n.length; c > a; a++) e = n[a], i > e && (i = e) } else t = x(t, r), m.each(n, function (n, r, e) { u = t(n, r, e), (o > u || 1 / 0 === u && 1 / 0 === i) && (i = n, o = u) }); return i }, m.shuffle = function (n) { for (var t, r = k(n) ? n : m.values(n), e = r.length, u = Array(e), i = 0; e > i; i++) t = m.random(0, i), t !== i && (u[i] = u[t]), u[t] = r[i]; return u }, m.sample = function (n, t, r) { return null == t || r ? (k(n) || (n = m.values(n)), n[m.random(n.length - 1)]) : m.shuffle(n).slice(0, Math.max(0, t)) }, m.sortBy = function (n, t, r) { return t = x(t, r), m.pluck(m.map(n, function (n, r, e) { return { value: n, index: r, criteria: t(n, r, e) } }).sort(function (n, t) { var r = n.criteria, e = t.criteria; if (r !== e) { if (r > e || r === void 0) return 1; if (e > r || e === void 0) return -1 } return n.index - t.index }), \"value\") }; var F = function (n) { return function (t, r, e) { var u = {}; return r = x(r, e), m.each(t, function (e, i) { var o = r(e, i, t); n(u, e, o) }), u } }; m.groupBy = F(function (n, t, r) { m.has(n, r) ? n[r].push(t) : n[r] = [t] }), m.indexBy = F(function (n, t, r) { n[r] = t }), m.countBy = F(function (n, t, r) { m.has(n, r) ? n[r]++ : n[r] = 1 }), m.toArray = function (n) { return n ? m.isArray(n) ? l.call(n) : k(n) ? m.map(n, m.identity) : m.values(n) : [] }, m.size = function (n) { return null == n ? 0 : k(n) ? n.length : m.keys(n).length }, m.partition = function (n, t, r) { t = x(t, r); var e = [], u = []; return m.each(n, function (n, r, i) { (t(n, r, i) ? e : u).push(n) }), [e, u] }, m.first = m.head = m.take = function (n, t, r) { return null == n ? void 0 : null == t || r ? n[0] : m.initial(n, n.length - t) }, m.initial = function (n, t, r) { return l.call(n, 0, Math.max(0, n.length - (null == t || r ? 1 : t))) }, m.last = function (n, t, r) { return null == n ? void 0 : null == t || r ? n[n.length - 1] : m.rest(n, Math.max(0, n.length - t)) }, m.rest = m.tail = m.drop = function (n, t, r) { return l.call(n, null == t || r ? 1 : t) }, m.compact = function (n) { return m.filter(n, m.identity) }; var S = function (n, t, r, e) { for (var u = [], i = 0, o = e || 0, a = O(n) ; a > o; o++) { var c = n[o]; if (k(c) && (m.isArray(c) || m.isArguments(c))) { t || (c = S(c, t, r)); var f = 0, l = c.length; for (u.length += l; l > f;) u[i++] = c[f++] } else r || (u[i++] = c) } return u }; m.flatten = function (n, t) { return S(n, t, !1) }, m.without = function (n) { return m.difference(n, l.call(arguments, 1)) }, m.uniq = m.unique = function (n, t, r, e) { m.isBoolean(t) || (e = r, r = t, t = !1), null != r && (r = x(r, e)); for (var u = [], i = [], o = 0, a = O(n) ; a > o; o++) { var c = n[o], f = r ? r(c, o, n) : c; t ? (o && i === f || u.push(c), i = f) : r ? m.contains(i, f) || (i.push(f), u.push(c)) : m.contains(u, c) || u.push(c) } return u }, m.union = function () { return m.uniq(S(arguments, !0, !0)) }, m.intersection = function (n) { for (var t = [], r = arguments.length, e = 0, u = O(n) ; u > e; e++) { var i = n[e]; if (!m.contains(t, i)) { for (var o = 1; r > o && m.contains(arguments[o], i) ; o++); o === r && t.push(i) } } return t }, m.difference = function (n) { var t = S(arguments, !0, !0, 1); return m.filter(n, function (n) { return !m.contains(t, n) }) }, m.zip = function () { return m.unzip(arguments) }, m.unzip = function (n) { for (var t = n && m.max(n, O).length || 0, r = Array(t), e = 0; t > e; e++) r[e] = m.pluck(n, e); return r }, m.object = function (n, t) { for (var r = {}, e = 0, u = O(n) ; u > e; e++) t ? r[n[e]] = t[e] : r[n[e][0]] = n[e][1]; return r }, m.findIndex = t(1), m.findLastIndex = t(-1), m.sortedIndex = function (n, t, r, e) { r = x(r, e, 1); for (var u = r(t), i = 0, o = O(n) ; o > i;) { var a = Math.floor((i + o) / 2); r(n[a]) < u ? i = a + 1 : o = a } return i }, m.indexOf = r(1, m.findIndex, m.sortedIndex), m.lastIndexOf = r(-1, m.findLastIndex), m.range = function (n, t, r) { null == t && (t = n || 0, n = 0), r = r || 1; for (var e = Math.max(Math.ceil((t - n) / r), 0), u = Array(e), i = 0; e > i; i++, n += r) u[i] = n; return u }; var E = function (n, t, r, e, u) { if (!(e instanceof t)) return n.apply(r, u); var i = j(n.prototype), o = n.apply(i, u); return m.isObject(o) ? o : i }; m.bind = function (n, t) { if (g && n.bind === g) return g.apply(n, l.call(arguments, 1)); if (!m.isFunction(n)) throw new TypeError(\"Bind must be called on a function\"); var r = l.call(arguments, 2), e = function () { return E(n, e, t, this, r.concat(l.call(arguments))) }; return e }, m.partial = function (n) { var t = l.call(arguments, 1), r = function () { for (var e = 0, u = t.length, i = Array(u), o = 0; u > o; o++) i[o] = t[o] === m ? arguments[e++] : t[o]; for (; e < arguments.length;) i.push(arguments[e++]); return E(n, r, this, this, i) }; return r }, m.bindAll = function (n) { var t, r, e = arguments.length; if (1 >= e) throw new Error(\"bindAll must be passed function names\"); for (t = 1; e > t; t++) r = arguments[t], n[r] = m.bind(n[r], n); return n }, m.memoize = function (n, t) { var r = function (e) { var u = r.cache, i = \"\" + (t ? t.apply(this, arguments) : e); return m.has(u, i) || (u[i] = n.apply(this, arguments)), u[i] }; return r.cache = {}, r }, m.delay = function (n, t) { var r = l.call(arguments, 2); return setTimeout(function () { return n.apply(null, r) }, t) }, m.defer = m.partial(m.delay, m, 1), m.throttle = function (n, t, r) { var e, u, i, o = null, a = 0; r || (r = {}); var c = function () { a = r.leading === !1 ? 0 : m.now(), o = null, i = n.apply(e, u), o || (e = u = null) }; return function () { var f = m.now(); a || r.leading !== !1 || (a = f); var l = t - (f - a); return e = this, u = arguments, 0 >= l || l > t ? (o && (clearTimeout(o), o = null), a = f, i = n.apply(e, u), o || (e = u = null)) : o || r.trailing === !1 || (o = setTimeout(c, l)), i } }, m.debounce = function (n, t, r) { var e, u, i, o, a, c = function () { var f = m.now() - o; t > f && f >= 0 ? e = setTimeout(c, t - f) : (e = null, r || (a = n.apply(i, u), e || (i = u = null))) }; return function () { i = this, u = arguments, o = m.now(); var f = r && !e; return e || (e = setTimeout(c, t)), f && (a = n.apply(i, u), i = u = null), a } }, m.wrap = function (n, t) { return m.partial(t, n) }, m.negate = function (n) { return function () { return !n.apply(this, arguments) } }, m.compose = function () { var n = arguments, t = n.length - 1; return function () { for (var r = t, e = n[t].apply(this, arguments) ; r--;) e = n[r].call(this, e); return e } }, m.after = function (n, t) { return function () { return --n < 1 ? t.apply(this, arguments) : void 0 } }, m.before = function (n, t) { var r; return function () { return --n > 0 && (r = t.apply(this, arguments)), 1 >= n && (t = null), r } }, m.once = m.partial(m.before, 2); var M = !{ toString: null }.propertyIsEnumerable(\"toString\"), I = [\"valueOf\", \"isPrototypeOf\", \"toString\", \"propertyIsEnumerable\", \"hasOwnProperty\", \"toLocaleString\"]; m.keys = function (n) { if (!m.isObject(n)) return []; if (v) return v(n); var t = []; for (var r in n) m.has(n, r) && t.push(r); return M && e(n, t), t }, m.allKeys = function (n) { if (!m.isObject(n)) return []; var t = []; for (var r in n) t.push(r); return M && e(n, t), t }, m.values = function (n) { for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = n[t[u]]; return e }, m.mapObject = function (n, t, r) { t = x(t, r); for (var e, u = m.keys(n), i = u.length, o = {}, a = 0; i > a; a++) e = u[a], o[e] = t(n[e], e, n); return o }, m.pairs = function (n) { for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = [t[u], n[t[u]]]; return e }, m.invert = function (n) { for (var t = {}, r = m.keys(n), e = 0, u = r.length; u > e; e++) t[n[r[e]]] = r[e]; return t }, m.functions = m.methods = function (n) { var t = []; for (var r in n) m.isFunction(n[r]) && t.push(r); return t.sort() }, m.extend = _(m.allKeys), m.extendOwn = m.assign = _(m.keys), m.findKey = function (n, t, r) { t = x(t, r); for (var e, u = m.keys(n), i = 0, o = u.length; o > i; i++) if (e = u[i], t(n[e], e, n)) return e }, m.pick = function (n, t, r) { var e, u, i = {}, o = n; if (null == o) return i; m.isFunction(t) ? (u = m.allKeys(o), e = b(t, r)) : (u = S(arguments, !1, !1, 1), e = function (n, t, r) { return t in r }, o = Object(o)); for (var a = 0, c = u.length; c > a; a++) { var f = u[a], l = o[f]; e(l, f, o) && (i[f] = l) } return i }, m.omit = function (n, t, r) { if (m.isFunction(t)) t = m.negate(t); else { var e = m.map(S(arguments, !1, !1, 1), String); t = function (n, t) { return !m.contains(e, t) } } return m.pick(n, t, r) }, m.defaults = _(m.allKeys, !0), m.create = function (n, t) { var r = j(n); return t && m.extendOwn(r, t), r }, m.clone = function (n) { return m.isObject(n) ? m.isArray(n) ? n.slice() : m.extend({}, n) : n }, m.tap = function (n, t) { return t(n), n }, m.isMatch = function (n, t) { var r = m.keys(t), e = r.length; if (null == n) return !e; for (var u = Object(n), i = 0; e > i; i++) { var o = r[i]; if (t[o] !== u[o] || !(o in u)) return !1 } return !0 }; var N = function (n, t, r, e) { if (n === t) return 0 !== n || 1 / n === 1 / t; if (null == n || null == t) return n === t; n instanceof m && (n = n._wrapped), t instanceof m && (t = t._wrapped); var u = s.call(n); if (u !== s.call(t)) return !1; switch (u) { case \"[object RegExp]\": case \"[object String]\": return \"\" + n == \"\" + t; case \"[object Number]\": return +n !== +n ? +t !== +t : 0 === +n ? 1 / +n === 1 / t : +n === +t; case \"[object Date]\": case \"[object Boolean]\": return +n === +t } var i = \"[object Array]\" === u; if (!i) { if (\"object\" != typeof n || \"object\" != typeof t) return !1; var o = n.constructor, a = t.constructor; if (o !== a && !(m.isFunction(o) && o instanceof o && m.isFunction(a) && a instanceof a) && \"constructor\" in n && \"constructor\" in t) return !1 } r = r || [], e = e || []; for (var c = r.length; c--;) if (r[c] === n) return e[c] === t; if (r.push(n), e.push(t), i) { if (c = n.length, c !== t.length) return !1; for (; c--;) if (!N(n[c], t[c], r, e)) return !1 } else { var f, l = m.keys(n); if (c = l.length, m.keys(t).length !== c) return !1; for (; c--;) if (f = l[c], !m.has(t, f) || !N(n[f], t[f], r, e)) return !1 } return r.pop(), e.pop(), !0 }; m.isEqual = function (n, t) { return N(n, t) }, m.isEmpty = function (n) { return null == n ? !0 : k(n) && (m.isArray(n) || m.isString(n) || m.isArguments(n)) ? 0 === n.length : 0 === m.keys(n).length }, m.isElement = function (n) { return !(!n || 1 !== n.nodeType) }, m.isArray = h || function (n) { return \"[object Array]\" === s.call(n) }, m.isObject = function (n) { var t = typeof n; return \"function\" === t || \"object\" === t && !!n }, m.each([\"Arguments\", \"Function\", \"String\", \"Number\", \"Date\", \"RegExp\", \"Error\"], function (n) { m[\"is\" + n] = function (t) { return s.call(t) === \"[object \" + n + \"]\" } }), m.isArguments(arguments) || (m.isArguments = function (n) { return m.has(n, \"callee\") }), \"function\" != typeof /./ && \"object\" != typeof Int8Array && (m.isFunction = function (n) { return \"function\" == typeof n || !1 }), m.isFinite = function (n) { return isFinite(n) && !isNaN(parseFloat(n)) }, m.isNaN = function (n) { return m.isNumber(n) && n !== +n }, m.isBoolean = function (n) { return n === !0 || n === !1 || \"[object Boolean]\" === s.call(n) }, m.isNull = function (n) { return null === n }, m.isUndefined = function (n) { return n === void 0 }, m.has = function (n, t) { return null != n && p.call(n, t) }, m.noConflict = function () { return u._ = i, this }, m.identity = function (n) { return n }, m.constant = function (n) { return function () { return n } }, m.noop = function () { }, m.property = w, m.propertyOf = function (n) { return null == n ? function () { } : function (t) { return n[t] } }, m.matcher = m.matches = function (n) { return n = m.extendOwn({}, n), function (t) { return m.isMatch(t, n) } }, m.times = function (n, t, r) { var e = Array(Math.max(0, n)); t = b(t, r, 1); for (var u = 0; n > u; u++) e[u] = t(u); return e }, m.random = function (n, t) { return null == t && (t = n, n = 0), n + Math.floor(Math.random() * (t - n + 1)) }, m.now = Date.now || function () { return (new Date).getTime() }; var B = { \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#x27;\", \"`\": \"&#x60;\" }, T = m.invert(B), R = function (n) { var t = function (t) { return n[t] }, r = \"(?:\" + m.keys(n).join(\"|\") + \")\", e = RegExp(r), u = RegExp(r, \"g\"); return function (n) { return n = null == n ? \"\" : \"\" + n, e.test(n) ? n.replace(u, t) : n } }; m.escape = R(B), m.unescape = R(T), m.result = function (n, t, r) { var e = null == n ? void 0 : n[t]; return e === void 0 && (e = r), m.isFunction(e) ? e.call(n) : e }; var q = 0; m.uniqueId = function (n) { var t = ++q + \"\"; return n ? n + t : t }, m.templateSettings = { evaluate: /<%([\\s\\S]+?)%>/g, interpolate: /<%=([\\s\\S]+?)%>/g, escape: /<%-([\\s\\S]+?)%>/g }; var K = /(.)^/, z = { \"'\": \"'\", \"\\\\\": \"\\\\\", \"\\r\": \"r\", \"\\n\": \"n\", \"\\u2028\": \"u2028\", \"\\u2029\": \"u2029\" }, D = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g, L = function (n) { return \"\\\\\" + z[n] }; m.template = function (n, t, r) { !t && r && (t = r), t = m.defaults({}, t, m.templateSettings); var e = RegExp([(t.escape || K).source, (t.interpolate || K).source, (t.evaluate || K).source].join(\"|\") + \"|$\", \"g\"), u = 0, i = \"__p+='\"; n.replace(e, function (t, r, e, o, a) { return i += n.slice(u, a).replace(D, L), u = a + t.length, r ? i += \"'+\\n((__t=(\" + r + \"))==null?'':_.escape(__t))+\\n'\" : e ? i += \"'+\\n((__t=(\" + e + \"))==null?'':__t)+\\n'\" : o && (i += \"';\\n\" + o + \"\\n__p+='\"), t }), i += \"';\\n\", t.variable || (i = \"with(obj||{}){\\n\" + i + \"}\\n\"), i = \"var __t,__p='',__j=Array.prototype.join,\" + \"print=function(){__p+=__j.call(arguments,'');};\\n\" + i + \"return __p;\\n\"; try { var o = new Function(t.variable || \"obj\", \"_\", i) } catch (a) { throw a.source = i, a } var c = function (n) { return o.call(this, n, m) }, f = t.variable || \"obj\"; return c.source = \"function(\" + f + \"){\\n\" + i + \"}\", c }, m.chain = function (n) { var t = m(n); return t._chain = !0, t }; var P = function (n, t) { return n._chain ? m(t).chain() : t }; m.mixin = function (n) { m.each(m.functions(n), function (t) { var r = m[t] = n[t]; m.prototype[t] = function () { var n = [this._wrapped]; return f.apply(n, arguments), P(this, r.apply(m, n)) } }) }, m.mixin(m), m.each([\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"], function (n) { var t = o[n]; m.prototype[n] = function () { var r = this._wrapped; return t.apply(r, arguments), \"shift\" !== n && \"splice\" !== n || 0 !== r.length || delete r[0], P(this, r) } }), m.each([\"concat\", \"join\", \"slice\"], function (n) { var t = o[n]; m.prototype[n] = function () { return P(this, t.apply(this._wrapped, arguments)) } }), m.prototype.value = function () { return this._wrapped }, m.prototype.valueOf = m.prototype.toJSON = m.prototype.value, m.prototype.toString = function () { return \"\" + this._wrapped }, \"function\" == typeof define && define.amd && define(\"underscore\", [], function () { return m }) }).call(this);\n//# sourceMappingURL=underscore-min.map\n/**\n * @ngdoc module\n * @name gettext\n * @packageName angular-gettext\n * @description Super simple Gettext for Angular.JS\n *\n * A sample application can be found at https://github.com/rubenv/angular-gettext-example.\n * This is an adaptation of the [TodoMVC](http://todomvc.com/) example. You can use this as a guideline while adding {@link angular-gettext angular-gettext} to your own application.\n * Version 2.4.1\n */\n/**\n * @ngdoc factory\n * @module gettext\n * @name gettextPlurals\n * @param {String} [langCode=en] language code\n * @param {Number} [n=0] number to calculate form for\n * @returns {Number} plural form number\n * @description Provides correct plural form id for the given language\n *\n * Example\n * ```js\n * gettextPlurals('ru', 10); // 1\n * gettextPlurals('en', 1);  // 0\n * gettextPlurals();         // 1\n * ```\n */\nangular.module('gettext', []);\n/**\n * @ngdoc object\n * @module gettext\n * @name gettext\n * @kind function\n * @param {String} str annotation key\n * @description Gettext constant function for annotating strings\n *\n * ```js\n * angular.module('myApp', ['gettext']).config(function(gettext) {\n *   /// MyApp document title\n *   gettext('my-app.title');\n *   ...\n * })\n * ```\n */\nangular.module('gettext').constant('gettext', function (str) {\n    /*\n     * Does nothing, simply returns the input string.\n     *\n     * This function serves as a marker for `grunt-angular-gettext` to know that\n     * this string should be extracted for translations.\n     */\n    return str;\n});\n\n/**\n * @ngdoc service\n * @module gettext\n * @name gettextCatalog\n * @requires gettextPlurals\n * @requires gettextFallbackLanguage\n * @requires https://docs.angularjs.org/api/ng/service/$http $http\n * @requires https://docs.angularjs.org/api/ng/service/$cacheFactory $cacheFactory\n * @requires https://docs.angularjs.org/api/ng/service/$interpolate $interpolate\n * @requires https://docs.angularjs.org/api/ng/service/$rootScope $rootScope\n * @description Provides set of method to translate strings\n */\nangular.module('gettext').factory('gettextCatalog', [\"gettextPlurals\", \"gettextFallbackLanguage\", \"$http\", \"$cacheFactory\", \"$interpolate\", \"$rootScope\", function (gettextPlurals, gettextFallbackLanguage, $http, $cacheFactory, $interpolate, $rootScope) {\n    var catalog;\n    var noContext = '$$noContext';\n\n    // IE8 returns UPPER CASE tags, even though the source is lower case.\n    // This can causes the (key) string in the DOM to have a different case to\n    // the string in the `po` files.\n    // IE9, IE10 and IE11 reorders the attributes of tags.\n    var test = '<span id=\"test\" title=\"test\" class=\"tested\">test</span>';\n    var isHTMLModified = (angular.element('<span>' + test + '</span>').html() !== test);\n\n    var prefixDebug = function (string) {\n        if (catalog.debug && catalog.currentLanguage !== catalog.baseLanguage) {\n            return catalog.debugPrefix + string;\n        } else {\n            return string;\n        }\n    };\n\n    var addTranslatedMarkers = function (string) {\n        if (catalog.showTranslatedMarkers) {\n            return catalog.translatedMarkerPrefix + string + catalog.translatedMarkerSuffix;\n        } else {\n            return string;\n        }\n    };\n\n    function broadcastUpdated() {\n        /**\n         * @ngdoc event\n         * @name gettextCatalog#gettextLanguageChanged\n         * @eventType broadcast on $rootScope\n         * @description Fires language change notification without any additional parameters.\n         */\n        $rootScope.$broadcast('gettextLanguageChanged');\n    }\n\n    catalog = {\n        /**\n         * @ngdoc property\n         * @name gettextCatalog#debug\n         * @public\n         * @type {Boolean} false\n         * @see gettextCatalog#debug\n         * @description Whether or not to prefix untranslated strings with `[MISSING]:` or a custom prefix.\n         */\n        debug: false,\n        /**\n         * @ngdoc property\n         * @name gettextCatalog#debugPrefix\n         * @public\n         * @type {String} [MISSING]:\n         * @description Custom prefix for untranslated strings when {@link gettextCatalog#debug gettextCatalog#debug} set to `true`.\n         */\n        debugPrefix: '[MISSING]: ',\n        /**\n         * @ngdoc property\n         * @name gettextCatalog#showTranslatedMarkers\n         * @public\n         * @type {Boolean} false\n         * @description Whether or not to wrap all processed text with markers.\n         *\n         * Example output: `[Welcome]`\n         */\n        showTranslatedMarkers: false,\n        /**\n         * @ngdoc property\n         * @name gettextCatalog#translatedMarkerPrefix\n         * @public\n         * @type {String} [\n         * @description Custom prefix to mark strings that have been run through {@link angular-gettext angular-gettext}.\n         */\n        translatedMarkerPrefix: '[',\n        /**\n         * @ngdoc property\n         * @name gettextCatalog#translatedMarkerSuffix\n         * @public\n         * @type {String} ]\n         * @description Custom suffix to mark strings that have been run through {@link angular-gettext angular-gettext}.\n         */\n        translatedMarkerSuffix: ']',\n        /**\n         * @ngdoc property\n         * @name gettextCatalog#strings\n         * @private\n         * @type {Object}\n         * @description An object of loaded translation strings. Shouldn't be used directly.\n         */\n        strings: {},\n        /**\n         * @ngdoc property\n         * @name gettextCatalog#baseLanguage\n         * @protected\n         * @deprecated\n         * @since 2.0\n         * @type {String} en\n         * @description The default language, in which you're application is written.\n         *\n         * This defaults to English and it's generally a bad idea to use anything else:\n         * if your language has different pluralization rules you'll end up with incorrect translations.\n         */\n        baseLanguage: 'en',\n        /**\n         * @ngdoc property\n         * @name gettextCatalog#currentLanguage\n         * @public\n         * @type {String}\n         * @description Active language.\n         */\n        currentLanguage: 'en',\n        /**\n         * @ngdoc property\n         * @name gettextCatalog#cache\n         * @public\n         * @type {String} en\n         * @description Language cache for lazy load\n         */\n        cache: $cacheFactory('strings'),\n\n        /**\n         * @ngdoc method\n         * @name gettextCatalog#setCurrentLanguage\n         * @public\n         * @param {String} lang language name\n         * @description Sets the current language and makes sure that all translations get updated correctly.\n         */\n        setCurrentLanguage: function (lang) {\n            this.currentLanguage = lang;\n            broadcastUpdated();\n        },\n\n        /**\n         * @ngdoc method\n         * @name gettextCatalog#getCurrentLanguage\n         * @public\n         * @returns {String} current language\n         * @description Returns the current language.\n         */\n        getCurrentLanguage: function () {\n            return this.currentLanguage;\n        },\n\n        /**\n         * @ngdoc method\n         * @name gettextCatalog#setStrings\n         * @public\n         * @param {String} language language name\n         * @param {Object.<String>} strings set of strings where the key is the translation `key` and `value` is the translated text\n         * @description Processes an object of string definitions. {@link guide:manual-setstrings More details here}.\n         */\n        setStrings: function (language, strings) {\n            if (!this.strings[language]) {\n                this.strings[language] = {};\n            }\n\n            var defaultPlural = gettextPlurals(language, 1);\n            for (var key in strings) {\n                var val = strings[key];\n\n                if (isHTMLModified) {\n                    // Use the DOM engine to render any HTML in the key (#131).\n                    key = angular.element('<span>' + key + '</span>').html();\n                }\n\n                if (angular.isString(val) || angular.isArray(val)) {\n                    // No context, wrap it in $$noContext.\n                    var obj = {};\n                    obj[noContext] = val;\n                    val = obj;\n                }\n\n                if (!this.strings[language][key]) {\n                    this.strings[language][key] = {};\n                }\n\n                for (var context in val) {\n                    var str = val[context];\n                    if (!angular.isArray(str)) {\n                        // Expand single strings\n                        this.strings[language][key][context] = [];\n                        this.strings[language][key][context][defaultPlural] = str;\n                    } else {\n                        this.strings[language][key][context] = str;\n                    }\n                }\n            }\n\n            broadcastUpdated();\n        },\n\n        /**\n         * @ngdoc method\n         * @name gettextCatalog#getStringFormFor\n         * @protected\n         * @param {String} language language name\n         * @param {String} string translation key\n         * @param {Number=} n number to build string form for\n         * @param {String=} context translation key context, e.g. {@link doc:context Verb, Noun}\n         * @returns {String|Null} translated or annotated string or null if language is not set\n         * @description Translate a string with the given language, count and context.\n         */\n        getStringFormFor: function (language, string, n, context) {\n            if (!language) {\n                return null;\n            }\n            var stringTable = this.strings[language] || {};\n            var contexts = stringTable[string] || {};\n            var plurals = contexts[context || noContext] || [];\n            return plurals[gettextPlurals(language, n)];\n        },\n\n        /**\n         * @ngdoc method\n         * @name gettextCatalog#getString\n         * @public\n         * @param {String} string translation key\n         * @param {$rootScope.Scope=} scope scope to do interpolation against\n         * @param {String=} context translation key context, e.g. {@link doc:context Verb, Noun}\n         * @returns {String} translated or annotated string\n         * @description Translate a string with the given scope and context.\n         *\n         * First it tries {@link gettextCatalog#currentLanguage gettextCatalog#currentLanguage} (e.g. `en-US`) then {@link gettextFallbackLanguage fallback} (e.g. `en`).\n         *\n         * When `scope` is supplied it uses Angular.JS interpolation, so something like this will do what you expect:\n         * ```js\n         * var hello = gettextCatalog.getString(\"Hello {{name}}!\", { name: \"Ruben\" });\n         * // var hello will be \"Hallo Ruben!\" in Dutch.\n         * ```\n         * Avoid using scopes - this skips interpolation and is a lot faster.\n         */\n        getString: function (string, scope, context) {\n            var fallbackLanguage = gettextFallbackLanguage(this.currentLanguage);\n            string = this.getStringFormFor(this.currentLanguage, string, 1, context) ||\n                     this.getStringFormFor(fallbackLanguage, string, 1, context) ||\n                     prefixDebug(string);\n            string = scope ? $interpolate(string)(scope) : string;\n            return addTranslatedMarkers(string);\n        },\n\n        /**\n         * @ngdoc method\n         * @name gettextCatalog#getPlural\n         * @public\n         * @param {Number} n number to build string form for\n         * @param {String} string translation key\n         * @param {String} stringPlural plural translation key\n         * @param {$rootScope.Scope=} scope scope to do interpolation against\n         * @param {String=} context translation key context, e.g. {@link doc:context Verb, Noun}\n         * @returns {String} translated or annotated string\n         * @see {@link gettextCatalog#getString gettextCatalog#getString} for details\n         * @description Translate a plural string with the given context.\n         */\n        getPlural: function (n, string, stringPlural, scope, context) {\n            var fallbackLanguage = gettextFallbackLanguage(this.currentLanguage);\n            string = this.getStringFormFor(this.currentLanguage, string, n, context) ||\n                     this.getStringFormFor(fallbackLanguage, string, n, context) ||\n                     prefixDebug(n === 1 ? string : stringPlural);\n            if (scope) {\n                scope.$count = n;\n                string = $interpolate(string)(scope);\n            }\n            return addTranslatedMarkers(string);\n        },\n\n        /**\n         * @ngdoc method\n         * @name gettextCatalog#loadRemote\n         * @public\n         * @param {String} url location of the translations\n         * @description Load a set of translation strings from a given URL.\n         *\n         * This should be a JSON catalog generated with [angular-gettext-tools](https://github.com/rubenv/angular-gettext-tools).\n         * {@link guide:lazy-loading More details here}.\n         */\n        loadRemote: function (url) {\n            return $http({\n                method: 'GET',\n                url: url,\n                cache: catalog.cache\n            }).then(function (response) {\n                var data = response.data;\n                for (var lang in data) {\n                    catalog.setStrings(lang, data[lang]);\n                }\n                return response;\n            });\n        }\n    };\n\n    return catalog;\n}]);\n\n/**\n * @ngdoc directive\n * @module gettext\n * @name translate\n * @requires gettextCatalog\n * @requires gettextUtil\n * @requires https://docs.angularjs.org/api/ng/service/$parse $parse\n * @requires https://docs.angularjs.org/api/ng/service/$animate $animate\n * @requires https://docs.angularjs.org/api/ng/service/$compile $compile\n * @requires https://docs.angularjs.org/api/ng/service/$window $window\n * @restrict AE\n * @param {String} [translatePlural] plural form\n * @param {Number} translateN value to watch to substitute correct plural form\n * @param {String} translateContext context value, e.g. {@link doc:context Verb, Noun}\n * @description Annotates and translates text inside directive\n *\n * Full interpolation support is available in translated strings, so the following will work as expected:\n * ```js\n * <div translate>Hello {{name}}!</div>\n * ```\n *\n * You can also use custom context parameters while interpolating. This approach allows usage\n * of angular filters as well as custom logic inside your translated messages without unnecessary impact on translations.\n *\n * So for example when you have message like this:\n * ```js\n * <div translate>Last modified {{modificationDate | date:'yyyy-MM-dd HH:mm:ss Z'}} by {{author}}.</div>\n * ```\n * you will have it extracted in exact same version so it would look like this:\n * `Last modified {{modificationDate | date:'yyyy-MM-dd HH:mm:ss Z'}} by {{author}}`.\n * To start with it might be too complicated to read and handle by non technical translator. It's easy to make mistake\n * when copying format for example. Secondly if you decide to change format by some point of the project translation will broke\n * as it won't be the same string anymore.\n *\n * Instead your translator should only be concerned to place {{modificationDate}} correctly and you should have a free hand\n * to modify implementation details on how to present the results. This is how you can achieve the goal:\n * ```js\n * <div translate translate-params-modification-date=\"modificationDate | date:'yyyy-MM-dd HH:mm:ss Z'\">Last modified {{modificationDate}} by {{author}}.</div>\n * ```\n *\n * There's a few more things worth to point out:\n * 1. You can use as many parameters as you want. Each parameter begins with `translate-params-` followed by snake-case parameter name.\n * Each parameter will be available for interpolation in camelCase manner (just like angular directive works by default).\n * ```js\n * <div translate translate-params-my-custom-param=\"param1\" translate-params-name=\"name\">Param {{myCustomParam}} has been changed by {{name}}.</div>\n * ```\n * 2. You can rename your variables from current scope to simple ones if you like.\n * ```js\n * <div translate translate-params-date=\"veryUnintuitiveNameForDate\">Today's date is: {{date}}.</div>\n * ```\n * 3. You can use translate-params only for some interpolations. Rest would be treated as usual.\n * ```js\n * <div translate translate-params-cost=\"cost | currency\">This product: {{product}} costs {{cost}}.</div>\n * ```\n */\nangular.module('gettext').directive('translate', [\"gettextCatalog\", \"$parse\", \"$animate\", \"$compile\", \"$window\", \"gettextUtil\", function (gettextCatalog, $parse, $animate, $compile, $window, gettextUtil) {\n    var msie = parseInt((/msie (\\d+)/i.exec($window.navigator.userAgent) || [])[1], 10);\n    var PARAMS_PREFIX = 'translateParams';\n\n    function getCtxAttr(key) {\n        return gettextUtil.lcFirst(key.replace(PARAMS_PREFIX, ''));\n    }\n\n    function handleInterpolationContext(scope, attrs, update) {\n        var attributes = Object.keys(attrs).filter(function (key) {\n            return gettextUtil.startsWith(key, PARAMS_PREFIX) && key !== PARAMS_PREFIX;\n        });\n\n        if (!attributes.length) {\n            return null;\n        }\n\n        var interpolationContext = scope.$new();\n        var unwatchers = [];\n        attributes.forEach(function (attribute) {\n            var unwatch = scope.$watch(attrs[attribute], function (newVal) {\n                var key = getCtxAttr(attribute);\n                interpolationContext[key] = newVal;\n                update(interpolationContext);\n            });\n            unwatchers.push(unwatch);\n        });\n        scope.$on('$destroy', function () {\n            unwatchers.forEach(function (unwatch) {\n                unwatch();\n            });\n\n            interpolationContext.$destroy();\n        });\n        return interpolationContext;\n    }\n\n    return {\n        restrict: 'AE',\n        terminal: true,\n        compile: function compile(element, attrs) {\n            // Validate attributes\n            gettextUtil.assert(!attrs.translatePlural || attrs.translateN, 'translate-n', 'translate-plural');\n            gettextUtil.assert(!attrs.translateN || attrs.translatePlural, 'translate-plural', 'translate-n');\n\n            var msgid = gettextUtil.trim(element.html());\n            var translatePlural = attrs.translatePlural;\n            var translateContext = attrs.translateContext;\n\n            if (msie <= 8) {\n                // Workaround fix relating to angular adding a comment node to\n                // anchors. angular/angular.js/#1949 / angular/angular.js/#2013\n                if (msgid.slice(-13) === '<!--IE fix-->') {\n                    msgid = msgid.slice(0, -13);\n                }\n            }\n\n            return {\n                post: function (scope, element, attrs) {\n                    var countFn = $parse(attrs.translateN);\n                    var pluralScope = null;\n                    var linking = true;\n\n                    function update(interpolationContext) {\n                        interpolationContext = interpolationContext || null;\n\n                        // Fetch correct translated string.\n                        var translated;\n                        if (translatePlural) {\n                            scope = pluralScope || (pluralScope = scope.$new());\n                            scope.$count = countFn(scope);\n                            translated = gettextCatalog.getPlural(scope.$count, msgid, translatePlural, null, translateContext);\n                        } else {\n                            translated = gettextCatalog.getString(msgid, null, translateContext);\n                        }\n                        var oldContents = element.contents();\n\n                        if (!oldContents && !translated){\n                            return;\n                        }\n\n                        // Avoid redundant swaps\n                        if (translated === gettextUtil.trim(oldContents.html())){\n                            // Take care of unlinked content\n                            if (linking){\n                                $compile(oldContents)(scope);\n                            }\n                            return;\n                        }\n\n                        // Swap in the translation\n                        var newWrapper = angular.element('<span>' + translated + '</span>');\n                        $compile(newWrapper.contents())(interpolationContext || scope);\n                        var newContents = newWrapper.contents();\n\n                        $animate.enter(newContents, element);\n                        $animate.leave(oldContents);\n                    }\n\n                    var interpolationContext = handleInterpolationContext(scope, attrs, update);\n                    update(interpolationContext);\n                    linking = false;\n\n                    if (attrs.translateN) {\n                        scope.$watch(attrs.translateN, function () {\n                            update(interpolationContext);\n                        });\n                    }\n\n                    /**\n                     * @ngdoc event\n                     * @name translate#gettextLanguageChanged\n                     * @eventType listen on scope\n                     * @description Listens for language updates and changes translation accordingly\n                     */\n                    scope.$on('gettextLanguageChanged', function () {\n                        update(interpolationContext);\n                    });\n\n                }\n            };\n        }\n    };\n}]);\n\n/**\n * @ngdoc factory\n * @module gettext\n * @name gettextFallbackLanguage\n * @param {String} langCode language code\n * @returns {String|Null} fallback language\n * @description Strips regional code and returns language code only\n *\n * Example\n * ```js\n * gettextFallbackLanguage('ru');     // \"null\"\n * gettextFallbackLanguage('en_GB');  // \"en\"\n * gettextFallbackLanguage();         // null\n * ```\n */\nangular.module(\"gettext\").factory(\"gettextFallbackLanguage\", function () {\n    var cache = {};\n    var pattern = /([^_]+)_[^_]+$/;\n\n    return function (langCode) {\n        if (cache[langCode]) {\n            return cache[langCode];\n        }\n\n        var matches = pattern.exec(langCode);\n        if (matches) {\n            cache[langCode] = matches[1];\n            return matches[1];\n        }\n\n        return null;\n    };\n});\n/**\n * @ngdoc filter\n * @module gettext\n * @name translate\n * @requires gettextCatalog\n * @param {String} input translation key\n * @param {String} context context to evaluate key against\n * @returns {String} translated string or annotated key\n * @see {@link doc:context Verb, Noun}\n * @description Takes key and returns string\n *\n * Sometimes it's not an option to use an attribute (e.g. when you want to annotate an attribute value).\n * There's a `translate` filter available for this purpose.\n *\n * ```html\n * <input type=\"text\" placeholder=\"{{'Username'|translate}}\" />\n * ```\n * This filter does not support plural strings.\n *\n * You may want to use {@link guide:custom-annotations custom annotations} to avoid using the `translate` filter all the time. * Is\n */\nangular.module('gettext').filter('translate', [\"gettextCatalog\", function (gettextCatalog) {\n    function filter(input, context) {\n        return gettextCatalog.getString(input, null, context);\n    }\n    filter.$stateful = true;\n    return filter;\n}]);\n\n// Do not edit this file, it is autogenerated using genplurals.py!\nangular.module(\"gettext\").factory(\"gettextPlurals\", function () {\n    var languageCodes = {\n        \"pt_BR\": \"pt_BR\",\n        \"pt-BR\": \"pt_BR\"\n    };\n    return function (langCode, n) {\n        switch (getLanguageCode(langCode)) {\n            case \"ay\":  // Aymará\n            case \"bo\":  // Tibetan\n            case \"cgg\": // Chiga\n            case \"dz\":  // Dzongkha\n            case \"fa\":  // Persian\n            case \"id\":  // Indonesian\n            case \"ja\":  // Japanese\n            case \"jbo\": // Lojban\n            case \"ka\":  // Georgian\n            case \"kk\":  // Kazakh\n            case \"km\":  // Khmer\n            case \"ko\":  // Korean\n            case \"ky\":  // Kyrgyz\n            case \"lo\":  // Lao\n            case \"ms\":  // Malay\n            case \"my\":  // Burmese\n            case \"sah\": // Yakut\n            case \"su\":  // Sundanese\n            case \"th\":  // Thai\n            case \"tt\":  // Tatar\n            case \"ug\":  // Uyghur\n            case \"vi\":  // Vietnamese\n            case \"wo\":  // Wolof\n            case \"zh\":  // Chinese\n                // 1 form\n                return 0;\n            case \"is\":  // Icelandic\n                // 2 forms\n                return (n%10!=1 || n%100==11) ? 1 : 0;\n            case \"jv\":  // Javanese\n                // 2 forms\n                return n!=0 ? 1 : 0;\n            case \"mk\":  // Macedonian\n                // 2 forms\n                return n==1 || n%10==1 ? 0 : 1;\n            case \"ach\": // Acholi\n            case \"ak\":  // Akan\n            case \"am\":  // Amharic\n            case \"arn\": // Mapudungun\n            case \"br\":  // Breton\n            case \"fil\": // Filipino\n            case \"fr\":  // French\n            case \"gun\": // Gun\n            case \"ln\":  // Lingala\n            case \"mfe\": // Mauritian Creole\n            case \"mg\":  // Malagasy\n            case \"mi\":  // Maori\n            case \"oc\":  // Occitan\n            case \"pt_BR\":  // Brazilian Portuguese\n            case \"tg\":  // Tajik\n            case \"ti\":  // Tigrinya\n            case \"tr\":  // Turkish\n            case \"uz\":  // Uzbek\n            case \"wa\":  // Walloon\n            case \"zh\":  // Chinese\n                // 2 forms\n                return n>1 ? 1 : 0;\n            case \"lv\":  // Latvian\n                // 3 forms\n                return (n%10==1 && n%100!=11 ? 0 : n != 0 ? 1 : 2);\n            case \"lt\":  // Lithuanian\n                // 3 forms\n                return (n%10==1 && n%100!=11 ? 0 : n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2);\n            case \"be\":  // Belarusian\n            case \"bs\":  // Bosnian\n            case \"hr\":  // Croatian\n            case \"ru\":  // Russian\n            case \"sr\":  // Serbian\n            case \"uk\":  // Ukrainian\n                // 3 forms\n                return (n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n            case \"mnk\": // Mandinka\n                // 3 forms\n                return (n==0 ? 0 : n==1 ? 1 : 2);\n            case \"ro\":  // Romanian\n                // 3 forms\n                return (n==1 ? 0 : (n==0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2);\n            case \"pl\":  // Polish\n                // 3 forms\n                return (n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n            case \"cs\":  // Czech\n            case \"sk\":  // Slovak\n                // 3 forms\n                return (n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;\n            case \"sl\":  // Slovenian\n                // 4 forms\n                return (n%100==1 ? 1 : n%100==2 ? 2 : n%100==3 || n%100==4 ? 3 : 0);\n            case \"mt\":  // Maltese\n                // 4 forms\n                return (n==1 ? 0 : n==0 || ( n%100>1 && n%100<11) ? 1 : (n%100>10 && n%100<20 ) ? 2 : 3);\n            case \"gd\":  // Scottish Gaelic\n                // 4 forms\n                return (n==1 || n==11) ? 0 : (n==2 || n==12) ? 1 : (n > 2 && n < 20) ? 2 : 3;\n            case \"cy\":  // Welsh\n                // 4 forms\n                return (n==1) ? 0 : (n==2) ? 1 : (n != 8 && n != 11) ? 2 : 3;\n            case \"kw\":  // Cornish\n                // 4 forms\n                return (n==1) ? 0 : (n==2) ? 1 : (n == 3) ? 2 : 3;\n            case \"ga\":  // Irish\n                // 5 forms\n                return n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : 4;\n            case \"ar\":  // Arabic\n                // 6 forms\n                return (n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5);\n            default: // Everything else\n                return n != 1 ? 1 : 0;\n        }\n    };\n\n    /**\n     * Method extracts iso639-2 language code from code with locale e.g. pl_PL, en_US, etc.\n     * If it's provided with standalone iso639-2 language code it simply returns it.\n     * @param {String} langCode\n     * @returns {String} iso639-2 language Code\n     */\n    function getLanguageCode(langCode) {\n        if (!languageCodes[langCode]) {\n            languageCodes[langCode] = langCode.split(/\\-|_/).shift();\n        }\n        return languageCodes[langCode];\n    }\n});\n\n/**\n * @ngdoc factory\n * @module gettext\n * @name gettextUtil\n * @description Utility service for common operations and polyfills.\n */\nangular.module('gettext').factory('gettextUtil', function gettextUtil() {\n    /**\n     * @ngdoc method\n     * @name gettextUtil#trim\n     * @public\n     * @param {string} value String to be trimmed.\n     * @description Trim polyfill for old browsers (instead of jQuery). Based on AngularJS-v1.2.2 (angular.js#620).\n     *\n     * Example\n     * ```js\n     * gettextUtil.assert('  no blanks  '); // \"no blanks\"\n     * ```\n     */\n    var trim = (function () {\n        if (!String.prototype.trim) {\n            return function (value) {\n                return (typeof value === 'string') ? value.replace(/^\\s*/, '').replace(/\\s*$/, '') : value;\n            };\n        }\n        return function (value) {\n            return (typeof value === 'string') ? value.trim() : value;\n        };\n    })();\n\n    /**\n     * @ngdoc method\n     * @name gettextUtil#assert\n     * @public\n     * @param {bool} condition condition to check\n     * @param {String} missing name of the directive missing attribute\n     * @param {String} found name of attribute that has been used with directive\n     * @description Throws error if condition is not met, which means that directive was used with certain parameter\n     * that requires another one (which is missing).\n     *\n     * Example\n     * ```js\n     * gettextUtil.assert(!attrs.translatePlural || attrs.translateN, 'translate-n', 'translate-plural');\n     * //You should add a translate-n attribute whenever you add a translate-plural attribute.\n     * ```\n     */\n    function assert(condition, missing, found) {\n        if (!condition) {\n            throw new Error('You should add a ' + missing + ' attribute whenever you add a ' + found + ' attribute.');\n        }\n    }\n\n    /**\n     * @ngdoc method\n     * @name gettextUtil#startsWith\n     * @public\n     * @param {string} target String on which checking will occur.\n     * @param {string} query String expected to be at the beginning of target.\n     * @returns {boolean} Returns true if object has no ownProperties. For arrays returns true if length == 0.\n     * @description Checks if string starts with another string.\n     *\n     * Example\n     * ```js\n     * gettextUtil.startsWith('Home sweet home.', 'Home'); //true\n     * gettextUtil.startsWith('Home sweet home.', 'sweet'); //false\n     * ```\n     */\n    function startsWith(target, query) {\n        return target.indexOf(query) === 0;\n    }\n\n    /**\n     * @ngdoc method\n     * @name gettextUtil#lcFirst\n     * @public\n     * @param {string} target String to transform.\n     * @returns {string} Strings beginning with lowercase letter.\n     * @description Makes first letter of the string lower case\n     *\n     * Example\n     * ```js\n     * gettextUtil.lcFirst('Home Sweet Home.'); //'home Sweet Home'\n     * gettextUtil.lcFirst('ShouldBeCamelCase.'); //'shouldBeCamelCase'\n     * ```\n     */\n    function lcFirst(target) {\n        var first = target.charAt(0).toLowerCase();\n        return first + target.substr(1);\n    }\n\n    return {\n        trim: trim,\n        assert: assert,\n        startsWith: startsWith,\n        lcFirst: lcFirst\n    };\n});\n\n// https://github.com/oblador/angular-scroll\nvar duScrollDefaultEasing = function (e) { \"use strict\"; return .5 > e ? Math.pow(2 * e, 2) / 2 : 1 - Math.pow(2 * (1 - e), 2) / 2 }; angular.module(\"duScroll\", [\"duScroll.scrollspy\", \"duScroll.smoothScroll\", \"duScroll.scrollContainer\", \"duScroll.spyContext\", \"duScroll.scrollHelpers\"]).value(\"duScrollDuration\", 350).value(\"duScrollSpyWait\", 100).value(\"duScrollGreedy\", !1).value(\"duScrollOffset\", 0).value(\"duScrollEasing\", duScrollDefaultEasing).value(\"duScrollCancelOnEvents\", \"scroll mousedown mousewheel touchmove keydown\").value(\"duScrollBottomSpy\", !1).value(\"duScrollActiveClass\", \"active\"), angular.module(\"duScroll.scrollHelpers\", [\"duScroll.requestAnimation\"]).run([\"$window\", \"$q\", \"cancelAnimation\", \"requestAnimation\", \"duScrollEasing\", \"duScrollDuration\", \"duScrollOffset\", \"duScrollCancelOnEvents\", function (e, t, n, r, o, l, u, i) { \"use strict\"; var c = {}, a = function (e) { return \"undefined\" != typeof HTMLDocument && e instanceof HTMLDocument || e.nodeType && e.nodeType === e.DOCUMENT_NODE }, s = function (e) { return \"undefined\" != typeof HTMLElement && e instanceof HTMLElement || e.nodeType && e.nodeType === e.ELEMENT_NODE }, d = function (e) { return s(e) || a(e) ? e : e[0] }; c.duScrollTo = function (t, n, r, o) { var l; if (angular.isElement(t) ? l = this.duScrollToElement : angular.isDefined(r) && (l = this.duScrollToAnimated), l) return l.apply(this, arguments); var u = d(this); return a(u) ? e.scrollTo(t, n) : (u.scrollLeft = t, void (u.scrollTop = n)) }; var f, p; c.duScrollToAnimated = function (e, l, u, c) { u && !c && (c = o); var a = this.duScrollLeft(), s = this.duScrollTop(), d = Math.round(e - a), m = Math.round(l - s), S = null, g = 0, h = this, v = function (e) { (!e || g && e.which > 0) && (i && h.unbind(i, v), n(f), p.reject(), f = null) }; if (f && v(), p = t.defer(), 0 === u || !d && !m) return 0 === u && h.duScrollTo(e, l), p.resolve(), p.promise; var y = function (e) { null === S && (S = e), g = e - S; var t = g >= u ? 1 : c(g / u); h.scrollTo(a + Math.ceil(d * t), s + Math.ceil(m * t)), 1 > t ? f = r(y) : (i && h.unbind(i, v), f = null, p.resolve()) }; return h.duScrollTo(a, s), i && h.bind(i, v), f = r(y), p.promise }, c.duScrollToElement = function (e, t, n, r) { var o = d(this); (!angular.isNumber(t) || isNaN(t)) && (t = u); var l = this.duScrollTop() + d(e).getBoundingClientRect().top - t; return s(o) && (l -= o.getBoundingClientRect().top), this.duScrollTo(0, l, n, r) }, c.duScrollLeft = function (t, n, r) { if (angular.isNumber(t)) return this.duScrollTo(t, this.duScrollTop(), n, r); var o = d(this); return a(o) ? e.scrollX || document.documentElement.scrollLeft || document.body.scrollLeft : o.scrollLeft }, c.duScrollTop = function (t, n, r) { if (angular.isNumber(t)) return this.duScrollTo(this.duScrollLeft(), t, n, r); var o = d(this); return a(o) ? e.scrollY || document.documentElement.scrollTop || document.body.scrollTop : o.scrollTop }, c.duScrollToElementAnimated = function (e, t, n, r) { return this.duScrollToElement(e, t, n || l, r) }, c.duScrollTopAnimated = function (e, t, n) { return this.duScrollTop(e, t || l, n) }, c.duScrollLeftAnimated = function (e, t, n) { return this.duScrollLeft(e, t || l, n) }, angular.forEach(c, function (e, t) { angular.element.prototype[t] = e; var n = t.replace(/^duScroll/, \"scroll\"); angular.isUndefined(angular.element.prototype[n]) && (angular.element.prototype[n] = e) }) }]), angular.module(\"duScroll.polyfill\", []).factory(\"polyfill\", [\"$window\", function (e) { \"use strict\"; var t = [\"webkit\", \"moz\", \"o\", \"ms\"]; return function (n, r) { if (e[n]) return e[n]; for (var o, l = n.substr(0, 1).toUpperCase() + n.substr(1), u = 0; u < t.length; u++) if (o = t[u] + l, e[o]) return e[o]; return r } }]), angular.module(\"duScroll.requestAnimation\", [\"duScroll.polyfill\"]).factory(\"requestAnimation\", [\"polyfill\", \"$timeout\", function (e, t) { \"use strict\"; var n = 0, r = function (e, r) { var o = (new Date).getTime(), l = Math.max(0, 16 - (o - n)), u = t(function () { e(o + l) }, l); return n = o + l, u }; return e(\"requestAnimationFrame\", r) }]).factory(\"cancelAnimation\", [\"polyfill\", \"$timeout\", function (e, t) { \"use strict\"; var n = function (e) { t.cancel(e) }; return e(\"cancelAnimationFrame\", n) }]), angular.module(\"duScroll.spyAPI\", [\"duScroll.scrollContainerAPI\"]).factory(\"spyAPI\", [\"$rootScope\", \"$timeout\", \"$window\", \"$document\", \"scrollContainerAPI\", \"duScrollGreedy\", \"duScrollSpyWait\", \"duScrollBottomSpy\", \"duScrollActiveClass\", function (e, t, n, r, o, l, u, i, c) { \"use strict\"; var a = function (o) { var a = !1, s = !1, d = function () { s = !1; var t, u = o.container, a = u[0], d = 0; \"undefined\" != typeof HTMLElement && a instanceof HTMLElement || a.nodeType && a.nodeType === a.ELEMENT_NODE ? (d = a.getBoundingClientRect().top, t = Math.round(a.scrollTop + a.clientHeight) >= a.scrollHeight) : t = Math.round(n.pageYOffset + n.innerHeight) >= r[0].body.scrollHeight; var f, p, m, S, g, h, v = i && t ? \"bottom\" : \"top\"; for (S = o.spies, p = o.currentlyActive, m = void 0, f = 0; f < S.length; f++) g = S[f], h = g.getTargetPosition(), h && (i && t || h.top + g.offset - d < 20 && (l || -1 * h.top + d) < h.height) && (!m || m[v] < h[v]) && (m = { spy: g }, m[v] = h[v]); m && (m = m.spy), p === m || l && !m || (p && (p.$element.removeClass(c), e.$broadcast(\"duScrollspy:becameInactive\", p.$element, angular.element(p.getTargetElement()))), m && (m.$element.addClass(c), e.$broadcast(\"duScrollspy:becameActive\", m.$element, angular.element(m.getTargetElement()))), o.currentlyActive = m) }; return u ? function () { a ? s = !0 : (d(), a = t(function () { a = !1, s && d() }, u, !1)) } : d }, s = {}, d = function (e) { var t = e.$id, n = { spies: [] }; return n.handler = a(n), s[t] = n, e.$on(\"$destroy\", function () { f(e) }), t }, f = function (e) { var t = e.$id, n = s[t], r = n.container; r && r.off(\"scroll\", n.handler), delete s[t] }, p = d(e), m = function (e) { return s[e.$id] ? s[e.$id] : e.$parent ? m(e.$parent) : s[p] }, S = function (e) { var t, n, r = e.$scope; if (r) return m(r); for (n in s) if (t = s[n], -1 !== t.spies.indexOf(e)) return t }, g = function (e) { for (; e.parentNode;) if (e = e.parentNode, e === document) return !0; return !1 }, h = function (e) { var t = S(e); t && (t.spies.push(e), t.container && g(t.container) || (t.container && t.container.off(\"scroll\", t.handler), t.container = o.getContainer(e.$scope), t.container.on(\"scroll\", t.handler).triggerHandler(\"scroll\"))) }, v = function (e) { var t = S(e); e === t.currentlyActive && (t.currentlyActive = null); var n = t.spies.indexOf(e); -1 !== n && t.spies.splice(n, 1), e.$element = null }; return { addSpy: h, removeSpy: v, createContext: d, destroyContext: f, getContextForScope: m } }]), angular.module(\"duScroll.scrollContainerAPI\", []).factory(\"scrollContainerAPI\", [\"$document\", function (e) { \"use strict\"; var t = {}, n = function (e, n) { var r = e.$id; return t[r] = n, r }, r = function (e) { return t[e.$id] ? e.$id : e.$parent ? r(e.$parent) : void 0 }, o = function (n) { var o = r(n); return o ? t[o] : e }, l = function (e) { var n = r(e); n && delete t[n] }; return { getContainerId: r, getContainer: o, setContainer: n, removeContainer: l } }]), angular.module(\"duScroll.smoothScroll\", [\"duScroll.scrollHelpers\", \"duScroll.scrollContainerAPI\"]).directive(\"duSmoothScroll\", [\"duScrollDuration\", \"duScrollOffset\", \"scrollContainerAPI\", function (e, t, n) { \"use strict\"; return { link: function (r, o, l) { o.on(\"click\", function (o) { if (l.href && -1 !== l.href.indexOf(\"#\") || \"\" !== l.duSmoothScroll) { var u = l.href ? l.href.replace(/.*(?=#[^\\s]+$)/, \"\").substring(1) : l.duSmoothScroll, i = document.getElementById(u) || document.getElementsByName(u)[0]; if (i && i.getBoundingClientRect) { o.stopPropagation && o.stopPropagation(), o.preventDefault && o.preventDefault(); var c = l.offset ? parseInt(l.offset, 10) : t, a = l.duration ? parseInt(l.duration, 10) : e, s = n.getContainer(r); s.duScrollToElement(angular.element(i), isNaN(c) ? 0 : c, isNaN(a) ? 0 : a) } } }) } } }]), angular.module(\"duScroll.spyContext\", [\"duScroll.spyAPI\"]).directive(\"duSpyContext\", [\"spyAPI\", function (e) { \"use strict\"; return { restrict: \"A\", scope: !0, compile: function (t, n, r) { return { pre: function (t, n, r, o) { e.createContext(t) } } } } }]), angular.module(\"duScroll.scrollContainer\", [\"duScroll.scrollContainerAPI\"]).directive(\"duScrollContainer\", [\"scrollContainerAPI\", function (e) { \"use strict\"; return { restrict: \"A\", scope: !0, compile: function (t, n, r) { return { pre: function (t, n, r, o) { r.$observe(\"duScrollContainer\", function (r) { angular.isString(r) && (r = document.getElementById(r)), r = angular.isElement(r) ? angular.element(r) : n, e.setContainer(t, r), t.$on(\"$destroy\", function () { e.removeContainer(t) }) }) } } } } }]), angular.module(\"duScroll.scrollspy\", [\"duScroll.spyAPI\"]).directive(\"duScrollspy\", [\"spyAPI\", \"duScrollOffset\", \"$timeout\", \"$rootScope\", function (e, t, n, r) { \"use strict\"; var o = function (e, t, n, r) { angular.isElement(e) ? this.target = e : angular.isString(e) && (this.targetId = e), this.$scope = t, this.$element = n, this.offset = r }; return o.prototype.getTargetElement = function () { return !this.target && this.targetId && (this.target = document.getElementById(this.targetId) || document.getElementsByName(this.targetId)[0]), this.target }, o.prototype.getTargetPosition = function () { var e = this.getTargetElement(); return e ? e.getBoundingClientRect() : void 0 }, o.prototype.flushTargetCache = function () { this.targetId && (this.target = void 0) }, { link: function (l, u, i) { var c, a = i.ngHref || i.href; if (a && -1 !== a.indexOf(\"#\") ? c = a.replace(/.*(?=#[^\\s]+$)/, \"\").substring(1) : i.duScrollspy ? c = i.duScrollspy : i.duSmoothScroll && (c = i.duSmoothScroll), c) { var s = n(function () { var n = new o(c, l, u, -(i.offset ? parseInt(i.offset, 10) : t)); e.addSpy(n), l.$on(\"$locationChangeSuccess\", n.flushTargetCache.bind(n)); var a = r.$on(\"$stateChangeSuccess\", n.flushTargetCache.bind(n)); l.$on(\"$destroy\", function () { e.removeSpy(n), a() }) }, 0, !1); l.$on(\"$destroy\", function () { n.cancel(s) }) } } } }]);\n//# sourceMappingURL=angular-scroll.min.js.map\n/*! \n * angular-loading-bar v0.9.0\n * https://chieffancypants.github.io/angular-loading-bar\n * Copyright (c) 2016 Wes Cruver\n * License: MIT\n */\n/*\n * angular-loading-bar\n *\n * intercepts XHR requests and creates a loading bar.\n * Based on the excellent nprogress work by rstacruz (more info in readme)\n *\n * (c) 2013 Wes Cruver\n * License: MIT\n */\n\n\n(function() {\n\n'use strict';\n\n// Alias the loading bar for various backwards compatibilities since the project has matured:\nangular.module('angular-loading-bar', ['cfp.loadingBarInterceptor']);\nangular.module('chieffancypants.loadingBar', ['cfp.loadingBarInterceptor']);\n\n\n/**\n * loadingBarInterceptor service\n *\n * Registers itself as an Angular interceptor and listens for XHR requests.\n */\nangular.module('cfp.loadingBarInterceptor', ['cfp.loadingBar'])\n  .config(['$httpProvider', function ($httpProvider) {\n\n    var interceptor = ['$q', '$cacheFactory', '$timeout', '$rootScope', '$log', 'cfpLoadingBar', function ($q, $cacheFactory, $timeout, $rootScope, $log, cfpLoadingBar) {\n\n      /**\n       * The total number of requests made\n       */\n      var reqsTotal = 0;\n\n      /**\n       * The number of requests completed (either successfully or not)\n       */\n      var reqsCompleted = 0;\n\n      /**\n       * The amount of time spent fetching before showing the loading bar\n       */\n      var latencyThreshold = cfpLoadingBar.latencyThreshold;\n\n      /**\n       * $timeout handle for latencyThreshold\n       */\n      var startTimeout;\n\n\n      /**\n       * calls cfpLoadingBar.complete() which removes the\n       * loading bar from the DOM.\n       */\n      function setComplete() {\n        $timeout.cancel(startTimeout);\n        cfpLoadingBar.complete();\n        reqsCompleted = 0;\n        reqsTotal = 0;\n      }\n\n      /**\n       * Determine if the response has already been cached\n       * @param  {Object}  config the config option from the request\n       * @return {Boolean} retrns true if cached, otherwise false\n       */\n      function isCached(config) {\n        var cache;\n        var defaultCache = $cacheFactory.get('$http');\n        var defaults = $httpProvider.defaults;\n\n        // Choose the proper cache source. Borrowed from angular: $http service\n        if ((config.cache || defaults.cache) && config.cache !== false &&\n          (config.method === 'GET' || config.method === 'JSONP')) {\n            cache = angular.isObject(config.cache) ? config.cache\n              : angular.isObject(defaults.cache) ? defaults.cache\n              : defaultCache;\n        }\n\n        var cached = cache !== undefined ?\n          cache.get(config.url) !== undefined : false;\n\n        if (config.cached !== undefined && cached !== config.cached) {\n          return config.cached;\n        }\n        config.cached = cached;\n        return cached;\n      }\n\n\n      return {\n        'request': function(config) {\n          // Check to make sure this request hasn't already been cached and that\n          // the requester didn't explicitly ask us to ignore this request:\n          if (!config.ignoreLoadingBar && !isCached(config)) {\n            $rootScope.$broadcast('cfpLoadingBar:loading', {url: config.url});\n            if (reqsTotal === 0) {\n              startTimeout = $timeout(function() {\n                cfpLoadingBar.start();\n              }, latencyThreshold);\n            }\n            reqsTotal++;\n            cfpLoadingBar.set(reqsCompleted / reqsTotal);\n          }\n          return config;\n        },\n\n        'response': function(response) {\n          if (!response || !response.config) {\n            $log.error('Broken interceptor detected: Config object not supplied in response:\\n https://github.com/chieffancypants/angular-loading-bar/pull/50');\n            return response;\n          }\n\n          if (!response.config.ignoreLoadingBar && !isCached(response.config)) {\n            reqsCompleted++;\n            $rootScope.$broadcast('cfpLoadingBar:loaded', {url: response.config.url, result: response});\n            if (reqsCompleted >= reqsTotal) {\n              setComplete();\n            } else {\n              cfpLoadingBar.set(reqsCompleted / reqsTotal);\n            }\n          }\n          return response;\n        },\n\n        'responseError': function(rejection) {\n          if (!rejection || !rejection.config) {\n            $log.error('Broken interceptor detected: Config object not supplied in rejection:\\n https://github.com/chieffancypants/angular-loading-bar/pull/50');\n            return $q.reject(rejection);\n          }\n\n          if (!rejection.config.ignoreLoadingBar && !isCached(rejection.config)) {\n            reqsCompleted++;\n            $rootScope.$broadcast('cfpLoadingBar:loaded', {url: rejection.config.url, result: rejection});\n            if (reqsCompleted >= reqsTotal) {\n              setComplete();\n            } else {\n              cfpLoadingBar.set(reqsCompleted / reqsTotal);\n            }\n          }\n          return $q.reject(rejection);\n        }\n      };\n    }];\n\n    $httpProvider.interceptors.push(interceptor);\n  }]);\n\n\n/**\n * Loading Bar\n *\n * This service handles adding and removing the actual element in the DOM.\n * Generally, best practices for DOM manipulation is to take place in a\n * directive, but because the element itself is injected in the DOM only upon\n * XHR requests, and it's likely needed on every view, the best option is to\n * use a service.\n */\nangular.module('cfp.loadingBar', [])\n  .provider('cfpLoadingBar', function() {\n\n    this.autoIncrement = true;\n    this.includeSpinner = true;\n    this.includeBar = true;\n    this.latencyThreshold = 100;\n    this.startSize = 0.02;\n    this.parentSelector = 'body';\n    this.spinnerTemplate = '<div id=\"loading-bar-spinner\"><div class=\"spinner-icon\"></div></div>';\n    this.loadingBarTemplate = '<div id=\"loading-bar\"><div class=\"bar\"><div class=\"peg\"></div></div></div>';\n\n    this.$get = ['$injector', '$document', '$timeout', '$rootScope', function ($injector, $document, $timeout, $rootScope) {\n      var $animate;\n      var $parentSelector = this.parentSelector,\n        loadingBarContainer = angular.element(this.loadingBarTemplate),\n        loadingBar = loadingBarContainer.find('div').eq(0),\n        spinner = angular.element(this.spinnerTemplate);\n\n      var incTimeout,\n        completeTimeout,\n        started = false,\n        status = 0;\n\n      var autoIncrement = this.autoIncrement;\n      var includeSpinner = this.includeSpinner;\n      var includeBar = this.includeBar;\n      var startSize = this.startSize;\n\n      /**\n       * Inserts the loading bar element into the dom, and sets it to 2%\n       */\n      function _start() {\n        if (!$animate) {\n          $animate = $injector.get('$animate');\n        }\n\n        $timeout.cancel(completeTimeout);\n\n        // do not continually broadcast the started event:\n        if (started) {\n          return;\n        }\n\n        var document = $document[0];\n        var parent = document.querySelector ?\n          document.querySelector($parentSelector)\n          : $document.find($parentSelector)[0]\n        ;\n\n        if (! parent) {\n          parent = document.getElementsByTagName('body')[0];\n        }\n\n        var $parent = angular.element(parent);\n        var $after = parent.lastChild && angular.element(parent.lastChild);\n\n        $rootScope.$broadcast('cfpLoadingBar:started');\n        started = true;\n\n        if (includeBar) {\n          $animate.enter(loadingBarContainer, $parent, $after);\n        }\n\n        if (includeSpinner) {\n          $animate.enter(spinner, $parent, loadingBarContainer);\n        }\n\n        _set(startSize);\n      }\n\n      /**\n       * Set the loading bar's width to a certain percent.\n       *\n       * @param n any value between 0 and 1\n       */\n      function _set(n) {\n        if (!started) {\n          return;\n        }\n        var pct = (n * 100) + '%';\n        loadingBar.css('width', pct);\n        status = n;\n\n        // increment loadingbar to give the illusion that there is always\n        // progress but make sure to cancel the previous timeouts so we don't\n        // have multiple incs running at the same time.\n        if (autoIncrement) {\n          $timeout.cancel(incTimeout);\n          incTimeout = $timeout(function() {\n            _inc();\n          }, 250);\n        }\n      }\n\n      /**\n       * Increments the loading bar by a random amount\n       * but slows down as it progresses\n       */\n      function _inc() {\n        if (_status() >= 1) {\n          return;\n        }\n\n        var rnd = 0;\n\n        // TODO: do this mathmatically instead of through conditions\n\n        var stat = _status();\n        if (stat >= 0 && stat < 0.25) {\n          // Start out between 3 - 6% increments\n          rnd = (Math.random() * (5 - 3 + 1) + 3) / 100;\n        } else if (stat >= 0.25 && stat < 0.65) {\n          // increment between 0 - 3%\n          rnd = (Math.random() * 3) / 100;\n        } else if (stat >= 0.65 && stat < 0.9) {\n          // increment between 0 - 2%\n          rnd = (Math.random() * 2) / 100;\n        } else if (stat >= 0.9 && stat < 0.99) {\n          // finally, increment it .5 %\n          rnd = 0.005;\n        } else {\n          // after 99%, don't increment:\n          rnd = 0;\n        }\n\n        var pct = _status() + rnd;\n        _set(pct);\n      }\n\n      function _status() {\n        return status;\n      }\n\n      function _completeAnimation() {\n        status = 0;\n        started = false;\n      }\n\n      function _complete() {\n        if (!$animate) {\n          $animate = $injector.get('$animate');\n        }\n\n        $rootScope.$broadcast('cfpLoadingBar:completed');\n        _set(1);\n\n        $timeout.cancel(completeTimeout);\n\n        // Attempt to aggregate any start/complete calls within 500ms:\n        completeTimeout = $timeout(function() {\n          var promise = $animate.leave(loadingBarContainer, _completeAnimation);\n          if (promise && promise.then) {\n            promise.then(_completeAnimation);\n          }\n          $animate.leave(spinner);\n        }, 500);\n      }\n\n      return {\n        start            : _start,\n        set              : _set,\n        status           : _status,\n        inc              : _inc,\n        complete         : _complete,\n        autoIncrement    : this.autoIncrement,\n        includeSpinner   : this.includeSpinner,\n        latencyThreshold : this.latencyThreshold,\n        parentSelector   : this.parentSelector,\n        startSize        : this.startSize\n      };\n\n\n    }];     //\n  });       // wtf javascript. srsly\n})();       //\n\n(function (window) {\n    'use strict';\n    angular.module('tmh.dynamicLocale', []).provider('tmhDynamicLocale', function () {\n\n        var defaultLocale,\n          localeLocationPattern = 'angular/i18n/angular-locale_{{locale}}.js',\n          storageFactory = 'tmhDynamicLocaleStorageCache',\n          storage,\n          storeKey = 'tmhDynamicLocale.locale',\n          promiseCache = {},\n          activeLocale;\n\n        /**\n         * Loads a script asynchronously\n         *\n         * @param {string} url The url for the script\n         @ @param {function) callback A function to be called once the script is loaded\n         */\n        function loadScript(url, callback, errorCallback, $timeout) {\n            var script = document.createElement('script'),\n              body = document.getElementsByTagName('body')[0],\n              removed = false;\n\n            script.type = 'text/javascript';\n            if (script.readyState) { // IE\n                script.onreadystatechange = function () {\n                    if (script.readyState === 'complete' ||\n                        script.readyState === 'loaded') {\n                        script.onreadystatechange = null;\n                        $timeout(\n                          function () {\n                              if (removed) return;\n                              removed = true;\n                              body.removeChild(script);\n                              callback();\n                          }, 30, false);\n                    }\n                };\n            } else { // Others\n                script.onload = function () {\n                    if (removed) return;\n                    removed = true;\n                    body.removeChild(script);\n                    callback();\n                };\n                script.onerror = function () {\n                    if (removed) return;\n                    removed = true;\n                    body.removeChild(script);\n                    errorCallback();\n                };\n            }\n            script.src = url;\n            script.async = false;\n            body.appendChild(script);\n        }\n\n        /**\n         * Loads a locale and replaces the properties from the current locale with the new locale information\n         *\n         * @param localeUrl The path to the new locale\n         * @param $locale The locale at the curent scope\n         */\n        function loadLocale(localeUrl, $locale, localeId, $rootScope, $q, localeCache, $timeout) {\n\n            function overrideValues(oldObject, newObject) {\n                if (activeLocale !== localeId) {\n                    return;\n                }\n                angular.forEach(oldObject, function (value, key) {\n                    if (!newObject[key]) {\n                        delete oldObject[key];\n                    } else if (angular.isArray(newObject[key])) {\n                        oldObject[key].length = newObject[key].length;\n                    }\n                });\n                angular.forEach(newObject, function (value, key) {\n                    if (angular.isArray(newObject[key]) || angular.isObject(newObject[key])) {\n                        if (!oldObject[key]) {\n                            oldObject[key] = angular.isArray(newObject[key]) ? [] : {};\n                        }\n                        overrideValues(oldObject[key], newObject[key]);\n                    } else {\n                        oldObject[key] = newObject[key];\n                    }\n                });\n            }\n\n\n            if (promiseCache[localeId]) return promiseCache[localeId];\n\n            var cachedLocale,\n              deferred = $q.defer();\n            if (localeId === activeLocale) {\n                deferred.resolve($locale);\n            } else if ((cachedLocale = localeCache.get(localeId))) {\n                activeLocale = localeId;\n                $rootScope.$evalAsync(function () {\n                    overrideValues($locale, cachedLocale);\n                    $rootScope.$broadcast('$localeChangeSuccess', localeId, $locale);\n                    storage.put(storeKey, localeId);\n                    deferred.resolve($locale);\n                });\n            } else {\n                activeLocale = localeId;\n                promiseCache[localeId] = deferred.promise;\n                loadScript(localeUrl, function () {\n                    // Create a new injector with the new locale\n                    var localInjector = angular.injector(['ngLocale']),\n                      externalLocale = localInjector.get('$locale');\n\n                    overrideValues($locale, externalLocale);\n                    localeCache.put(localeId, externalLocale);\n                    delete promiseCache[localeId];\n\n                    $rootScope.$apply(function () {\n                        $rootScope.$broadcast('$localeChangeSuccess', localeId, $locale);\n                        storage.put(storeKey, localeId);\n                        deferred.resolve($locale);\n                    });\n                }, function () {\n                    delete promiseCache[localeId];\n\n                    $rootScope.$apply(function () {\n                        $rootScope.$broadcast('$localeChangeError', localeId);\n                        deferred.reject(localeId);\n                    });\n                }, $timeout);\n            }\n            return deferred.promise;\n        }\n\n        this.localeLocationPattern = function (value) {\n            if (value) {\n                localeLocationPattern = value;\n                return this;\n            } else {\n                return localeLocationPattern;\n            }\n        };\n\n        this.useStorage = function (storageName) {\n            storageFactory = storageName;\n        };\n\n        this.useCookieStorage = function () {\n            this.useStorage('$cookieStore');\n        };\n\n        this.defaultLocale = function (value) {\n            defaultLocale = value;\n        };\n\n        this.$get = ['$rootScope', '$injector', '$interpolate', '$locale', '$q', 'tmhDynamicLocaleCache', '$timeout', function ($rootScope, $injector, interpolate, locale, $q, tmhDynamicLocaleCache, $timeout) {\n            var localeLocation = interpolate(localeLocationPattern);\n\n            storage = $injector.get(storageFactory);\n            $rootScope.$evalAsync(function () {\n                var initialLocale;\n                if ((initialLocale = (storage.get(storeKey) || defaultLocale))) {\n                    loadLocale(localeLocation({ locale: initialLocale }), locale, initialLocale, $rootScope, $q, tmhDynamicLocaleCache, $timeout);\n                }\n            });\n            return {\n                /**\n                 * @ngdoc method\n                 * @description\n                 * @param {string=} value Sets the locale to the new locale. Changing the locale will trigger\n                 *    a background task that will retrieve the new locale and configure the current $locale\n                 *    instance with the information from the new locale\n                 */\n                set: function (value) {\n                    return loadLocale(localeLocation({ locale: value }), locale, value, $rootScope, $q, tmhDynamicLocaleCache, $timeout);\n                }\n            };\n        }];\n    }).provider('tmhDynamicLocaleCache', function () {\n        this.$get = ['$cacheFactory', function ($cacheFactory) {\n            return $cacheFactory('tmh.dynamicLocales');\n        }];\n    }).provider('tmhDynamicLocaleStorageCache', function () {\n        this.$get = ['$cacheFactory', function ($cacheFactory) {\n            return $cacheFactory('tmh.dynamicLocales.store');\n        }];\n    }).run(['tmhDynamicLocale', angular.noop]);\n}(window));\n/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 2.5.0 - 2017-01-28\n * License: MIT\n */\nangular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.alert\", \"ui.bootstrap.dropdown\", \"ui.bootstrap.multiMap\", \"ui.bootstrap.position\", \"ui.bootstrap.modal\", \"ui.bootstrap.stackedMap\", \"ui.bootstrap.popover\", \"ui.bootstrap.tooltip\"]), angular.module(\"ui.bootstrap.tpls\", [\"uib/template/alert/alert.html\", \"uib/template/modal/window.html\", \"uib/template/popover/popover-html.html\", \"uib/template/popover/popover-template.html\", \"uib/template/popover/popover.html\", \"uib/template/tooltip/tooltip-html-popup.html\", \"uib/template/tooltip/tooltip-popup.html\", \"uib/template/tooltip/tooltip-template-popup.html\"]), angular.module(\"ui.bootstrap.alert\", []).controller(\"UibAlertController\", [\"$scope\", \"$element\", \"$attrs\", \"$interpolate\", \"$timeout\", function (t, e, o, n, i) { t.closeable = !!o.close, e.addClass(\"alert\"), o.$set(\"role\", \"alert\"), t.closeable && e.addClass(\"alert-dismissible\"); var r = angular.isDefined(o.dismissOnTimeout) ? n(o.dismissOnTimeout)(t.$parent) : null; r && i(function () { t.close() }, parseInt(r, 10)) }]).directive(\"uibAlert\", function () { return { controller: \"UibAlertController\", controllerAs: \"alert\", restrict: \"A\", templateUrl: function (t, e) { return e.templateUrl || \"uib/template/alert/alert.html\" }, transclude: !0, scope: { close: \"&\" } } }), angular.module(\"ui.bootstrap.dropdown\", [\"ui.bootstrap.multiMap\", \"ui.bootstrap.position\"]).constant(\"uibDropdownConfig\", { appendToOpenClass: \"uib-dropdown-open\", openClass: \"open\" }).service(\"uibDropdownService\", [\"$document\", \"$rootScope\", \"$$multiMap\", function (t, e, o) { var n = null, i = o.createNew(); this.isOnlyOpen = function (t, e) { var o = i.get(e); if (o) { var n = o.reduce(function (e, o) { return o.scope === t ? o : e }, {}); if (n) return 1 === o.length } return !1 }, this.open = function (e, o, l) { if (n || t.on(\"click\", r), n && n !== e && (n.isOpen = !1), n = e, l) { var a = i.get(l); if (a) { var p = a.map(function (t) { return t.scope }); -1 === p.indexOf(e) && i.put(l, { scope: e }) } else i.put(l, { scope: e }) } }, this.close = function (e, o, l) { if (n === e && (t.off(\"click\", r), t.off(\"keydown\", this.keybindFilter), n = null), l) { var a = i.get(l); if (a) { var p = a.reduce(function (t, o) { return o.scope === e ? o : t }, {}); p && i.remove(l, p) } } }; var r = function (t) { if (n && n.isOpen && !(t && \"disabled\" === n.getAutoClose() || t && 3 === t.which)) { var o = n.getToggleElement(); if (!(t && o && o[0].contains(t.target))) { var i = n.getDropdownElement(); t && \"outsideClick\" === n.getAutoClose() && i && i[0].contains(t.target) || (n.focusToggleElement(), n.isOpen = !1, e.$$phase || n.$apply()) } } }; this.keybindFilter = function (t) { if (n) { var e = n.getDropdownElement(), o = n.getToggleElement(), i = e && e[0].contains(t.target), l = o && o[0].contains(t.target); 27 === t.which ? (t.stopPropagation(), n.focusToggleElement(), r()) : n.isKeynavEnabled() && -1 !== [38, 40].indexOf(t.which) && n.isOpen && (i || l) && (t.preventDefault(), t.stopPropagation(), n.focusDropdownEntry(t.which)) } } }]).controller(\"UibDropdownController\", [\"$scope\", \"$element\", \"$attrs\", \"$parse\", \"uibDropdownConfig\", \"uibDropdownService\", \"$animate\", \"$uibPosition\", \"$document\", \"$compile\", \"$templateRequest\", function (t, e, o, n, i, r, l, a, p, u, s) { function c() { e.append(m.dropdownMenu) } var d, f, m = this, h = t.$new(), v = i.appendToOpenClass, b = i.openClass, g = angular.noop, w = o.onToggle ? n(o.onToggle) : angular.noop, $ = !1, y = p.find(\"body\"); e.addClass(\"dropdown\"), this.init = function () { o.isOpen && (f = n(o.isOpen), g = f.assign, t.$watch(f, function (t) { h.isOpen = !!t })), $ = angular.isDefined(o.keyboardNav) }, this.toggle = function (t) { return h.isOpen = arguments.length ? !!t : !h.isOpen, angular.isFunction(g) && g(h, h.isOpen), h.isOpen }, this.isOpen = function () { return h.isOpen }, h.getToggleElement = function () { return m.toggleElement }, h.getAutoClose = function () { return o.autoClose || \"always\" }, h.getElement = function () { return e }, h.isKeynavEnabled = function () { return $ }, h.focusDropdownEntry = function (t) { var o = m.dropdownMenu ? angular.element(m.dropdownMenu).find(\"a\") : e.find(\"ul\").eq(0).find(\"a\"); switch (t) { case 40: m.selectedOption = angular.isNumber(m.selectedOption) ? m.selectedOption === o.length - 1 ? m.selectedOption : m.selectedOption + 1 : 0; break; case 38: m.selectedOption = angular.isNumber(m.selectedOption) ? 0 === m.selectedOption ? 0 : m.selectedOption - 1 : o.length - 1 } o[m.selectedOption].focus() }, h.getDropdownElement = function () { return m.dropdownMenu }, h.focusToggleElement = function () { m.toggleElement && m.toggleElement[0].focus() }, h.$watch(\"isOpen\", function (i, f) { var $ = null, C = !1; if (angular.isDefined(o.dropdownAppendTo)) { var k = n(o.dropdownAppendTo)(h); k && ($ = angular.element(k)) } if (angular.isDefined(o.dropdownAppendToBody)) { var T = n(o.dropdownAppendToBody)(h); T !== !1 && (C = !0) } if (C && !$ && ($ = y), $ && m.dropdownMenu && (i ? ($.append(m.dropdownMenu), e.on(\"$destroy\", c)) : (e.off(\"$destroy\", c), c())), $ && m.dropdownMenu) { var E, O, D, M = a.positionElements(e, m.dropdownMenu, \"bottom-left\", !0), x = 0; if (E = { top: M.top + \"px\", display: i ? \"block\" : \"none\" }, O = m.dropdownMenu.hasClass(\"dropdown-menu-right\"), O ? (E.left = \"auto\", D = a.scrollbarPadding($), D.heightOverflow && D.scrollbarWidth && (x = D.scrollbarWidth), E.right = window.innerWidth - x - (M.left + e.prop(\"offsetWidth\")) + \"px\") : (E.left = M.left + \"px\", E.right = \"auto\"), !C) { var S = a.offset($); E.top = M.top - S.top + \"px\", O ? E.right = window.innerWidth - (M.left - S.left + e.prop(\"offsetWidth\")) + \"px\" : E.left = M.left - S.left + \"px\" } m.dropdownMenu.css(E) } var A = $ ? $ : e, P = $ ? v : b, N = A.hasClass(P), I = r.isOnlyOpen(t, $); if (N === !i) { var R; R = $ ? I ? \"removeClass\" : \"addClass\" : i ? \"addClass\" : \"removeClass\", l[R](A, P).then(function () { angular.isDefined(i) && i !== f && w(t, { open: !!i }) }) } if (i) m.dropdownMenuTemplateUrl ? s(m.dropdownMenuTemplateUrl).then(function (t) { d = h.$new(), u(t.trim())(d, function (t) { var e = t; m.dropdownMenu.replaceWith(e), m.dropdownMenu = e, p.on(\"keydown\", r.keybindFilter) }) }) : p.on(\"keydown\", r.keybindFilter), h.focusToggleElement(), r.open(h, e, $); else { if (r.close(h, e, $), m.dropdownMenuTemplateUrl) { d && d.$destroy(); var U = angular.element('<ul class=\"dropdown-menu\"></ul>'); m.dropdownMenu.replaceWith(U), m.dropdownMenu = U } m.selectedOption = null } angular.isFunction(g) && g(t, i) }) }]).directive(\"uibDropdown\", function () { return { controller: \"UibDropdownController\", link: function (t, e, o, n) { n.init() } } }).directive(\"uibDropdownMenu\", function () { return { restrict: \"A\", require: \"?^uibDropdown\", link: function (t, e, o, n) { if (n && !angular.isDefined(o.dropdownNested)) { e.addClass(\"dropdown-menu\"); var i = o.templateUrl; i && (n.dropdownMenuTemplateUrl = i), n.dropdownMenu || (n.dropdownMenu = e) } } } }).directive(\"uibDropdownToggle\", function () { return { require: \"?^uibDropdown\", link: function (t, e, o, n) { if (n) { e.addClass(\"dropdown-toggle\"), n.toggleElement = e; var i = function (i) { i.preventDefault(), e.hasClass(\"disabled\") || o.disabled || t.$apply(function () { n.toggle() }) }; e.on(\"click\", i), e.attr({ \"aria-haspopup\": !0, \"aria-expanded\": !1 }), t.$watch(n.isOpen, function (t) { e.attr(\"aria-expanded\", !!t) }), t.$on(\"$destroy\", function () { e.off(\"click\", i) }) } } } }), angular.module(\"ui.bootstrap.multiMap\", []).factory(\"$$multiMap\", function () { return { createNew: function () { var t = {}; return { entries: function () { return Object.keys(t).map(function (e) { return { key: e, value: t[e] } }) }, get: function (e) { return t[e] }, hasKey: function (e) { return !!t[e] }, keys: function () { return Object.keys(t) }, put: function (e, o) { t[e] || (t[e] = []), t[e].push(o) }, remove: function (e, o) { var n = t[e]; if (n) { var i = n.indexOf(o); -1 !== i && n.splice(i, 1), n.length || delete t[e] } } } } } }), angular.module(\"ui.bootstrap.position\", []).factory(\"$uibPosition\", [\"$document\", \"$window\", function (t, e) { var o, n, i = { normal: /(auto|scroll)/, hidden: /(auto|scroll|hidden)/ }, r = { auto: /\\s?auto?\\s?/i, primary: /^(top|bottom|left|right)$/, secondary: /^(top|bottom|left|right|center)$/, vertical: /^(top|bottom)$/ }, l = /(HTML|BODY)/; return { getRawNode: function (t) { return t.nodeName ? t : t[0] || t }, parseStyle: function (t) { return t = parseFloat(t), isFinite(t) ? t : 0 }, offsetParent: function (o) { function n(t) { return \"static\" === (e.getComputedStyle(t).position || \"static\") } o = this.getRawNode(o); for (var i = o.offsetParent || t[0].documentElement; i && i !== t[0].documentElement && n(i) ;) i = i.offsetParent; return i || t[0].documentElement }, scrollbarWidth: function (i) { if (i) { if (angular.isUndefined(n)) { var r = t.find(\"body\"); r.addClass(\"uib-position-body-scrollbar-measure\"), n = e.innerWidth - r[0].clientWidth, n = isFinite(n) ? n : 0, r.removeClass(\"uib-position-body-scrollbar-measure\") } return n } if (angular.isUndefined(o)) { var l = angular.element('<div class=\"uib-position-scrollbar-measure\"></div>'); t.find(\"body\").append(l), o = l[0].offsetWidth - l[0].clientWidth, o = isFinite(o) ? o : 0, l.remove() } return o }, scrollbarPadding: function (t) { t = this.getRawNode(t); var o = e.getComputedStyle(t), n = this.parseStyle(o.paddingRight), i = this.parseStyle(o.paddingBottom), r = this.scrollParent(t, !1, !0), a = this.scrollbarWidth(l.test(r.tagName)); return { scrollbarWidth: a, widthOverflow: r.scrollWidth > r.clientWidth, right: n + a, originalRight: n, heightOverflow: r.scrollHeight > r.clientHeight, bottom: i + a, originalBottom: i } }, isScrollable: function (t, o) { t = this.getRawNode(t); var n = o ? i.hidden : i.normal, r = e.getComputedStyle(t); return n.test(r.overflow + r.overflowY + r.overflowX) }, scrollParent: function (o, n, r) { o = this.getRawNode(o); var l = n ? i.hidden : i.normal, a = t[0].documentElement, p = e.getComputedStyle(o); if (r && l.test(p.overflow + p.overflowY + p.overflowX)) return o; var u = \"absolute\" === p.position, s = o.parentElement || a; if (s === a || \"fixed\" === p.position) return a; for (; s.parentElement && s !== a;) { var c = e.getComputedStyle(s); if (u && \"static\" !== c.position && (u = !1), !u && l.test(c.overflow + c.overflowY + c.overflowX)) break; s = s.parentElement } return s }, position: function (o, n) { o = this.getRawNode(o); var i = this.offset(o); if (n) { var r = e.getComputedStyle(o); i.top -= this.parseStyle(r.marginTop), i.left -= this.parseStyle(r.marginLeft) } var l = this.offsetParent(o), a = { top: 0, left: 0 }; return l !== t[0].documentElement && (a = this.offset(l), a.top += l.clientTop - l.scrollTop, a.left += l.clientLeft - l.scrollLeft), { width: Math.round(angular.isNumber(i.width) ? i.width : o.offsetWidth), height: Math.round(angular.isNumber(i.height) ? i.height : o.offsetHeight), top: Math.round(i.top - a.top), left: Math.round(i.left - a.left) } }, offset: function (o) { o = this.getRawNode(o); var n = o.getBoundingClientRect(); return { width: Math.round(angular.isNumber(n.width) ? n.width : o.offsetWidth), height: Math.round(angular.isNumber(n.height) ? n.height : o.offsetHeight), top: Math.round(n.top + (e.pageYOffset || t[0].documentElement.scrollTop)), left: Math.round(n.left + (e.pageXOffset || t[0].documentElement.scrollLeft)) } }, viewportOffset: function (o, n, i) { o = this.getRawNode(o), i = i !== !1 ? !0 : !1; var r = o.getBoundingClientRect(), l = { top: 0, left: 0, bottom: 0, right: 0 }, a = n ? t[0].documentElement : this.scrollParent(o), p = a.getBoundingClientRect(); if (l.top = p.top + a.clientTop, l.left = p.left + a.clientLeft, a === t[0].documentElement && (l.top += e.pageYOffset, l.left += e.pageXOffset), l.bottom = l.top + a.clientHeight, l.right = l.left + a.clientWidth, i) { var u = e.getComputedStyle(a); l.top += this.parseStyle(u.paddingTop), l.bottom -= this.parseStyle(u.paddingBottom), l.left += this.parseStyle(u.paddingLeft), l.right -= this.parseStyle(u.paddingRight) } return { top: Math.round(r.top - l.top), bottom: Math.round(l.bottom - r.bottom), left: Math.round(r.left - l.left), right: Math.round(l.right - r.right) } }, parsePlacement: function (t) { var e = r.auto.test(t); return e && (t = t.replace(r.auto, \"\")), t = t.split(\"-\"), t[0] = t[0] || \"top\", r.primary.test(t[0]) || (t[0] = \"top\"), t[1] = t[1] || \"center\", r.secondary.test(t[1]) || (t[1] = \"center\"), t[2] = e ? !0 : !1, t }, positionElements: function (t, o, n, i) { t = this.getRawNode(t), o = this.getRawNode(o); var l = angular.isDefined(o.offsetWidth) ? o.offsetWidth : o.prop(\"offsetWidth\"), a = angular.isDefined(o.offsetHeight) ? o.offsetHeight : o.prop(\"offsetHeight\"); n = this.parsePlacement(n); var p = i ? this.offset(t) : this.position(t), u = { top: 0, left: 0, placement: \"\" }; if (n[2]) { var s = this.viewportOffset(t, i), c = e.getComputedStyle(o), d = { width: l + Math.round(Math.abs(this.parseStyle(c.marginLeft) + this.parseStyle(c.marginRight))), height: a + Math.round(Math.abs(this.parseStyle(c.marginTop) + this.parseStyle(c.marginBottom))) }; if (n[0] = \"top\" === n[0] && d.height > s.top && d.height <= s.bottom ? \"bottom\" : \"bottom\" === n[0] && d.height > s.bottom && d.height <= s.top ? \"top\" : \"left\" === n[0] && d.width > s.left && d.width <= s.right ? \"right\" : \"right\" === n[0] && d.width > s.right && d.width <= s.left ? \"left\" : n[0], n[1] = \"top\" === n[1] && d.height - p.height > s.bottom && d.height - p.height <= s.top ? \"bottom\" : \"bottom\" === n[1] && d.height - p.height > s.top && d.height - p.height <= s.bottom ? \"top\" : \"left\" === n[1] && d.width - p.width > s.right && d.width - p.width <= s.left ? \"right\" : \"right\" === n[1] && d.width - p.width > s.left && d.width - p.width <= s.right ? \"left\" : n[1], \"center\" === n[1]) if (r.vertical.test(n[0])) { var f = p.width / 2 - l / 2; s.left + f < 0 && d.width - p.width <= s.right ? n[1] = \"left\" : s.right + f < 0 && d.width - p.width <= s.left && (n[1] = \"right\") } else { var m = p.height / 2 - d.height / 2; s.top + m < 0 && d.height - p.height <= s.bottom ? n[1] = \"top\" : s.bottom + m < 0 && d.height - p.height <= s.top && (n[1] = \"bottom\") } } switch (n[0]) { case \"top\": u.top = p.top - a; break; case \"bottom\": u.top = p.top + p.height; break; case \"left\": u.left = p.left - l; break; case \"right\": u.left = p.left + p.width } switch (n[1]) { case \"top\": u.top = p.top; break; case \"bottom\": u.top = p.top + p.height - a; break; case \"left\": u.left = p.left; break; case \"right\": u.left = p.left + p.width - l; break; case \"center\": r.vertical.test(n[0]) ? u.left = p.left + p.width / 2 - l / 2 : u.top = p.top + p.height / 2 - a / 2 } return u.top = Math.round(u.top), u.left = Math.round(u.left), u.placement = \"center\" === n[1] ? n[0] : n[0] + \"-\" + n[1], u }, adjustTop: function (t, e, o, n) { return -1 !== t.indexOf(\"top\") && o !== n ? { top: e.top - n + \"px\" } : void 0 }, positionArrow: function (t, o) { t = this.getRawNode(t); var n = t.querySelector(\".tooltip-inner, .popover-inner\"); if (n) { var i = angular.element(n).hasClass(\"tooltip-inner\"), l = t.querySelector(i ? \".tooltip-arrow\" : \".arrow\"); if (l) { var a = { top: \"\", bottom: \"\", left: \"\", right: \"\" }; if (o = this.parsePlacement(o), \"center\" === o[1]) return void angular.element(l).css(a); var p = \"border-\" + o[0] + \"-width\", u = e.getComputedStyle(l)[p], s = \"border-\"; s += r.vertical.test(o[0]) ? o[0] + \"-\" + o[1] : o[1] + \"-\" + o[0], s += \"-radius\"; var c = e.getComputedStyle(i ? n : t)[s]; switch (o[0]) { case \"top\": a.bottom = i ? \"0\" : \"-\" + u; break; case \"bottom\": a.top = i ? \"0\" : \"-\" + u; break; case \"left\": a.right = i ? \"0\" : \"-\" + u; break; case \"right\": a.left = i ? \"0\" : \"-\" + u } a[o[1]] = c, angular.element(l).css(a) } } } } }]), angular.module(\"ui.bootstrap.modal\", [\"ui.bootstrap.multiMap\", \"ui.bootstrap.stackedMap\", \"ui.bootstrap.position\"]).provider(\"$uibResolve\", function () { var t = this; this.resolver = null, this.setResolver = function (t) { this.resolver = t }, this.$get = [\"$injector\", \"$q\", function (e, o) { var n = t.resolver ? e.get(t.resolver) : null; return { resolve: function (t, i, r, l) { if (n) return n.resolve(t, i, r, l); var a = []; return angular.forEach(t, function (t) { a.push(angular.isFunction(t) || angular.isArray(t) ? o.resolve(e.invoke(t)) : angular.isString(t) ? o.resolve(e.get(t)) : o.resolve(t)) }), o.all(a).then(function (e) { var o = {}, n = 0; return angular.forEach(t, function (t, i) { o[i] = e[n++] }), o }) } } }] }).directive(\"uibModalBackdrop\", [\"$animate\", \"$injector\", \"$uibModalStack\", function (t, e, o) { function n(e, n, i) { i.modalInClass && (t.addClass(n, i.modalInClass), e.$on(o.NOW_CLOSING_EVENT, function (o, r) { var l = r(); e.modalOptions.animation ? t.removeClass(n, i.modalInClass).then(l) : l() })) } return { restrict: \"A\", compile: function (t, e) { return t.addClass(e.backdropClass), n } } }]).directive(\"uibModalWindow\", [\"$uibModalStack\", \"$q\", \"$animateCss\", \"$document\", function (t, e, o, n) { return { scope: { index: \"@\" }, restrict: \"A\", transclude: !0, templateUrl: function (t, e) { return e.templateUrl || \"uib/template/modal/window.html\" }, link: function (i, r, l) { r.addClass(l.windowTopClass || \"\"), i.size = l.size, i.close = function (e) { var o = t.getTop(); o && o.value.backdrop && \"static\" !== o.value.backdrop && e.target === e.currentTarget && (e.preventDefault(), e.stopPropagation(), t.dismiss(o.key, \"backdrop click\")) }, r.on(\"click\", i.close), i.$isRendered = !0; var a = e.defer(); i.$$postDigest(function () { a.resolve() }), a.promise.then(function () { var a = null; l.modalInClass && (a = o(r, { addClass: l.modalInClass }).start(), i.$on(t.NOW_CLOSING_EVENT, function (t, e) { var n = e(); o(r, { removeClass: l.modalInClass }).start().then(n) })), e.when(a).then(function () { var e = t.getTop(); if (e && t.modalRendered(e.key), !n[0].activeElement || !r[0].contains(n[0].activeElement)) { var o = r[0].querySelector(\"[autofocus]\"); o ? o.focus() : r[0].focus() } }) }) } } }]).directive(\"uibModalAnimationClass\", function () { return { compile: function (t, e) { e.modalAnimation && t.addClass(e.uibModalAnimationClass) } } }).directive(\"uibModalTransclude\", [\"$animate\", function (t) { return { link: function (e, o, n, i, r) { r(e.$parent, function (e) { o.empty(), t.enter(e, o) }) } } }]).factory(\"$uibModalStack\", [\"$animate\", \"$animateCss\", \"$document\", \"$compile\", \"$rootScope\", \"$q\", \"$$multiMap\", \"$$stackedMap\", \"$uibPosition\", function (t, e, o, n, i, r, l, a, p) { function u(t) { var e = \"-\"; return t.replace(S, function (t, o) { return (o ? e : \"\") + t.toLowerCase() }) } function s(t) { return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length) } function c() { for (var t = -1, e = k.keys(), o = 0; o < e.length; o++) k.get(e[o]).value.backdrop && (t = o); return t > -1 && O > t && (t = O), t } function d(t, e) { var o = k.get(t).value, n = o.appendTo; k.remove(t), D = k.top(), D && (O = parseInt(D.value.modalDomEl.attr(\"index\"), 10)), h(o.modalDomEl, o.modalScope, function () { var e = o.openedClass || C; T.remove(e, t); var i = T.hasKey(e); n.toggleClass(e, i), !i && y && y.heightOverflow && y.scrollbarWidth && (n.css(y.originalRight ? { paddingRight: y.originalRight + \"px\" } : { paddingRight: \"\" }), y = null), f(!0) }, o.closedDeferred), m(), e && e.focus ? e.focus() : n.focus && n.focus() } function f(t) { var e; k.length() > 0 && (e = k.top().value, e.modalDomEl.toggleClass(e.windowTopClass || \"\", t)) } function m() { if (w && -1 === c()) { var t = $; h(w, $, function () { t = null }), w = void 0, $ = void 0 } } function h(e, o, n, i) { function l() { l.done || (l.done = !0, t.leave(e).then(function () { n && n(), e.remove(), i && i.resolve() }), o.$destroy()) } var a, p = null, u = function () { return a || (a = r.defer(), p = a.promise), function () { a.resolve() } }; return o.$broadcast(E.NOW_CLOSING_EVENT, u), r.when(p).then(l) } function v(t) { if (t.isDefaultPrevented()) return t; var e = k.top(); if (e) switch (t.which) { case 27: e.value.keyboard && (t.preventDefault(), i.$apply(function () { E.dismiss(e.key, \"escape key press\") })); break; case 9: var o = E.loadFocusElementList(e), n = !1; t.shiftKey ? (E.isFocusInFirstItem(t, o) || E.isModalFocused(t, e)) && (n = E.focusLastFocusableElement(o)) : E.isFocusInLastItem(t, o) && (n = E.focusFirstFocusableElement(o)), n && (t.preventDefault(), t.stopPropagation()) } } function b(t, e, o) { return !t.value.modalScope.$broadcast(\"modal.closing\", e, o).defaultPrevented } function g() { Array.prototype.forEach.call(document.querySelectorAll(\"[\" + M + \"]\"), function (t) { var e = parseInt(t.getAttribute(M), 10), o = e - 1; t.setAttribute(M, o), o || (t.removeAttribute(M), t.removeAttribute(\"aria-hidden\")) }) } var w, $, y, C = \"modal-open\", k = a.createNew(), T = l.createNew(), E = { NOW_CLOSING_EVENT: \"modal.stack.now-closing\" }, O = 0, D = null, M = \"data-bootstrap-modal-aria-hidden-count\", x = \"a[href], area[href], input:not([disabled]):not([tabindex='-1']), button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']), textarea:not([disabled]):not([tabindex='-1']), iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]\", S = /[A-Z]/g; return i.$watch(c, function (t) { $ && ($.index = t) }), o.on(\"keydown\", v), i.$on(\"$destroy\", function () { o.off(\"keydown\", v) }), E.open = function (e, r) { function l(t) { function e(t) { var e = t.parent() ? t.parent().children() : []; return Array.prototype.filter.call(e, function (e) { return e !== t[0] }) } if (t && \"BODY\" !== t[0].tagName) return e(t).forEach(function (t) { var e = \"true\" === t.getAttribute(\"aria-hidden\"), o = parseInt(t.getAttribute(M), 10); o || (o = e ? 1 : 0), t.setAttribute(M, o + 1), t.setAttribute(\"aria-hidden\", \"true\") }), l(t.parent()) } var a = o[0].activeElement, s = r.openedClass || C; f(!1), D = k.top(), k.add(e, { deferred: r.deferred, renderDeferred: r.renderDeferred, closedDeferred: r.closedDeferred, modalScope: r.scope, backdrop: r.backdrop, keyboard: r.keyboard, openedClass: r.openedClass, windowTopClass: r.windowTopClass, animation: r.animation, appendTo: r.appendTo }), T.put(s, e); var d = r.appendTo, m = c(); m >= 0 && !w && ($ = i.$new(!0), $.modalOptions = r, $.index = m, w = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>'), w.attr({ \"class\": \"modal-backdrop\", \"ng-style\": \"{'z-index': 1040 + (index && 1 || 0) + index*10}\", \"uib-modal-animation-class\": \"fade\", \"modal-in-class\": \"in\" }), r.backdropClass && w.addClass(r.backdropClass), r.animation && w.attr(\"modal-animation\", \"true\"), n(w)($), t.enter(w, d), p.isScrollable(d) && (y = p.scrollbarPadding(d), y.heightOverflow && y.scrollbarWidth && d.css({ paddingRight: y.right + \"px\" }))); var h; r.component ? (h = document.createElement(u(r.component.name)), h = angular.element(h), h.attr({ resolve: \"$resolve\", \"modal-instance\": \"$uibModalInstance\", close: \"$close($value)\", dismiss: \"$dismiss($value)\" })) : h = r.content, O = D ? parseInt(D.value.modalDomEl.attr(\"index\"), 10) + 1 : 0; var v = angular.element('<div uib-modal-window=\"modal-window\"></div>'); v.attr({ \"class\": \"modal\", \"template-url\": r.windowTemplateUrl, \"window-top-class\": r.windowTopClass, role: \"dialog\", \"aria-labelledby\": r.ariaLabelledBy, \"aria-describedby\": r.ariaDescribedBy, size: r.size, index: O, animate: \"animate\", \"ng-style\": \"{'z-index': 1050 + $$topModalIndex*10, display: 'block'}\", tabindex: -1, \"uib-modal-animation-class\": \"fade\", \"modal-in-class\": \"in\" }).append(h), r.windowClass && v.addClass(r.windowClass), r.animation && v.attr(\"modal-animation\", \"true\"), d.addClass(s), r.scope && (r.scope.$$topModalIndex = O), t.enter(n(v)(r.scope), d), k.top().value.modalDomEl = v, k.top().value.modalOpener = a, l(v) }, E.close = function (t, e) { var o = k.get(t); return g(), o && b(o, e, !0) ? (o.value.modalScope.$$uibDestructionScheduled = !0, o.value.deferred.resolve(e), d(t, o.value.modalOpener), !0) : !o }, E.dismiss = function (t, e) { var o = k.get(t); return g(), o && b(o, e, !1) ? (o.value.modalScope.$$uibDestructionScheduled = !0, o.value.deferred.reject(e), d(t, o.value.modalOpener), !0) : !o }, E.dismissAll = function (t) { for (var e = this.getTop() ; e && this.dismiss(e.key, t) ;) e = this.getTop() }, E.getTop = function () { return k.top() }, E.modalRendered = function (t) { var e = k.get(t); e && e.value.renderDeferred.resolve() }, E.focusFirstFocusableElement = function (t) { return t.length > 0 ? (t[0].focus(), !0) : !1 }, E.focusLastFocusableElement = function (t) { return t.length > 0 ? (t[t.length - 1].focus(), !0) : !1 }, E.isModalFocused = function (t, e) { if (t && e) { var o = e.value.modalDomEl; if (o && o.length) return (t.target || t.srcElement) === o[0] } return !1 }, E.isFocusInFirstItem = function (t, e) { return e.length > 0 ? (t.target || t.srcElement) === e[0] : !1 }, E.isFocusInLastItem = function (t, e) { return e.length > 0 ? (t.target || t.srcElement) === e[e.length - 1] : !1 }, E.loadFocusElementList = function (t) { if (t) { var e = t.value.modalDomEl; if (e && e.length) { var o = e[0].querySelectorAll(x); return o ? Array.prototype.filter.call(o, function (t) { return s(t) }) : o } } }, E }]).provider(\"$uibModal\", function () { var t = { options: { animation: !0, backdrop: !0, keyboard: !0 }, $get: [\"$rootScope\", \"$q\", \"$document\", \"$templateRequest\", \"$controller\", \"$uibResolve\", \"$uibModalStack\", function (e, o, n, i, r, l, a) { function p(t) { return t.template ? o.when(t.template) : i(angular.isFunction(t.templateUrl) ? t.templateUrl() : t.templateUrl) } var u = {}, s = null; return u.getPromiseChain = function () { return s }, u.open = function (i) { function u() { return v } var c = o.defer(), d = o.defer(), f = o.defer(), m = o.defer(), h = { result: c.promise, opened: d.promise, closed: f.promise, rendered: m.promise, close: function (t) { return a.close(h, t) }, dismiss: function (t) { return a.dismiss(h, t) } }; if (i = angular.extend({}, t.options, i), i.resolve = i.resolve || {}, i.appendTo = i.appendTo || n.find(\"body\").eq(0), !i.appendTo.length) throw new Error(\"appendTo element not found. Make sure that the element passed is in DOM.\"); if (!i.component && !i.template && !i.templateUrl) throw new Error(\"One of component or template or templateUrl options is required.\"); var v; v = i.component ? o.when(l.resolve(i.resolve, {}, null, null)) : o.all([p(i), l.resolve(i.resolve, {}, null, null)]); var b; return b = s = o.all([s]).then(u, u).then(function (t) { function o(e, o, n, i) { e.$scope = l, e.$scope.$resolve = {}, n ? e.$scope.$uibModalInstance = h : e.$uibModalInstance = h; var r = o ? t[1] : t; angular.forEach(r, function (t, o) { i && (e[o] = t), e.$scope.$resolve[o] = t }) } var n = i.scope || e, l = n.$new(); l.$close = h.close, l.$dismiss = h.dismiss, l.$on(\"$destroy\", function () { l.$$uibDestructionScheduled || l.$dismiss(\"$uibUnscheduledDestruction\") }); var p, u, s = { scope: l, deferred: c, renderDeferred: m, closedDeferred: f, animation: i.animation, backdrop: i.backdrop, keyboard: i.keyboard, backdropClass: i.backdropClass, windowTopClass: i.windowTopClass, windowClass: i.windowClass, windowTemplateUrl: i.windowTemplateUrl, ariaLabelledBy: i.ariaLabelledBy, ariaDescribedBy: i.ariaDescribedBy, size: i.size, openedClass: i.openedClass, appendTo: i.appendTo }, v = {}, b = {}; i.component ? (o(v, !1, !0, !1), v.name = i.component, s.component = v) : i.controller && (o(b, !0, !1, !0), u = r(i.controller, b, !0, i.controllerAs), i.controllerAs && i.bindToController && (p = u.instance, p.$close = l.$close, p.$dismiss = l.$dismiss, angular.extend(p, { $resolve: b.$scope.$resolve }, n)), p = u(), angular.isFunction(p.$onInit) && p.$onInit()), i.component || (s.content = t[0]), a.open(h, s), d.resolve(!0) }, function (t) { d.reject(t), c.reject(t) })[\"finally\"](function () { s === b && (s = null) }), h }, u }] }; return t }), angular.module(\"ui.bootstrap.stackedMap\", []).factory(\"$$stackedMap\", function () { return { createNew: function () { var t = []; return { add: function (e, o) { t.push({ key: e, value: o }) }, get: function (e) { for (var o = 0; o < t.length; o++) if (e === t[o].key) return t[o] }, keys: function () { for (var e = [], o = 0; o < t.length; o++) e.push(t[o].key); return e }, top: function () { return t[t.length - 1] }, remove: function (e) { for (var o = -1, n = 0; n < t.length; n++) if (e === t[n].key) { o = n; break } return t.splice(o, 1)[0] }, removeTop: function () { return t.pop() }, length: function () { return t.length } } } } }), angular.module(\"ui.bootstrap.popover\", [\"ui.bootstrap.tooltip\"]).directive(\"uibPopoverTemplatePopup\", function () { return { restrict: \"A\", scope: { uibTitle: \"@\", contentExp: \"&\", originScope: \"&\" }, templateUrl: \"uib/template/popover/popover-template.html\" } }).directive(\"uibPopoverTemplate\", [\"$uibTooltip\", function (t) { return t(\"uibPopoverTemplate\", \"popover\", \"click\", { useContentExp: !0 }) }]).directive(\"uibPopoverHtmlPopup\", function () { return { restrict: \"A\", scope: { contentExp: \"&\", uibTitle: \"@\" }, templateUrl: \"uib/template/popover/popover-html.html\" } }).directive(\"uibPopoverHtml\", [\"$uibTooltip\", function (t) { return t(\"uibPopoverHtml\", \"popover\", \"click\", { useContentExp: !0 }) }]).directive(\"uibPopoverPopup\", function () { return { restrict: \"A\", scope: { uibTitle: \"@\", content: \"@\" }, templateUrl: \"uib/template/popover/popover.html\" } }).directive(\"uibPopover\", [\"$uibTooltip\", function (t) { return t(\"uibPopover\", \"popover\", \"click\") }]), angular.module(\"ui.bootstrap.tooltip\", [\"ui.bootstrap.position\", \"ui.bootstrap.stackedMap\"]).provider(\"$uibTooltip\", function () { function t(t) { var e = /[A-Z]/g, o = \"-\"; return t.replace(e, function (t, e) { return (e ? o : \"\") + t.toLowerCase() }) } var e = { placement: \"top\", placementClassPrefix: \"\", animation: !0, popupDelay: 0, popupCloseDelay: 0, useContentExp: !1 }, o = { mouseenter: \"mouseleave\", click: \"click\", outsideClick: \"outsideClick\", focus: \"blur\", none: \"\" }, n = {}; this.options = function (t) { angular.extend(n, t) }, this.setTriggers = function (t) { angular.extend(o, t) }, this.$get = [\"$window\", \"$compile\", \"$timeout\", \"$document\", \"$uibPosition\", \"$interpolate\", \"$rootScope\", \"$parse\", \"$$stackedMap\", function (i, r, l, a, p, u, s, c, d) { function f(t) { if (27 === t.which) { var e = m.top(); e && (e.value.close(), e = null) } } var m = d.createNew(); return a.on(\"keyup\", f), s.$on(\"$destroy\", function () { a.off(\"keyup\", f) }), function (i, s, d, f) { function h(t) { var e = (t || f.trigger || d).split(\" \"), n = e.map(function (t) { return o[t] || t }); return { show: e, hide: n } } f = angular.extend({}, e, n, f); var v = t(i), b = u.startSymbol(), g = u.endSymbol(), w = \"<div \" + v + '-popup uib-title=\"' + b + \"title\" + g + '\" ' + (f.useContentExp ? 'content-exp=\"contentExp()\" ' : 'content=\"' + b + \"content\" + g + '\" ') + 'origin-scope=\"origScope\" class=\"uib-position-measure ' + s + '\" tooltip-animation-class=\"fade\"uib-tooltip-classes ng-class=\"{ in: isOpen }\" ></div>'; return { compile: function () { var t = r(w); return function (e, o, n) { function r() { H.isOpen ? d() : u() } function u() { (!L || e.$eval(n[s + \"Enable\"])) && (w(), C(), H.popupDelay ? P || (P = l(v, H.popupDelay, !1)) : v()) } function d() { b(), H.popupCloseDelay ? N || (N = l(g, H.popupCloseDelay, !1)) : g() } function v() { return b(), w(), H.content ? ($(), void H.$evalAsync(function () { H.isOpen = !0, k(!0), _() })) : angular.noop } function b() { P && (l.cancel(P), P = null), I && (l.cancel(I), I = null) } function g() { H && H.$evalAsync(function () { H && (H.isOpen = !1, k(!1), H.animation ? A || (A = l(y, 150, !1)) : y()) }) } function w() { N && (l.cancel(N), N = null), A && (l.cancel(A), A = null) } function $() { x || (S = H.$new(), x = t(S, function (t) { W ? a.find(\"body\").append(t) : o.after(t) }), m.add(H, { close: g }), T()) } function y() { b(), w(), E(), x && (x.remove(), x = null, R && l.cancel(R)), m.remove(H), S && (S.$destroy(), S = null) } function C() { H.title = n[s + \"Title\"], H.content = j ? j(e) : n[i], H.popupClass = n[s + \"Class\"], H.placement = angular.isDefined(n[s + \"Placement\"]) ? n[s + \"Placement\"] : f.placement; var t = p.parsePlacement(H.placement); U = t[1] ? t[0] + \"-\" + t[1] : t[0]; var o = parseInt(n[s + \"PopupDelay\"], 10), r = parseInt(n[s + \"PopupCloseDelay\"], 10); H.popupDelay = isNaN(o) ? f.popupDelay : o, H.popupCloseDelay = isNaN(r) ? f.popupCloseDelay : r } function k(t) { q && angular.isFunction(q.assign) && q.assign(e, t) } function T() { z.length = 0, j ? (z.push(e.$watch(j, function (t) { H.content = t, !t && H.isOpen && g() })), z.push(S.$watch(function () { B || (B = !0, S.$$postDigest(function () { B = !1, H && H.isOpen && _() })) }))) : z.push(n.$observe(i, function (t) { H.content = t, !t && H.isOpen ? g() : _() })), z.push(n.$observe(s + \"Title\", function (t) { H.title = t, H.isOpen && _() })), z.push(n.$observe(s + \"Placement\", function (t) { H.placement = t ? t : f.placement, H.isOpen && _() })) } function E() { z.length && (angular.forEach(z, function (t) { t() }), z.length = 0) } function O(t) { H && H.isOpen && x && (o[0].contains(t.target) || x[0].contains(t.target) || d()) } function D(t) { 27 === t.which && d() } function M() { var t = [], i = [], l = e.$eval(n[s + \"Trigger\"]); Y(), angular.isObject(l) ? (Object.keys(l).forEach(function (e) { t.push(e), i.push(l[e]) }), F = { show: t, hide: i }) : F = h(l), \"none\" !== F.show && F.show.forEach(function (t, e) { \"outsideClick\" === t ? (o.on(\"click\", r), a.on(\"click\", O)) : t === F.hide[e] ? o.on(t, r) : t && (o.on(t, u), o.on(F.hide[e], d)), o.on(\"keypress\", D) }) } var x, S, A, P, N, I, R, U, W = angular.isDefined(f.appendToBody) ? f.appendToBody : !1, F = h(void 0), L = angular.isDefined(n[s + \"Enable\"]), H = e.$new(!0), B = !1, q = angular.isDefined(n[s + \"IsOpen\"]) ? c(n[s + \"IsOpen\"]) : !1, j = f.useContentExp ? c(n[i]) : !1, z = [], _ = function () { x && x.html() && (I || (I = l(function () { var t = p.positionElements(o, x, H.placement, W), e = angular.isDefined(x.offsetHeight) ? x.offsetHeight : x.prop(\"offsetHeight\"), n = W ? p.offset(o) : p.position(o); x.css({ top: t.top + \"px\", left: t.left + \"px\" }); var i = t.placement.split(\"-\"); x.hasClass(i[0]) || (x.removeClass(U.split(\"-\")[0]), x.addClass(i[0])), x.hasClass(f.placementClassPrefix + t.placement) || (x.removeClass(f.placementClassPrefix + U), x.addClass(f.placementClassPrefix + t.placement)), R = l(function () { var t = angular.isDefined(x.offsetHeight) ? x.offsetHeight : x.prop(\"offsetHeight\"), o = p.adjustTop(i, n, e, t); o && x.css(o), R = null }, 0, !1), x.hasClass(\"uib-position-measure\") ? (p.positionArrow(x, t.placement), x.removeClass(\"uib-position-measure\")) : U !== t.placement && p.positionArrow(x, t.placement), U = t.placement, I = null }, 0, !1))) }; H.origScope = e, H.isOpen = !1, H.contentExp = function () { return H.content }, n.$observe(\"disabled\", function (t) { t && b(), t && H.isOpen && g() }), q && e.$watch(q, function (t) { H && !t === H.isOpen && r() }); var Y = function () { F.show.forEach(function (t) { \"outsideClick\" === t ? o.off(\"click\", r) : (o.off(t, u), o.off(t, r)), o.off(\"keypress\", D) }), F.hide.forEach(function (t) { \"outsideClick\" === t ? a.off(\"click\", O) : o.off(t, d) }) }; M(); var K = e.$eval(n[s + \"Animation\"]); H.animation = angular.isDefined(K) ? !!K : f.animation; var X, G = s + \"AppendToBody\"; X = G in n && void 0 === n[G] ? !0 : e.$eval(n[G]), W = angular.isDefined(X) ? X : W, e.$on(\"$destroy\", function () { Y(), y(), H = null }) } } } } }] }).directive(\"uibTooltipTemplateTransclude\", [\"$animate\", \"$sce\", \"$compile\", \"$templateRequest\", function (t, e, o, n) { return { link: function (i, r, l) { var a, p, u, s = i.$eval(l.tooltipTemplateTranscludeScope), c = 0, d = function () { p && (p.remove(), p = null), a && (a.$destroy(), a = null), u && (t.leave(u).then(function () { p = null }), p = u, u = null) }; i.$watch(e.parseAsResourceUrl(l.uibTooltipTemplateTransclude), function (e) { var l = ++c; e ? (n(e, !0).then(function (n) { if (l === c) { var i = s.$new(), p = n, f = o(p)(i, function (e) { d(), t.enter(e, r) }); a = i, u = f, a.$emit(\"$includeContentLoaded\", e) } }, function () { l === c && (d(), i.$emit(\"$includeContentError\", e)) }), i.$emit(\"$includeContentRequested\", e)) : d() }), i.$on(\"$destroy\", d) } } }]).directive(\"uibTooltipClasses\", [\"$uibPosition\", function (t) { return { restrict: \"A\", link: function (e, o, n) { if (e.placement) { var i = t.parsePlacement(e.placement); o.addClass(i[0]) } e.popupClass && o.addClass(e.popupClass), e.animation && o.addClass(n.tooltipAnimationClass) } } }]).directive(\"uibTooltipPopup\", function () { return { restrict: \"A\", scope: { content: \"@\" }, templateUrl: \"uib/template/tooltip/tooltip-popup.html\" } }).directive(\"uibTooltip\", [\"$uibTooltip\", function (t) {\n    return t(\"uibTooltip\", \"tooltip\", \"mouseenter\")\n}]).directive(\"uibTooltipTemplatePopup\", function () { return { restrict: \"A\", scope: { contentExp: \"&\", originScope: \"&\" }, templateUrl: \"uib/template/tooltip/tooltip-template-popup.html\" } }).directive(\"uibTooltipTemplate\", [\"$uibTooltip\", function (t) { return t(\"uibTooltipTemplate\", \"tooltip\", \"mouseenter\", { useContentExp: !0 }) }]).directive(\"uibTooltipHtmlPopup\", function () { return { restrict: \"A\", scope: { contentExp: \"&\" }, templateUrl: \"uib/template/tooltip/tooltip-html-popup.html\" } }).directive(\"uibTooltipHtml\", [\"$uibTooltip\", function (t) { return t(\"uibTooltipHtml\", \"tooltip\", \"mouseenter\", { useContentExp: !0 }) }]), angular.module(\"uib/template/alert/alert.html\", []).run([\"$templateCache\", function (t) { t.put(\"uib/template/alert/alert.html\", '<button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\\n  <span aria-hidden=\"true\">&times;</span>\\n  <span class=\"sr-only\">Close</span>\\n</button>\\n<div ng-transclude></div>\\n') }]), angular.module(\"uib/template/modal/window.html\", []).run([\"$templateCache\", function (t) { t.put(\"uib/template/modal/window.html\", \"<div class=\\\"modal-dialog {{size ? 'modal-' + size : ''}}\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\") }]), angular.module(\"uib/template/popover/popover-html.html\", []).run([\"$templateCache\", function (t) { t.put(\"uib/template/popover/popover-html.html\", '<div class=\"arrow\"></div>\\n\\n<div class=\"popover-inner\">\\n    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\\n    <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\\n</div>\\n') }]), angular.module(\"uib/template/popover/popover-template.html\", []).run([\"$templateCache\", function (t) { t.put(\"uib/template/popover/popover-template.html\", '<div class=\"arrow\"></div>\\n\\n<div class=\"popover-inner\">\\n    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\\n    <div class=\"popover-content\"\\n      uib-tooltip-template-transclude=\"contentExp()\"\\n      tooltip-template-transclude-scope=\"originScope()\"></div>\\n</div>\\n') }]), angular.module(\"uib/template/popover/popover.html\", []).run([\"$templateCache\", function (t) { t.put(\"uib/template/popover/popover.html\", '<div class=\"arrow\"></div>\\n\\n<div class=\"popover-inner\">\\n    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\\n    <div class=\"popover-content\" ng-bind=\"content\"></div>\\n</div>\\n') }]), angular.module(\"uib/template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function (t) { t.put(\"uib/template/tooltip/tooltip-html-popup.html\", '<div class=\"tooltip-arrow\"></div>\\n<div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\\n') }]), angular.module(\"uib/template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function (t) { t.put(\"uib/template/tooltip/tooltip-popup.html\", '<div class=\"tooltip-arrow\"></div>\\n<div class=\"tooltip-inner\" ng-bind=\"content\"></div>\\n') }]), angular.module(\"uib/template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function (t) { t.put(\"uib/template/tooltip/tooltip-template-popup.html\", '<div class=\"tooltip-arrow\"></div>\\n<div class=\"tooltip-inner\"\\n  uib-tooltip-template-transclude=\"contentExp()\"\\n  tooltip-template-transclude-scope=\"originScope()\"></div>\\n') }]), angular.module(\"ui.bootstrap.position\").run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find(\"head\").prepend('<style type=\"text/css\">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'), angular.$$uibPositionCss = !0 }), angular.module(\"ui.bootstrap.tooltip\").run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find(\"head\").prepend('<style type=\"text/css\">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'), angular.$$uibTooltipCss = !0 });\napp.directive('updateCart', ['CartService', function (CartService) {\n\n    // Shared scope:\n    // updateCart: The updated cart to save. If an existing cart does not exist, one will be created and returned.\n    // error: The error object to communicate errors.\n    // onSubmit: A function that will be called from scope when a cart update is submitted.\n    // onSuccess: A function that will be called from scope when the cart is successfully updated. Will include the response cart object as a parameter.\n    // onFailure: A function that will be called from scope when the update fails. Will include the error object as a parameter.\n\n    // Attributes\n    // params: An object that supplies a list of parameters to send to the api, such as show, hide, formatted, etc. Used to customize the response object.\n\n    return {\n        restrict: 'A',\n        require: '^form',\n        scope: {\n            cart: '=updateCart',\n            shippingIsBilling: '=?',\n            params: '=?',\n            error: '=?',\n            onSubmit: '=?',\n            onSuccess: '=?',\n            onError: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            elem.bind(\"click\", function () {\n\n                // Fire the submit event\n                if (scope.onSubmit) {\n                    scope.onSubmit();\n                }\n\n                // Clear previous errors\n                scope.error = null;\n\n                // Prep the params\n                var params = scope.params || attrs.params;\n                params = utils.mergeParams(params, null, null);\n\n                // Make a copy of the cart so you can modify the data without modifying the view. This is used when the user has supplied values in shipping fields but then checks \"shipping is billing\". We don't want to clear the view but we don't want to send a shipping address to the API.\n                var cartCopy = angular.copy(scope.cart);\n\n                // If set that billing is same as shipping, set all shipping values to null so that the API doesn't receive any of the data set on the view.\n                if (scope.shippingIsBilling) {\n                    if (cartCopy.customer.shipping_address) {\n                        cartCopy.customer.shipping_address.name = null;\n                        cartCopy.customer.shipping_address.address_1 = null;\n                        cartCopy.customer.shipping_address.address_2 = null;\n                        cartCopy.customer.shipping_address.city = null;\n                        cartCopy.customer.shipping_address.state_prov = null;\n                        cartCopy.customer.shipping_address.postal_code = null;\n                        cartCopy.customer.shipping_address.country = null;\n                    }\n                }\n\n                CartService.update(cartCopy, scope.params).then(function (cart) {\n\n                    // In the event that there were changes to the view between the time the call was sent and returned, we don't want to overwrite them. As a result, we won't sync the server customer values with the model.\n                    if (scope.cart) {\n                        cart.customer = scope.cart.customer;\n                    }\n\n                    scope.cart = cart;\n\n                    // Fire the success event\n                    if (scope.onSuccess) {\n                        scope.onSuccess(cart);\n                    }\n\n                }, function (error) {\n                    scope.error = error;\n                    // Fire the error event\n                    if (scope.onError) {\n                        scope.onError(error);\n                    }\n                });\n\n            });\n\n        }\n    };\n}]);\n\napp.directive('updateInvoice', ['InvoiceService', function (InvoiceService) {\n\n    // Shared scope:\n    // updateCart: The updated invoice to save. If an existing invoice does not exist, one will be created and returned.\n    // error: The error object to communicate errors.\n    // onSubmit: A function that will be called from scope when a invoice update is submitted.\n    // onSuccess: A function that will be called from scope when the invoice is successfully updated. Will include the response invoice object as a parameter.\n    // onFailure: A function that will be called from scope when the update fails. Will include the error object as a parameter.\n\n    // Attributes\n    // params: An object that supplies a list of parameters to send to the api, such as show, hide, formatted, etc. Used to customize the response object.\n\n    return {\n        restrict: 'A',\n        require: '^form',\n        scope: {\n            invoice: '=updateInvoice',\n            params: '=?',\n            error: '=?',\n            onSubmit: '=?',\n            onSuccess: '=?',\n            onError: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            elem.bind(\"click\", function () {\n\n                // Fire the submit event\n                if (scope.onSubmit) {\n                    scope.onSubmit();\n                }\n\n                // Clear previous errors\n                scope.error = null;\n\n                // Prep the params\n                var params = scope.params || attrs.params;\n                params = utils.mergeParams(params, null, null);\n\n                InvoiceService.update(scope.invoice, scope.params).then(function (invoice) {\n                    scope.invoice = invoice;\n                    // Fire the success event\n                    if (scope.onSuccess) {\n                        scope.onSuccess(invoice);\n                    }\n                }, function (error) {\n                    scope.error = error;\n                    // Fire the error event\n                    if (scope.onError) {\n                        scope.onError(error);\n                    }\n                });\n\n            });\n\n        }\n    };\n}]);\n\napp.directive('addToCart', ['CartService', 'gettextCatalog', function (CartService, gettextCatalog) {\n\n    // Shared scope:\n    // addToCart: The product to add to the cart. Must include the product_id.\n    // quantity: The quantity of the item to add to teh cart.\n    // error: The error object to communicate errors.\n    // onSubmit: A function that will be called from scope when the function is triggered.\n    // onSuccess: A function that will be called from scope when the item is successfully added. Will include the response item object as a parameter.\n    // onError: A function that will be called from scope when the function fails. Will include the error object as a parameter.\n    // params: An object that supplies a list of parameters to send to the api, such as show, hide, formatted, etc. Used to customize the response object.\n\n    return {\n        restrict: 'A',\n        require: '^form',\n        scope: {\n            product: '=addToCart',\n            params: '=?',\n            quantity: '=?',\n            error: '=?',\n            onSubmit: '=?',\n            onSuccess: '=?',\n            onError: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            elem.bind(\"click\", function () {\n\n                // Fire the submit event\n                if (scope.onSubmit) {\n                    scope.onSubmit();\n                }\n\n                if (ctrl.$invalid == true) {\n                    scope.$apply(function () {\n                        scope.error = { type: \"bad_request\", reference: \"AWu1twY\", code: \"invalid_input\", message: gettextCatalog.getString(\"There was a problem with some of the information you supplied. Please review for errors and try again.\"), status: 400 };\n                    });\n                    return;\n                }\n\n                // Clear previous errors\n                scope.error = null;\n\n                // Build the item\n                var item = { product_id: scope.product.product_id };\n\n                // Set the quantity\n                if (scope.quantity) {\n                    item.quantity = scope.quantity;\n                }\n\n                // Prep the params\n                var params = scope.params || attrs.params;\n                params = utils.mergeParams(params, null, null);\n\n                CartService.addItem(item, scope.params).then(function (item) {\n                    scope.item = item;\n                    // Fire the success event\n                    if (scope.onSuccess) {\n                        scope.onSuccess(item);\n                    }\n                }, function (error) {\n                    scope.error = error;\n                    // Fire the error event\n                    if (scope.onError) {\n                        scope.onError(error);\n                    }\n                });\n\n            });\n\n        }\n    };\n}]);\n\napp.directive('submitPayment', ['CartService', 'InvoiceService', 'PaymentService', 'gettextCatalog', function (CartService, InvoiceService, PaymentService, gettextCatalog) {\n\n    // Shared scope:\n    // submitPayment: Provide the payment_method to be used for payment. Should include, at a minimum, the following properties: payment_type, data (data includes payment method-specific fields such as credit card number).\n    // cart: Provide the cart that will be paid for. The cart will automatically be updated (or created if not yet created) through the API before the payment for the payment is submitted. Cart or invoice can be supplied, but not both.\n    // invoice: Provide the invoice that will be paid for. The invoice will automatically be updated through the API before the payment for the payment is submitted (i.e. a currency change). Cart or invoice can be supplied, but not both.\n    // payment: Provide the payment object for a direct, stand-alone payment (no cart or invoice). If payment is provided cart and invoice should NOT be provided.\n    // error: The error object to communicate errors.\n    // onSubmit: A function that will be called from scope when a payment is submitted. If the function that is called returns false, then the directive will stop processing and return.\n    // onSuccess: A function that will be called from scope when the payment is successfully completed. Will include the response payment object as a parameter.\n    // onError: A function that will be called from scope when the payment fails. Will include the (failed) response payment object as a parameter.\n    // onValidationSuccess: A function that will be called from scope when the validation is successful. If the function that is called returns false, then the directive will stop processing and return.\n    // onValidationError: A function that will be called from scope when the validation fails. The error object will be returned as a parameter.\n    // loading: This value is true while the submit payment is processing, false when done processing.\n\n    // Shared scope that are specific to different payment methods:\n\n    // Credit Card\n    // shippingIsBilling: A flag to indicate if the billing address and shipping address are the same. If so, the shipping address will be removed.\n\n    // Amazon Pay\n    // getConsentStatus: Pass in a function that allows you get the status of the Amazon Pay consent checkbox. This function you pass in is provided by the amazonPayButton directive.\n\n    // Attributes\n    // params: An object that supplies a list of parameters to send to the api for the payment, such as show, hide, formatted, etc. Used to customize the response object.\n    // cartParams: When a payment is submitted, a cart may be created or updated. An object that supplies a list of parameters to send to the api for the cart, such as show, hide, formatted, etc. Used to customize the response object.\n\n    return {\n        restrict: 'A',\n        require: '^form',\n        scope: {\n            paymentMethod: '=submitPayment',\n            cart: '=?',\n            invoice: '=?',\n            payment: '=?',\n            params: '=?',\n            cartParams: '=?',\n            error: '=?',\n            onSubmit: '=?',\n            onSuccess: '=?',\n            onValidationSuccess: '=?',\n            onValidationError: '=?',\n            onError: '=?',\n            shippingIsBilling: '=?',\n            getConsentStatus: '=?',\n            loading: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            elem.bind(\"click\", function () {\n\n                scope.loading = true;\n\n                // Fire the submit event\n                if (scope.onSubmit) {\n                    var result = scope.onSubmit();\n                    if (result === false) {\n                        scope.loading = false;\n                        return;\n                    }\n                }\n\n                // Validation functions. \n                function validateFormData() {\n\n                    var error = null;\n\n                    if (ctrl.$invalid == true) {\n                        error = { type: \"bad_request\", reference: \"kI1ETNz\", code: \"invalid_input\", message: gettextCatalog.getString(\"There was a problem with some of the information you supplied. Please review for errors and try again.\"), status: 400 };\n                    }\n\n                    if (scope.onValidationError)\n                        scope.onValidationError(error);\n\n                    scope.loading = false;\n                    return error;\n\n                }\n\n                function validateAmountIsProvided() {\n\n                    var error = null;\n\n                    if (!scope.payment.total && !scope.payment.subtotal && !scope.payment.shipping) {\n                        error = { type: \"bad_request\", reference: \"eiptRbg\", code: \"invalid_input\", message: gettextCatalog.getString(\"Please provide an amount for your payment.\"), status: 400 };\n                    }\n\n                    if (scope.onValidationError)\n                        scope.onValidationError(error);\n\n                    scope.loading = false;\n                    return error;\n\n                }\n\n                // Perform validatations, depending on payment method type\n                var error = null;\n                switch (scope.paymentMethod.type) {\n\n                    case \"credit_card\":\n\n                        // Wallet providers such as PayPal and Amazon Pay provide customer data as a callback so no need to collect from the user directly.\n                        error = validateFormData();\n\n                        if (error) {\n                            scope.$apply(function () {\n                                scope.error = error;\n                            });\n\n                            if (scope.onValidationError)\n                                scope.onValidationError(error);\n\n                            scope.loading = false;\n                            return;\n                        }\n\n                        break;\n\n                    case \"paypal\":\n\n                        // We skip validating form data for this payment method as customer data is provided by the provider. If a direct payment, we need to validate that an amount is provided.\n                        if (!scope.cart && !scope.invoice) {\n                            error = validateAmountIsProvided();\n                        }\n\n                        if (error) {\n                            scope.$apply(function () {\n                                scope.error = error;\n\n                                if (scope.onValidationError)\n                                    scope.onValidationError(error);\n\n                            });\n                            scope.loading = false;\n                            return;\n                        }\n\n                    case \"amazon_pay\":\n\n                        // If the payment method contains a billing agreement ID or the payment is marked to be saved and the user has not given consent, return an error.\n                        if ((scope.paymentMethod.data.billing_agreement_id || scope.paymentMethod.save) && !scope.getConsentStatus()) {\n                            error = { type: \"bad_request\", reference: \"nauRcF8\", code: \"invalid_input\", message: gettextCatalog.getString(\"Please check the box to provide consent to save your payment method for future payments.\"), status: 400 };\n                        }\n\n                        // We skip validating form data for this payment method as customer data is provided by the provider. If a direct payment, we need to validate that an amount is provided.\n                        if (!scope.cart && !scope.invoice) {\n                            error = validateAmountIsProvided();\n                        }\n\n                        if (error) {\n                            scope.$apply(function () {\n                                scope.error = error;\n\n                                if (scope.onValidationError)\n                                    scope.onValidationError(error);\n\n                            });\n                            scope.loading = false;\n                            return;\n                        }\n\n                        break;\n\n                }\n\n                if (scope.onValidationSuccess) {\n                    var result = scope.onValidationSuccess();\n                    if (result === false) {\n                        scope.loading = false;\n                        return;\n                    }\n                }\n\n                // For direct payments, amounts are provided by form input. If supplied, make sure the values are numbers and not strings. This ensures that the JSON sent to the API will be in numeric format and not string, which the API will reject as invalid.\n                if (scope.payment) {\n                    if (scope.payment.total)\n                        scope.payment.total = Number(scope.payment.total);\n\n                    if (scope.payment.subtotal)\n                        scope.payment.subtotal = Number(scope.payment.subtotal);\n\n                    if (scope.payment.shipping)\n                        scope.payment.shipping = Number(scope.payment.shipping);\n\n                    if (scope.payment.tax)\n                        scope.payment.tax = Number(scope.payment.tax);\n                }\n\n                // Disable the clicked element\n                elem.prop(\"disabled\", true);\n\n                // Clear previous errors\n                scope.error = null;\n\n                // Prep the params\n                var params = scope.params || attrs.params;\n                params = utils.mergeParams(params, null, \"order\");\n\n                if (scope.cart) {\n\n                    // If billing is shipping, remove the shipping address\n                    if (scope.shippingIsBilling) {\n                        delete scope.cart.customer.shipping_address;\n                    }\n\n                    CartService.pay(scope.cart, scope.paymentMethod, params, scope.cartParams).then(function (payment) {\n\n                        // Fire the success event\n                        if (scope.onSuccess) {\n                            scope.onSuccess(payment);\n                        }\n\n                        // If the cart is expanded, update the cart.\n                        if (payment.cart && payment.cart.url) {\n                            scope.cart = payment.cart;\n                        }\n\n                        // Remove the disabled attribute\n                        scope.loading = false;\n                        elem.prop(\"disabled\", null);\n\n                    }, function (error) {\n\n                        scope.error = error;\n\n                        // Fire the error event\n                        if (scope.onError) {\n                            scope.onError(error);\n                        }\n\n                        // Remove the disabled attribute\n                        scope.loading = false;\n                        elem.prop(\"disabled\", null);\n\n                    });\n                }\n\n                if (scope.invoice) {\n\n                    InvoiceService.pay(scope.invoice, scope.paymentMethod, params).then(function (payment) {\n\n                        // Fire the success event\n                        if (scope.onSuccess) {\n                            scope.onSuccess(payment);\n                        }\n\n                        // If the invoice is expanded, update the invoice.\n                        if (payment.invoice && payment.invoice.url) {\n                            scope.invoice = payment.invoice;\n                        }\n\n                        // Remove the disabled attribute\n                        scope.loading = false;\n                        elem.prop(\"disabled\", null);\n\n                    }, function (error) {\n\n                        scope.error = error;\n\n                        // Fire the error event\n                        if (scope.onError) {\n                            scope.onError(error);\n                        }\n\n                        // Remove the disabled attribute\n                        scope.loading = false;\n                        elem.prop(\"disabled\", null);\n\n                    });\n                }\n\n                if (scope.payment) {\n\n                    scope.payment.payment_method = scope.paymentMethod;\n\n                    // If billing is shipping, remove the shipping address\n                    if (scope.shippingIsBilling && scope.payment.customer) {\n                        delete scope.payment.customer.shipping_address;\n                    }\n\n                    PaymentService.createDirect(scope.payment, params).then(function (payment) {\n\n                        // Fire the success event\n                        if (scope.onSuccess) {\n                            scope.onSuccess(payment);\n                        }\n\n                        // Remove the disabled attribute\n                        scope.loading = false;\n                        elem.prop(\"disabled\", null);\n\n                    }, function (error) {\n\n                        scope.error = error;\n\n                        // Fire the error event\n                        if (scope.onError) {\n                            scope.onError(error);\n                        }\n\n                        // Remove the disabled attribute\n                        scope.loading = false;\n                        elem.prop(\"disabled\", null);\n\n                    });\n                }\n\n            });\n\n        }\n    };\n}]);\n\napp.directive('commitPayment', ['CartService', 'InvoiceService', 'PaymentService', 'gettextCatalog', function (CartService, InvoiceService, PaymentService, gettextCatalog) {\n\n    // This is used for payment methods such as PayPal and Amazon Pay that need to be tiggered for completion after they have been reviewed by the customer. \n\n    // Shared scope:\n    // commitPayment: Provide the payment_id of the payment that will be committed.\n    // sale: If a the payment is associated with a cart or invoice, you can supply the it here. If you supply a cart, any changes to the cart (such as customer data changes) will be saved before the commit is attempted.\n    // error: The error object to communicate errors.\n    // onSubmit: A function that will be called from scope when a payment is submitted.\n    // onSuccess: A function that will be called from scope when the payment is successfully completed. Will include the response payment object as a parameter.\n    // onError: A function that will be called from scope when the payment fails. Will include the (failed) response payment object as a parameter.\n\n    // Attributes\n    // params: An object that supplies a list of parameters to send to the api, such as show, hide, formatted, etc. Used to customize the response object.\n    // saleType: \"cart\" or \"invoice\" - a string that indicates what is being passed in through the sale shared scope.\n\n    return {\n        restrict: 'A',\n        require: '^form',\n        scope: {\n            paymentId: '=commitPayment',\n            sale: '=?',\n            invoice: '=?',\n            params: '=?',\n            error: '=?',\n            onSubmit: '=?',\n            onSuccess: '=?',\n            onError: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            elem.bind(\"click\", function () {\n\n                // Fire the submit event\n                if (scope.onSubmit) {\n                    scope.onSubmit();\n                }\n\n                // Data is not validated with PayPal since the customer data will come from the response.\n                if (ctrl.$invalid == true) {\n\n                    scope.$apply(function () {\n                        scope.error = { type: \"bad_request\", reference: \"eS9G9MA\", code: \"invalid_input\", message: gettextCatalog.getString(\"There was a problem with some of the information you supplied. Please review for errors and try again.\"), status: 400 };\n                    });\n\n                    // Fire the error event\n                    if (scope.onError) {\n                        scope.onError(error);\n                    }\n\n                    return;\n                }\n\n                // Disable the clicked element\n                elem.prop(\"disabled\", true);\n\n                // Clear previous errors\n                scope.error = null;\n\n                // Prep the params\n                var params = scope.params || attrs.params;\n                params = utils.mergeParams(params, null, \"order\");\n\n                // Define the commit function.\n                var commit = function (payment_id, params) {\n\n                    PaymentService.commit(payment_id, params).then(function (payment) {\n\n                        // Fire the success event\n                        if (scope.onSuccess) {\n                            scope.onSuccess(payment);\n                        }\n\n                        // Remove the disabled attribute\n                        elem.prop(\"disabled\", null);\n\n                    }, function (error) {\n\n                        scope.error = error;\n\n                        // Fire the error event\n                        if (scope.onError) {\n                            scope.onError(error);\n                        }\n\n                        // Remove the disabled attribute\n                        elem.prop(\"disabled\", null);\n\n                    });\n                };\n\n                // Perform the commit. If a cart, update the cart before running the payment.\n                if (attrs.saleType == \"cart\") {\n\n                    CartService.update(scope.sale).then(function (cart) {\n                        commit(scope.paymentId, params);\n                    }, function (error) {\n\n                        scope.error = error;\n\n                        // Fire the error event\n                        if (scope.onError) {\n                            scope.onError(error);\n                        }\n\n                        // Remove the disabled attribute\n                        elem.prop(\"disabled\", null);\n\n                    });\n\n                } else {\n                    // An invoice or direct payment. Nothing to update in advance, just run the commit.\n                    commit(scope.paymentId, params);\n                }\n\n            });\n\n        }\n    };\n}]);\n\napp.directive('currencySelect', ['CurrencyService', 'CartService', 'InvoiceService', 'PaymentService', 'ProductService', 'SettingsService', 'StorageService', '$timeout', '$rootScope', function (CurrencyService, CartService, InvoiceService, PaymentService, ProductService, SettingsService, StorageService, $timeout, $rootScope) {\n\n    return {\n        restrict: 'A',\n        scope: {\n            currency: '=selectCurrency',\n            cart: '=?',\n            invoice: '=?',\n            payment: '=?',\n            options: '=?',\n            products: '=?',\n            params: '=?',\n            onSuccess: '=?',\n            onError: '=?',\n            error: '=?'\n        },\n        link: function (scope, elem, attrs) {\n\n            // Shared scope:\n            // currency: The new currency\n            // cart: If running on a page with an cart, pass the cart object in and it will be updated with the pricing in the new currency\n            // invoice: If running on a page with an invoice, pass the invoice object in and it will be updated with the pricing in the new currency\n            // payment: If running on a page with a stand-alone payment, pass the payment object in and the currency will be set on the object\n            // options: If suppying a payment, you can supply the payment/options object and it will be updated with a new version as a result of the currency selection / change.\n            // product: If running on a page with a single product, pass the product in and it will be updated with the pricing in the new currency\n            // products: If running on a page with a list of products, pass the products list in and it will be updated with the pricing in the new currency\n            // error: The error object to communicate errors.\n            // onSuccess: A function that will be called from scope when the currency is successfully changed. Will include the newly set currency as a parameter.\n            // onError: A function that will be called from scope when the currency change fails. Will include an error object as a parameter.\n\n            // Attributes\n            // params: Any parameters you want to pass to the update function (i.e. expand, show, etc.)\n            // asDropdown: If specified, a Bootstrap dropdown will be output. Otherwise, a HTML select intput will be output.\n\n            // Get the settings\n            var settings = SettingsService.get();\n\n            if (utils.hasProperty(attrs, \"asDropdown\")) {\n\n                var elemNg = angular.element(elem[0]);\n                _.each(settings.account.currencies, function (item) {\n\n                    var option = '<li><a class=\"pointer\">' + item.name + '</a></li>';\n                    optionNg = angular.element(option);\n\n                    elemNg.append(optionNg);\n\n                    optionNg.bind(\"click\", function (event) {\n\n                        // Clear previous errors\n                        scope.error = null;\n\n                        // Placed within a timeout otherwise the update was happening before the change to the model occured.\n                        $timeout(function () {\n                            setCurrency(scope, item.code, attrs);\n                        });\n                    });\n\n                });\n\n                // Set the current value for display\n                var elems = angular.element(elem.parent().children());\n                var label = elems.find(\"span\");\n                if (label) {\n                    label.text(CurrencyService.getCurrencyName());\n                }\n\n                // Listen for a change\n                $rootScope.$on(\"currencyChanged\", function (event, currency) {\n                    var elems = angular.element(elem.parent().children());\n                    var label = elems.find(\"span\");\n                    if (label) {\n                        label.text(CurrencyService.getCurrencyName());\n                    }\n                });\n\n            } else {\n\n                var elemNg = angular.element(elem[0]);\n                _.each(settings.account.currencies, function (item) {\n\n                    var option = '<option value=\"' + item.code + '\"';\n                    if (item.code == CurrencyService.getCurrency()) {\n                        option += \" selected\";\n                    }\n                    option += '>' + item.name + '</option>';\n                    elemNg.append(option);\n\n                });\n\n                elem.bind(\"change\", function (event) {\n\n                    // Clear previous errors\n                    scope.error = null;\n\n                    var selectedCurrency = angular.element(elem[0]).val();\n\n                    // Placed within a timeout otherwise the update was happening before the change to the model occured.\n                    $timeout(function () {\n                        setCurrency(scope, selectedCurrency, attrs);\n                    });\n\n                });\n\n                // Listen for a change\n                $rootScope.$on(\"currencyChanged\", function (event, currency) {\n                    elemNg[0].value = currency;\n                });\n            }\n\n            var setCurrency = function (scope, selectedCurrency, attrs) {\n\n                // Prep the params\n                var params = scope.params || attrs.params;\n                params = utils.mergeParams(params, null, null);\n\n                // If associated with a cart, update the cart.\n                if (scope.cart && StorageService.get(\"cart_id\")) {\n\n                    CartService.update({ currency: selectedCurrency }, scope.params).then(function (cart) {\n\n                        CurrencyService.setCurrency(selectedCurrency);\n\n                        // We don't want to remove unsaved customer values from the view.\n                        var customer = null;\n                        if (scope.cart) {\n                            customer = scope.cart.customer;\n                        }\n                        scope.cart = cart;\n\n                        if (customer) {\n                            // Restore the original customer data.\n                            scope.cart.customer = customer;\n                        }\n\n                        if (scope.onSuccess) {\n                            scope.onSuccess(selectedCurrency);\n                        }\n\n                    }, function (error) {\n                        scope.error = error;\n                        if (scope.onError) {\n                            scope.onError(error);\n                        }\n                    });\n\n                };\n\n                // If associated with an invoice, update the invoice.\n                if (scope.invoice && StorageService.get(\"invoice_id\")) {\n\n                    InvoiceService.update({ currency: selectedCurrency }, scope.params).then(function (invoice) {\n\n                        CurrencyService.setCurrency(selectedCurrency);\n\n                        // We don't want to remove unsaved customer values from the view.\n                        var customer = null;\n                        if (scope.invoice) {\n                            customer = scope.invoice.customer;\n                        }\n                        scope.invoice = invoice;\n\n                        if (customer) {\n                            // Restore the original customer data.\n                            scope.invoice.customer = customer;\n                        }\n\n                        if (scope.onSuccess) {\n                            scope.onSuccess(selectedCurrency);\n                        }\n\n                    }, function (error) {\n                        scope.error = error;\n                        if (scope.onError) {\n                            scope.onError(error);\n                        }\n                    });\n\n                };\n\n                // If associated with a payment, update the payment. Refresh the payment options, if provided.\n                if (scope.payment) {\n\n                    scope.payment.currency = selectedCurrency;\n\n                    if (scope.options) {\n                        // Update the options according to the supplied currency.\n                        PaymentService.getOptions({ currency: selectedCurrency }).then(function (options) {\n                            scope.options = options;\n                        }, function (error) {\n                            scope.error = error;\n                            if (scope.onError) {\n                                scope.onError(error);\n                            }\n                        });\n                    }\n\n                    if (scope.onSuccess) {\n                        scope.onSuccess(selectedCurrency);\n                    }\n\n                    CurrencyService.setCurrency(selectedCurrency);\n                    scope.payment.currency = selectedCurrency;\n\n                };\n\n                // If products were supplied, refresh the list of products to show the products in the newly selected currency\n                if (scope.products) {\n\n                    // Pass through the current parameters from products (such as pagination)\n                    var pageParams = utils.getQueryParameters(scope.products.current_page_url);\n\n                    // Set the new currency\n                    params.currency = selectedCurrency;\n\n                    ProductService.getList(scope.params).then(function (products) {\n\n                        scope.products = products;\n                        CurrencyService.setCurrency(selectedCurrency);\n\n                        // If the user changes the currency of a product and has a cart, update the cart to that same currency to provide a better experience.\n                        if (StorageService.get(\"cart_id\")) {\n                            CartService.update({ currency: selectedCurrency }, scope.params, true);\n                        };\n\n                        if (scope.onSuccess) {\n                            scope.onSuccess(selectedCurrency);\n                        }\n\n                    }, function (error) {\n                        scope.error = error;\n                        if (scope.onError) {\n                            scope.onError(error);\n                        }\n                    });\n                }\n\n                // If a product was supplied, refresh the product to show the product in the newly selected currency\n                if (scope.product) {\n\n                    // Pass through the current parameters from product\n                    var pageParams = utils.getQueryParameters(scope.product.url);\n\n                    // Set the new currency\n                    scope.params.currency = selectedCurrency;\n\n                    ProductService.get(scope.product.product_id, scope.params).then(function (product) {\n\n                        scope.product = product;\n                        CurrencyService.setCurrency(selectedCurrency);\n\n                        // If the user changes the currency of a product and has a cart, update the cart to that same currency to provide a better experience.\n                        if (StorageService.get(\"cart_id\")) {\n                            CartService.update({ currency: selectedCurrency }, scope.params, true);\n                        };\n\n                        if (scope.onSuccess) {\n                            scope.onSuccess(selectedCurrency);\n                        }\n\n                    }, function (error) {\n                        scope.error = error;\n                        if (scope.onError) {\n                            scope.onError(error);\n                        }\n                    });\n                }\n\n            };\n        }\n    };\n}]);\n\napp.directive('languageSelect', ['LanguageService', '$timeout', '$rootScope', function (LanguageService, $timeout, $rootScope) {\n\n    return {\n        restrict: 'A',\n        link: function (scope, elem, attrs) {\n\n            // Get the languages\n            var languages = LanguageService.getLanguages();\n\n            if (utils.hasProperty(attrs, \"asDropdown\")) {\n\n                var elemNg = angular.element(elem[0]);\n\n                _.each(languages, function (language) {\n                    var option = '<li><a class=\"pointer\">' + language.name + '</a></li>';\n                    optionNg = angular.element(option);\n                    elemNg.append(optionNg);\n\n                    optionNg.bind(\"click\", function (event) {\n\n                        // Placed within a timeout otherwise the update was happening before the change to the model occured.\n                        $timeout(function () {\n                            LanguageService.setLanguage(language.code, attrs.languagesPath);\n                        });\n\n                    });\n                });\n\n                // Set the current value for display\n                var elems = angular.element(elem.parent().children());\n                var label = elems.find(\"span\");\n                if (label) {\n                    label.text(LanguageService.getSelectedLanguage().name);\n                }\n\n                // Listen for a change\n                $rootScope.$on(\"languageChanged\", function (event, currency) {\n                    var elems = angular.element(elem.parent().children());\n                    var label = elems.find(\"span\");\n                    if (label) {\n                        label.text(LanguageService.getSelectedLanguage().name);\n                    }\n                });\n\n            } else {\n\n                var elemNg = angular.element(elem[0]);\n                _.each(languages, function (language) {\n\n                    var option = '<option value=\"' + language.code + '\"';\n                    if (language.code == LanguageService.getSelectedLanguage().code) {\n                        option += \" selected\";\n                    }\n                    option += '>' + language.name + '</option>';\n                    elemNg.append(option);\n\n                });\n\n                elem.bind(\"change\", function (event) {\n\n                    var selectedLanguage = angular.element(elem[0]).val();\n\n                    // Placed within a timeout otherwise the update was happening before the change to the model occured.\n                    $timeout(function () {\n                        LanguageService.setLanguage(selectedLanguage);\n                    });\n\n                });\n\n                // Listen for a change\n                $rootScope.$on(\"languageChanged\", function (event, language) {\n                    elemNg[0].value = language;\n                });\n            }\n        }\n    };\n}]);\n\napp.directive('shippingSelect', ['CartService', 'InvoiceService', '$timeout', function (CartService, InvoiceService, $timeout) {\n\n    return {\n        restrict: 'A',\n        scope: {\n            sale: '=?',\n            shippingQuotes: '=?',\n            params: '=?',\n            onSuccess: '=?',\n            onError: '=?',\n            error: '=?'\n        },\n        link: function (scope, elem, attrs) {\n\n            // Shared scope:\n            // sale: The cart or invoice that is on the current page.\n            // error: The error object to communicate errors.\n            // onSuccess: A function that will be called from scope when the currency is successfully changed. Will include the newly set currency as a parameter.\n            // onError: A function that will be called from scope when the currency change fails. Will include an error object as a parameter.\n\n            // Attributes\n            // params: Any parameters you want to pass to the update function (i.e. expand, show, etc.)\n            // saleType: \"cart\" or \"invoice\" - a string that indicates what is being passed in through the sale shared scope.\n\n            scope.$watch(\"shippingQuotes\", function (newValue, oldValue) {\n\n                if (newValue) {\n\n                    var method_id = null;\n                    if (scope.sale.shipping_item) {\n                        method_id = scope.sale.shipping_item.item_id;\n                    }\n\n                    var elemNg = angular.element(elem[0]);\n\n                    // Clear any previous options\n                    elemNg.html(\"\");\n\n                    _.each(scope.shippingQuotes, function (item) {\n\n                        var option = '<option value=\"' + item.method_id + '\"';\n                        if (item.method_id == method_id) {\n                            option += \" selected\";\n                        }\n                        option += '>' + item.description + ' (' + item.formatted.price + ')</option>';\n                        elemNg.append(option);\n\n                    });\n\n                }\n            });\n\n            elem.bind(\"change\", function (event) {\n\n                // Clear previous errors\n                scope.error = null;\n\n                var selectedMethod = angular.element(elem[0]).val();\n\n                // Prep the params\n                var params = scope.params || attrs.params;\n                params = utils.mergeParams(params, null, null);\n\n                // Placed within a timeout otherwise the update was happening before the change to the model occured.\n                $timeout(function () {\n\n                    var data = { shipping_method_id: selectedMethod };\n\n                    if (attrs.saleType == \"cart\") {\n                        CartService.update(data, scope.params).then(function (cart) {\n\n                            // In the event that there were changes to the view between the time the call was sent and returned, we don't want to overwrite them. As a result, we won't sync the server customer values with the model.\n                            cart.customer = scope.sale.customer;\n\n                            // Sync the scope to the response.\n                            scope.sale = cart;\n\n                            if (scope.onSuccess) {\n                                scope.onSuccess(selectedCurrency);\n                            }\n\n                        }, function (error) {\n                            scope.error = error;\n                            if (scope.onError) {\n                                scope.onError(error);\n                            }\n                        });\n                    }\n\n                    if (attrs.saleType == \"invoice\") {\n                        InvoiceService.update(data, scope.params).then(function (invoice) {\n\n                            // In the event that there were changes to the view between the time the call was sent and returned, we don't want to overwrite them. As a result, we won't sync the server customer values with the model.\n                            invoice.customer = scope.sale.customer;\n\n                            // Sync the scope to the response.\n                            scope.sale = invoice;\n\n                            if (scope.onSuccess) {\n                                scope.onSuccess(selectedCurrency);\n                            }\n\n                        }, function (error) {\n                            scope.error = error;\n                            if (scope.onError) {\n                                scope.onError(error);\n                            }\n                        });\n                    }\n\n                });\n            });\n        }\n    };\n}]);\n\napp.directive('shippingRadio', ['CartService', 'InvoiceService', '$timeout', function (CartService, InvoiceService, $timeout) {\n\n    return {\n        restrict: 'A',\n        scope: {\n            sale: '=?',\n            shippingQuotes: '=?',\n            params: '=?',\n            onSuccess: '=?',\n            onError: '=?',\n            error: '=?'\n        },\n        link: function (scope, elem, attrs) {\n\n            // Shared scope:\n            // sale: The cart or invoice that is on the current page.\n            // error: The error object to communicate errors.\n            // onSuccess: A function that will be called from scope when the currency is successfully changed. Will include the newly set currency as a parameter.\n            // onError: A function that will be called from scope when the currency change fails. Will include an error object as a parameter.\n\n            // Attributes\n            // params: Any parameters you want to pass to the update function (i.e. expand, show, etc.)\n            // saleType: \"cart\" or \"invoice\" - a string that indicates what is being passed in through the sale shared scope.\n\n            elem.bind(\"change\", function (event) {\n\n                // Clear previous errors\n                scope.error = null;\n\n                var selectedMethod = attrs.shippingRadio;\n\n                // Prep the params\n                var params = scope.params || attrs.params;\n                params = utils.mergeParams(params, null, null);\n\n                // Placed within a timeout otherwise the update was happening before the change to the model occured.\n                $timeout(function () {\n                    var data = { shipping_method_id: selectedMethod };\n\n                    if (attrs.saleType == \"cart\") {\n                        CartService.update(data, scope.params).then(function (cart) {\n\n                            // In the event that there were changes to the view between the time the call was sent and returned, we don't want to overwrite them. As a result, we won't sync the server customer values with the model.\n                            if (scope.sale) {\n                                cart.customer = scope.sale.customer;\n                            }\n\n                            // Sync the scope to the response.\n                            scope.sale = cart;\n\n                            if (scope.onSuccess) {\n                                scope.onSuccess(selectedCurrency);\n                            }\n\n                        }, function (error) {\n                            scope.error = error;\n                            if (scope.onError) {\n                                scope.onError(error);\n                            }\n                        });\n                    }\n\n                    if (attrs.saleType == \"invoice\") {\n                        InvoiceService.update(data, scope.params).then(function (invoice) {\n\n                            // In the event that there were changes to the view between the time the call was sent and returned, we don't want to overwrite them. As a result, we won't sync the server customer values with the model.\n                            if (scope.sale) {\n                                invoice.customer = scope.sale.customer;\n                            }\n\n                            // Sync the scope to the response.\n                            scope.sale = invoice;\n\n                            if (scope.onSuccess) {\n                                scope.onSuccess(selectedCurrency);\n                            }\n\n                        }, function (error) {\n                            scope.error = error;\n                            if (scope.onError) {\n                                scope.onError(error);\n                            }\n                        });\n                    }\n\n                });\n            });\n        }\n    };\n}]);\n\napp.directive('customerCountries', ['GeoService', '$timeout', function (GeoService, $timeout) {\n\n    return {\n        restrict: 'A',\n        require: \"ngModel\",\n        scope: {\n            customerCountries: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            // Attributes\n            // customerCountries: A list of allowed customer countries\n            // placeholderName: A value to display as the \"empty\" option, rather than leaving blank.\n\n            scope.$watch(\"customerCountries\", function (customerCountries, oldValue) {\n\n                if (customerCountries) {\n\n                    var elemNg = angular.element(elem[0]);\n\n                    // Reset the existing options. If the value is empty, leave in place, this is the \"blank\" option in the list.\n                    var hasEmpty = false;\n                    for (var i = elemNg[0].options.length - 1 ; i >= 0 ; i--) {\n                        if (elemNg[0].options[i].value) {\n                            elemNg[0].remove(i);\n                        } else {\n                            hasEmpty = true;\n                        }\n                    }\n\n                    // If it doesn't have an empty value, add it.\n                    if (!hasEmpty) {\n                        elemNg[0].appendChild(document.createElement(\"option\"));\n                    }\n\n                    // Get the entire list of countries\n                    var countries = GeoService.getData().countries;\n\n                    countries = _.filter(countries, function (country) { return customerCountries.indexOf(country.code) > -1; });\n\n                    // Get the value\n                    var value = ctrl.$viewValue || ctrl.$modelValue;\n\n                    // Set a flag to indicate if you found a match of current country\n                    var match = false;\n\n                    _.each(countries, function (item) {\n\n                        var option = '<option class=\"select-options-color\" value=\"' + item.code + '\"';\n                        if (item.code == value) {\n                            option += \" selected\";\n                            match = true;\n                        }\n                        option += '>' + item.name + '</option>';\n                        elemNg.append(option);\n\n                    });\n\n                    // If no match, remove the value of the current control\n                    if (match == false) {\n                        ctrl.$setViewValue(null);\n                    }\n\n                }\n            });\n\n        }\n    };\n}]);\n\napp.directive('showErrors', ['$timeout', 'SettingsService', function ($timeout, SettingsService) {\n    return {\n        restrict: 'A',\n        require: '^form',\n        link: function (scope, elem, attrs, ctrl) {\n\n            // Find the input element and error block elements\n            var load = function () {\n                $timeout(function () {\n\n                    var inputEl = elem[0].querySelector(\"[name]\");\n                    var labelEl = elem[0].querySelector(\"label\");\n                    var errorEl = angular.element(elem[0].querySelector(\".error-block\"));\n\n                    // Convert the native angular elements\n                    var inputNgEl = angular.element(inputEl);\n                    var labelNgEl = angular.element(labelEl);\n                    var errorNgEl = angular.element(errorEl);\n\n                    // Remove errors, by default\n                    elem.removeClass(\"has-error\");\n                    errorNgEl.addClass(\"hidden\");\n\n                    // Get the name of the text box\n                    var inputName = inputNgEl.attr(\"name\");\n\n                    // If required, add a required class to the label, if supplied\n                    scope.$watch(attrs.showErrors, function (newValue, oldValue) {\n                        if (newValue && inputEl) {\n                            if (inputEl.required) {\n                                if (labelNgEl) {\n                                    labelNgEl.addClass(\"required\");\n                                }\n                            } else {\n                                labelNgEl.removeClass(\"required\");\n                            }\n                        }\n                    });\n\n                    // Define the action upon which we re-validate\n                    var action = \"blur\";\n\n                    // We don't do select elements on change because it can get cause a huge performance hit if a user navigates up and down a select list with a keyboard, causing many requests per second.\n                    if (inputEl) {\n                        if (inputEl.type == \"checkbox\" || inputEl.type == \"radio\") {\n                            action = \"change\";\n                        }\n                    }\n\n                    // Apply and remove has-error and hidden on blur\n                    inputNgEl.bind(action, function () {\n\n                        var settings = SettingsService.get();\n                        var errorLevel = settings.app.error_notifications || \"moderate\";\n\n                        // Define how aggressive error messaging is on blur: mild, moderate, aggressive\n                        if (errorLevel == \"moderate\") {\n                            elem.toggleClass(\"has-error\", ctrl[inputName].$invalid);\n                        }\n\n                        if (errorLevel == \"aggressive\") {\n                            elem.toggleClass(\"has-error\", ctrl[inputName].$invalid);\n                            errorNgEl.toggleClass(\"hidden\", !ctrl[inputName].$invalid);\n                        }\n\n                        // We only show on form submit, so on blur we only hide.\n                        if (ctrl[inputName].$invalid == false) {\n                            errorNgEl.toggleClass(\"hidden\", true);\n                        }\n\n                    });\n\n                    // Listen for the form submit and show any errors (plus error text)\n                    scope.$on(\"show-errors-check-validity\", function () {\n                        if (ctrl[inputName]) {\n                            elem.toggleClass(\"has-error\", ctrl[inputName].$invalid);\n                            errorNgEl.toggleClass(\"hidden\", !ctrl[inputName].$invalid);\n                        }\n                    });\n\n                });\n            };\n\n            // Set the initial listener\n            load();\n\n            // Watch for a trigger to reload the listener\n            if (attrs.refreshOnChange) {\n                scope.$watch(attrs.refreshOnChange, function (newValue, oldValue) {\n                    load();\n                });\n            }\n        }\n    };\n}]);\n\napp.directive('conversion', ['SettingsService', 'StorageService', function (SettingsService, StorageService) {\n\n    // Attributes:\n    // orderId: The order_id from the order, if null we don't record the conversion, which helps prevent false positives.\n\n    return {\n        restrict: 'A',\n        scope: {\n            conversion: '@'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            // Define your observe function\n            var setTracking = function () {\n                attrs.$observe(\"conversion\", function (order_id) {\n                    if (utils.isNullOrEmpty(order_id) == false) {\n\n                        var head = document.getElementsByTagName(\"head\")[0];\n                        var js = document.createElement(\"script\");\n                        js.id = \"__conversion\";\n                        js.type = \"text/javascript\";\n                        js.src = \"analytics/conversion.js\";\n                        js.setAttribute(\"data-order_id\", order_id);\n\n                        // Remove any existing\n                        if (document.getElementById(\"__conversion\") != null) {\n                            head.removeChild(document.getElementById(\"__conversion\"));\n                        }\n\n                        // Add again to force reload.\n                        head.appendChild(js);\n                    }\n                });\n            };\n\n            // Get the settings\n            var settings = SettingsService.get();\n            if (settings.config.development != true) {\n                // Your are not in a development environment, so set the tracking. \n                setTracking();\n            }\n        }\n    };\n}]);\n\napp.directive('validateOnSubmit', function () {\n    return {\n        restrict: 'A',\n        require: '^form',\n        link: function (scope, elem, attrs, ctrl) {\n\n            elem.bind(\"click\", function () {\n                scope.$broadcast('show-errors-check-validity');\n            });\n\n        }\n    };\n});\n\napp.directive('validateExpMonth', function () {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function (scope, elem, attrs, ctrl) {\n\n            ctrl.$parsers.unshift(function (viewValue) {\n\n                if (utils.isValidInteger(viewValue) == false) {\n                    ctrl.$setValidity('month', false);\n                    return undefined;\n                }\n\n                if (viewValue > 12) {\n                    ctrl.$setValidity('month', false);\n                    return undefined;\n                }\n\n                if (viewValue < 1) {\n                    ctrl.$setValidity('month', false);\n                    return undefined;\n                }\n\n                ctrl.$setValidity('month', true);\n                return viewValue;\n\n            });\n\n        }\n\n    };\n\n});\n\napp.directive('validateExpYear', function () {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function (scope, elem, attrs, ctrl) {\n\n            ctrl.$parsers.unshift(function (viewValue) {\n\n                if (utils.isValidInteger(viewValue) == false) {\n                    ctrl.$setValidity('year', false);\n                    return undefined;\n                }\n\n                if (viewValue.length > 4) {\n                    ctrl.$setValidity('year', false);\n                    return undefined;\n                }\n\n                if (viewValue.length < 2) {\n                    ctrl.$setValidity('year', false);\n                    return undefined;\n                }\n\n                ctrl.$setValidity('year', true);\n                return viewValue;\n\n            });\n\n        }\n\n    };\n\n});\n\napp.directive('validateCvv', function () {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function (scope, elem, attrs, ctrl) {\n\n            ctrl.$parsers.unshift(function (viewValue) {\n\n                var type = attrs.validateCvv;\n                var length;\n\n                // If the supplied cart number is Amex, then the length must be 4. Otherwise, 3.\n                if (type) {\n                    if (type.substring(0, 1).toString() == \"3\") {\n                        length = 4;\n                    } else {\n                        length = 3;\n                    }\n                }\n\n                if (utils.isValidInteger(viewValue) == false) {\n                    ctrl.$setValidity('cvv', false);\n                    return undefined;\n                }\n\n                if (viewValue.length < 3) {\n                    ctrl.$setValidity('cvv', false);\n                    return undefined;\n                }\n\n                if (viewValue.length > 4) {\n                    ctrl.$setValidity('cvv', false);\n                    return undefined;\n                }\n\n                // If the length is defined, we have a card number which means we know the card type. If the length does not match the card type, error.\n                if (length) {\n                    if (viewValue.length != length) {\n                        ctrl.$setValidity('cvv', false);\n                        return undefined;\n                    }\n                }\n\n                ctrl.$setValidity('cvv', true);\n                return viewValue;\n\n            });\n\n        }\n\n    };\n\n});\n\napp.directive('validateCard', function () {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function (scope, elem, attrs, ctrl) {\n\n            ctrl.$parsers.unshift(function (viewValue) {\n\n                // Strip any whitespace\n                viewValue = utils.removeWhitespace(viewValue);\n\n                if (utils.isNullOrEmpty(viewValue)) {\n                    ctrl.$setValidity('card', false);\n                    return undefined;\n                }\n\n                if (/^\\d+$/.test(viewValue) == false) {\n                    ctrl.$setValidity('card', false);\n                    return undefined;\n                }\n\n                if (viewValue.length < 14) {\n                    ctrl.$setValidity('card', false);\n                    return undefined;\n                }\n\n                if (viewValue.length > 19) {\n                    ctrl.$setValidity('card', false);\n                    return undefined;\n                }\n\n                if (utils.luhnCheck(viewValue) == false) {\n                    ctrl.$setValidity('card', false);\n                    return undefined;\n                }\n\n                ctrl.$setValidity('card', true);\n                return viewValue;\n\n            });\n\n        }\n\n    };\n\n});\n\napp.directive('isValidInteger', function () {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function (scope, elem, attrs, ctrl) {\n\n            ctrl.$validators.characters = function (modelValue, viewValue) {\n                var value = modelValue || viewValue;\n                if (attrs.allowEmptyValue == \"true\" && (value == \"\" || value == null)) {\n                    return true;\n                }\n                if (utils.isValidInteger(value) == false) {\n                    return false;\n                }\n                if (attrs.max) {\n                    if (value > attrs.max) {\n                        return false;\n                    }\n                }\n                if (attrs.lessThan) {\n                    if (value >= attrs.lessThan) {\n                        return false;\n                    }\n                }\n                if (attrs.min) {\n                    if (value < attrs.min) {\n                        return false;\n                    }\n                }\n                if (attrs.greaterThan) {\n                    if (value <= attrs.greaterThan) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n        }\n    };\n});\n\napp.directive('isValidNumber', function () {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function (scope, elem, attrs, ctrl) {\n\n            ctrl.$validators.characters = function (modelValue, viewValue) {\n                var value = modelValue || viewValue;\n                if (attrs.allowEmptyValue == \"true\" && (value == \"\" || value == null)) {\n                    return true;\n                }\n                if (utils.isValidNumber(value) == false) {\n                    return false;\n                }\n                if (attrs.max) {\n                    if (value > attrs.max) {\n                        return false;\n                    }\n                }\n                if (attrs.lessThan) {\n                    if (value >= attrs.lessThan) {\n                        return false;\n                    }\n                }\n                if (attrs.min) {\n                    if (value < attrs.min) {\n                        return false;\n                    }\n                }\n                if (attrs.greaterThan) {\n                    if (value <= attrs.greaterThan) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n        }\n    };\n});\n\napp.directive('promoCode', ['CartService', '$timeout', function (CartService, $timeout) {\n\n    // Shared scope:\n    // cart: The cart to which the promo code should be applied\n    // onAdd: A function that will be called from scope when the currency is successfully changed. Will include the newly updated cart as a parameter.\n    // onRemove: A function that will be called from scope when the currency is successfully changed. Will include the newly updated cart as a parameter.\n    // onError: A function that will be called from scope when the currency change fails. Will include an error object as a parameter.\n    // error: The error object to communicate errors.\n\n    // Attributes\n    // params: Any parameters you want to pass to the update function (i.e. expand, show, etc.)\n\n    // An HTML template that shows the classes that should be applied to each component and state of the promotion code request\n    //<div class=\"col-xs-12 promo-code\" ng-cloak promo-code cart=\"data.cart\" error=\"data.error\">\n    //    <label class=\"ask-promo-code\">Enter Promo Code</label>\n    //    <div class=\"form-inline supply-promo-code\">\n    //        <input class=\"form-control\" type=\"text\" placeholder=\"{{ 'Enter Promo Code' | translate}}\">\n    //        <button type=\"submit\" class=\"btn btn-info apply-promo-code\">Apply</button>\n    //    </div>\n    //    <div class=\"applied-promo-code\">\n    //        <strong translate>Discount applied.</strong>&nbsp;&nbsp;<strong class=\"text-success\">{{data.cart.promotion_code}}</strong>&nbsp;&nbsp;&nbsp;&nbsp;<i class=\"fa fa-trash fa-lg pointer remove-promo-code\"></i>\n    //    </div>\n    //</div>\n\n    return {\n        restrict: 'A',\n        scope: {\n            cart: '=?',\n            params: '=?',\n            error: '=?',\n            onAdd: '=?',\n            onRemove: '=?',\n            onError: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            var label = angular.element(elem[0].querySelector('.ask-promo-code'));\n            var request = angular.element(elem[0].querySelector('.supply-promo-code'));\n            var applied = angular.element(elem[0].querySelector('.applied-promo-code'));\n            var input = angular.element(elem.find(\"input\"));\n            var button = angular.element(elem[0].querySelector('.apply-promo-code'));\n            var remove = angular.element(elem[0].querySelector('.remove-promo-code'));\n\n            // Set the state\n            request.addClass(\"hidden\");\n            applied.addClass(\"hidden\");\n\n            scope.$watch(\"cart\", function (newCart, oldCart) {\n                if (newCart) {\n                    if (newCart.promotion_code) {\n                        label.addClass(\"hidden\");\n                        applied.removeClass(\"hidden\");\n                    } else {\n                        applied.addClass(\"hidden\");\n                    }\n                }\n            });\n\n            label.bind(\"click\", function () {\n\n                label.addClass(\"hidden\");\n                request.removeClass(\"hidden\");\n\n                // Focus the input\n                $timeout(function () {\n                    elem.find(\"input\")[0].focus();\n                });\n\n            });\n\n            button.bind(\"click\", function () {\n\n                // Get the promo code\n                var promoCode = input.val();\n\n                if (utils.isNullOrEmpty(promoCode)) {\n                    return;\n                }\n\n                // Clear previous errors\n                scope.error = null;\n\n                // Build the request\n                var cart = { promotion_code: promoCode };\n\n                // Prep the params\n                var params = scope.params || attrs.params;\n                params = utils.mergeParams(params, null, null);\n\n                CartService.update(cart, scope.params).then(function (cart) {\n                    scope.cart = cart;\n\n                    // Fire the add event\n                    if (scope.onAdd) {\n                        scope.onAdd(cart);\n                    }\n\n                    // Hide the request form\n                    request.addClass(\"hidden\");\n\n                    // Show the applied field\n                    applied.removeClass(\"hidden\");\n\n                }, function (error) {\n\n                    scope.error = error;\n                    // Fire the error event\n                    if (scope.onError) {\n                        scope.onError(error);\n                    }\n\n                });\n\n            });\n\n            remove.bind(\"click\", function () {\n\n                // Reset the promo code\n                input.val(\"\");\n\n                // Clear previous errors\n                scope.error = null;\n\n                // Build the request\n                var cart = { promotion_code: null };\n\n                // Prep the params\n                var params = scope.params || attrs.params;\n                params = utils.mergeParams(params, null, null);\n\n                CartService.update(cart, scope.params).then(function (cart) {\n                    scope.cart = cart;\n\n                    // Fire the remove event\n                    if (scope.onRemove) {\n                        scope.onRemove(cart);\n                    }\n\n                    // Show the label\n                    label.removeClass(\"hidden\");\n\n                    // Hide the applied field\n                    applied.addClass(\"hidden\");\n\n                }, function (error) {\n                    scope.error = error;\n\n                    // Fire the error event\n                    if (scope.onError) {\n                        scope.onError(error);\n                    }\n\n                });\n\n            });\n\n            input.bind(\"blur\", function () {\n\n                // On blur, if no code is supplied, reset back to default\n                if (utils.isNullOrEmpty(input.val())) {\n                    request.addClass(\"hidden\");\n                    applied.addClass(\"hidden\");\n                    label.removeClass(\"hidden\");\n\n                    // Clear previous errors\n                    $timeout(function () {\n                        scope.error = null;\n                    });\n                }\n\n            });\n\n        }\n    };\n}]);\n\napp.directive('customerSignin', ['CartService', 'CustomerService', '$timeout', function (CartService, CustomerService, $timeout) {\n\n    // Shared scope:\n    // cart: The cart to which the login should be applied, if the login is associated with a cart\n    // customer: The customer object to which the login should be applied. Must be provided if a cart is not provided, if a cart is provided this is unnecessary and will not be used.\n    // paymentMethod: The cart's payment method object\n    // onSigninSubmit: A function that will be called when the signin is submitted.\n    // onSignoutSubmit: A function that will be called when the signout is submitted.\n    // onSigninSuccess: A function that will be called when the signin is successfully completed. Will include the cart as a parameter.\n    // onSignoutSuccess: A function that will be called when the signout is successfully completed. Will include the cart as a parameter.\n    // onSigninError: A function that will be called when the signin fails. Will include an error object as a parameter.\n    // onSignoutError: A function that will be called when the signout fails. Will include an error object as a parameter.\n    // error: The error object to communicate errors.\n    // options: The cart options that indicates if the login prompt should be shown or not.\n\n    // Attributes\n    // params: Any parameters you want to pass to the update function (i.e. expand, show, etc.)\n\n    // An HTML template that shows the classes that should be applied to each component and state of the signin\n    //<div customer-signin cart=\"data.cart\" payment-method=\"data.payment_method\" options=\"data.cart.options\" error=\"data.error\" params=\"params\">\n\n    //    <div class=\"well clearfix ask-signin\">\n    //        <strong><span translate>Have an account?</span></strong>\n    //        <strong><a class=\"pointer pull-right show-signin\" translate>Sign In</a></strong>\n    //    </div>\n\n    //    <div class=\"well clearfix supply-signin\">\n    //        <div class=\"col-xs-12 col-md-6\" id=\"un\">\n    //            <div class=\"form-group\">\n    //                <label class=\"control-label\" for=\"un\" translate>Username</label>\n    //                <input class=\"form-control signin-username\" name=\"un\" type=\"text\">\n    //            </div>\n    //        </div>\n\n    //        <div class=\"col-xs-12 col-md-6\" id=\"pw\">\n    //            <div class=\"form-group\">\n    //                <label class=\"control-label\" for=\"pw\" translate>Password</label>\n    //                <input class=\"form-control signin-password\" name=\"pw\" type=\"password\">\n    //            </div>\n    //        </div>\n\n    //        <div class=\"col-xs-12 text-right\">\n    //            <button class=\"btn btn-sm cancel-signin\" translate>Cancel</button>\n    //            <button type=\"submit\" class=\"btn btn-default btn-sm submit-signin\" customer-login cart=\"data.cart\" username=\"data.un\" password=\"data.pw\" error=\"data.error\" translate>Sign In</button>\n    //        </div>\n    //    </div>\n\n    //    <div class=\"well signed-in\">\n    //        <span>Signed in as {{data.cart.customer.username}}</span><strong><a class=\"pointer pull-right submit-signout\" customer-logout cart=\"data.cart\" error=\"data.error\" translate>Sign out</a></strong>\n    //    </div>\n\n    //</div>        \n\n\n    return {\n        restrict: 'A',\n        scope: {\n            cart: '=',\n            customer: '=',\n            paymentMethod: '=?',\n            options: '=?',\n            params: '=?',\n            error: '=?',\n            onSigninSubmit: '=?',\n            onSignoutSubmit: '=?',\n            onSigninSuccess: '=?',\n            onSignoutSuccess: '=?',\n            onSigninError: '=?',\n            onSignoutError: '=?'\n        },\n        link: function (scope, elem, attrs) {\n\n            var askSignin = angular.element(elem[0].querySelector('.ask-signin'));\n            var showSignin = angular.element(elem[0].querySelector('.show-signin'));\n            var supplySignin = angular.element(elem[0].querySelector('.supply-signin'));\n            var username = angular.element(elem[0].querySelector('.signin-username'));\n            var password = angular.element(elem[0].querySelector('.signin-password'));\n            var submit = angular.element(elem[0].querySelector('.submit-signin'));\n            var cancel = angular.element(elem[0].querySelector('.cancel-signin'));\n            var signedIn = angular.element(elem[0].querySelector('.signed-in'));\n            var signOut = angular.element(elem[0].querySelector('.submit-signout'));\n\n            var hideAll = function () {\n                askSignin.addClass(\"hidden\");\n                supplySignin.addClass(\"hidden\");\n                signedIn.addClass(\"hidden\");\n            };\n\n            // Set the default state\n            elem.addClass(\"hidden\");\n            hideAll();\n\n            scope.$watchGroup([\"options\", \"cart\", \"customer\"], function (newValues, oldValues) {\n\n                var options = newValues[0];\n                var cart = newValues[1];\n                var customer = newValues[2];\n\n                if (options) {\n                    if (options.customer_optional_fields) {\n                        if (options.customer_optional_fields.indexOf(\"username\") >= 0) {\n                            hideAll();\n                            elem.removeClass(\"hidden\");\n                            askSignin.removeClass(\"hidden\");\n                        }\n                    }\n                }\n\n                if (cart) {\n                    if (cart.customer) {\n                        hideAll();\n                        if (cart.customer.username) {\n                            signedIn.removeClass(\"hidden\");\n                        } else {\n                            askSignin.removeClass(\"hidden\");\n                        }\n                    }\n                }\n\n                if (customer) {\n                    hideAll();\n                    if (customer.username) {\n                        signedIn.removeClass(\"hidden\");\n                    } else {\n                        askSignin.removeClass(\"hidden\");\n                    }\n                }\n\n            }, true);\n\n            showSignin.bind(\"click\", function () {\n\n                askSignin.addClass(\"hidden\");\n                supplySignin.removeClass(\"hidden\");\n\n                // Focus the input\n                $timeout(function () {\n                    elem.find(\"input\")[0].focus();\n                });\n\n            });\n\n            // Bind to the password enter event\n            password.bind(\"keydown\", function (event) {\n                if (event.which == 13) {\n                    submitForm();\n                }\n            });\n\n            // Bind to the username enter event\n            username.bind(\"keydown\", function (event) {\n                if (event.which == 13) {\n                    submitForm();\n                }\n            });\n\n            // Bind to the submit button click          \n            submit.bind(\"click\", function (event) {\n                submitForm();\n            });\n\n            signOut.bind(\"click\", function () {\n\n                // Fire the event\n                if (scope.onSignoutSubmit) {\n                    scope.onSignoutSubmit();\n                }\n\n                // If associated with a cart, log the customer out of the cart to disassociated the cart from the user.\n                if (scope.cart) {\n\n                    // Prep the params\n                    var params = scope.params || attrs.params;\n                    params = utils.mergeParams(params, null, \"customer.payment_methods\");\n\n                    CartService.logout(params).then(function (cart) {\n\n                        scope.cart = cart;\n\n                        // Delete the payment_method_id on the payment method object\n                        delete scope.paymentMethod.payment_method_id;\n\n                        // Fire the success event\n                        if (scope.onSignoutSuccess) {\n                            scope.onSignoutSuccess(cart);\n                        }\n\n                    }, function (error) {\n\n                        scope.error = error;\n                        // Fire the error event\n                        if (scope.onSignoutError) {\n                            scope.onSignoutError(error);\n                        }\n\n                    });\n\n                } else {\n\n                    // Not associated with a cart\n                    if (scope.customer) {\n\n                        scope.$apply(function () {\n\n                            // Reset the customer to empty. Set country explicitly to null otherwise you end up with an option 'undefined' in country HTML select controls.\n                            scope.customer = { billing_address: { country: null }, shipping_address: { country: null } };\n\n                            // Delete the payment_method_id on the payment method object\n                            delete scope.paymentMethod.payment_method_id;\n                        });\n\n                        // Fire the success event\n                        if (scope.onSignoutSuccess) {\n                            scope.onSignoutSuccess();\n                        }\n                    }\n\n                }\n\n            });\n\n            cancel.bind(\"click\", function () {\n\n                // Reset the username and password\n                username.val(\"\");\n                password.val(\"\");\n\n                // Clear previous errors\n                scope.error = null;\n\n                // Reset back to login prompt.\n                hideAll();\n                askSignin.removeClass(\"hidden\");\n\n            });\n\n            var submitForm = function () {\n\n                // Get the login values\n                var un = username.val();\n                var pw = password.val();\n\n                if (utils.isNullOrEmpty(un) || utils.isNullOrEmpty(pw)) {\n                    return;\n                }\n\n                // Clear previous errors\n                scope.error = null;\n\n                // Fire the event\n                if (scope.onSigninSubmit) {\n                    scope.onSigninSubmit();\n                }\n\n                // Build the login object\n                var login = { username: un, password: pw };\n\n                // If a cart is provided, log the user into the cart.\n                if (scope.cart) {\n\n                    // Prep the params\n                    var params = scope.params || attrs.params;\n                    params = utils.mergeParams(params, null, \"customer.payment_methods\");\n\n                    CartService.login(login, params).then(function (cart) {\n\n                        scope.cart = cart;\n\n                        // Remove the username and password\n                        username.val(\"\");\n                        password.val(\"\");\n\n                        // If the customer has payment methods and the payment method object is supplied, assign the default payment method id\n                        if (cart.customer.payment_methods.data.length > 0 && scope.paymentMethod) {\n                            var payment_method_id = _.findWhere(cart.customer.payment_methods.data, { is_default: true }).payment_method_id;\n                            scope.paymentMethod = { payment_method_id: payment_method_id };\n                        }\n\n                        // Fire the success event\n                        if (scope.onSigninSuccess) {\n                            scope.onSigninSuccess(cart);\n                        }\n\n                    }, function (error) {\n\n                        scope.error = error;\n                        // Fire the error event\n                        if (scope.onSigninError) {\n                            scope.onSigninError(error);\n                        }\n\n                    });\n\n                } else {\n\n                    // Otherwise, log the customer in directly.\n\n                    // Prep the params\n                    var params = scope.params || attrs.params;\n                    params = utils.mergeParams(params, null, \"payment_methods\");\n\n                    CustomerService.login(login, params).then(function (customer) {\n\n                        // Update the customer object with the returned customer.\n                        scope.customer = customer;\n\n                        // Remove the username and password\n                        username.val(\"\");\n                        password.val(\"\");\n\n                        // If the customer has payment methods and the payment method object is supplied, assign the default payment method id\n                        if (customer.payment_methods.data.length > 0 && scope.paymentMethod) {\n                            var payment_method_id = _.findWhere(customer.payment_methods.data, { is_default: true }).payment_method_id;\n                            scope.paymentMethod = { payment_method_id: payment_method_id };\n                        }\n\n                        // Fire the success event\n                        if (scope.onSigninSuccess) {\n                            scope.onSigninSuccess(customer);\n                        }\n\n                    }, function (error) {\n\n                        scope.error = error;\n                        // Fire the error event\n                        if (scope.onSigninError) {\n                            scope.onSigninError(error);\n                        }\n\n                    });\n\n                }\n\n            };\n\n        }\n    };\n}]);\n\napp.directive('createAccount', ['CustomerService', '$timeout', function (CustomerService, $timeout) {\n\n    // Shared scope:\n    // customer: The customer for which an account will be created. Must include the customer_id.\n    // onSubmit: A function that will be called when the signin is submitted.\n    // onSuccess: A function that will be called when the signin is successfully completed. Will include the cart as a parameter.\n    // onError: A function that will be called when the signout fails. Will include an error object as a parameter.\n    // error: The error object to communicate errors.\n    // options: The cart options that indicates if the create account prompt should be shown or not.\n\n    // Attributes\n    // params: Any parameters you want to pass to the update function (i.e. expand, show, etc.)\n\n    // An HTML template that shows the classes that should be applied to each component and state of the signin\n    //<div customer-signin cart=\"data.cart\" payment-method=\"data.payment_method\" options=\"data.cart.options\" error=\"data.error\" params=\"params\">\n\n    //    <div class=\"well clearfix ask-signin\">\n    //        <strong><span translate>Have an account?</span></strong>\n    //        <strong><a class=\"pointer pull-right show-signin\" translate>Sign In</a></strong>\n    //    </div>\n\n    //    <div class=\"well clearfix create-account\">\n    //        <div class=\"col-xs-12 col-md-6\" id=\"un\">\n    //            <div class=\"form-group\">\n    //                <label class=\"control-label\" for=\"un\" translate>Username</label>\n    //                <input class=\"form-control signin-username\" name=\"un\" type=\"text\">\n    //            </div>\n    //        </div>\n\n    //        <div class=\"col-xs-12 col-md-6\" id=\"pw\">\n    //            <div class=\"form-group\">\n    //                <label class=\"control-label\" for=\"pw\" translate>Password</label>\n    //                <input class=\"form-control signin-password\" name=\"pw\" type=\"password\">\n    //            </div>\n    //        </div>\n\n    //        <div class=\"col-xs-12 text-right\">\n    //            <button class=\"btn btn-sm cancel-signin\" translate>Cancel</button>\n    //            <button type=\"submit\" class=\"btn btn-default btn-sm submit-signin\" customer-login cart=\"data.cart\" username=\"data.un\" password=\"data.pw\" error=\"data.error\" translate>Sign In</button>\n    //        </div>\n    //    </div>\n\n    //    <div class=\"well signed-in\">\n    //        <span>Signed in as {{data.cart.customer.username}}</span><strong><a class=\"pointer pull-right submit-signout\" customer-logout cart=\"data.cart\" error=\"data.error\" translate>Sign out</a></strong>\n    //    </div>\n\n    //</div>        \n\n\n    return {\n        restrict: 'A',\n        scope: {\n            customer: '=',\n            options: '=?',\n            params: '=?',\n            error: '=?',\n            onSubmit: '=?',\n            onSuccess: '=?',\n            onError: '=?'\n        },\n        link: function (scope, elem, attrs) {\n\n            var supplyCredentials = angular.element(elem[0].querySelector('.supply-credentials'));\n            var username = angular.element(elem[0].querySelector('.create-account-username'));\n            var password = angular.element(elem[0].querySelector('.create-account-password'));\n            var submit = angular.element(elem[0].querySelector('.submit-create-account'));\n            var accountCreated = angular.element(elem[0].querySelector('.account-created'));\n\n            // Set the default state\n            elem.addClass(\"hidden\");\n            accountCreated.addClass(\"hidden\");\n\n            scope.$watchGroup([\"options\", \"customer\"], function (newValues, oldValues) {\n\n                var options = newValues[0];\n                var customer = newValues[1];\n\n                // When both the options and customer come through, look to see if the field is set in the options and that a customer username is not already set.\n                if (options && customer) {\n                    if (options.customer_optional_fields) {\n                        if (options.customer_optional_fields.indexOf(\"username\") >= 0 && !customer.username) {\n                            // Show the form.\n                            elem.removeClass(\"hidden\");\n                        }\n                    }\n                }\n            });\n\n            // Bind to the password enter event\n            password.bind(\"keydown\", function (event) {\n                if (event.which == 13) {\n                    submitForm();\n                }\n            });\n\n            // Bind to the username enter event\n            username.bind(\"keydown\", function (event) {\n                if (event.which == 13) {\n                    submitForm();\n                }\n            });\n\n            // Bind to the submit button click          \n            submit.bind(\"click\", function (event) {\n                submitForm();\n            });\n\n            var submitForm = function () {\n\n                // Get the login values\n                var un = username.val();\n                var pw = password.val();\n\n                if (utils.isNullOrEmpty(un) || utils.isNullOrEmpty(pw)) {\n                    return;\n                }\n\n                // Clear previous errors\n                scope.error = null;\n\n                // Fire the event\n                if (scope.onSubmit) {\n                    scope.onSubmit();\n                }\n\n                // Build the login object\n                scope.customer.username = un;\n                scope.customer.password = pw;\n\n                // Prep the params\n                var params = scope.params || attrs.params;\n                params = utils.mergeParams(params, null, \"customer.payment_methods\");\n\n                CustomerService.createAccount(scope.customer, scope.params).then(function (customer) {\n\n                    scope.customer = customer;\n\n                    // Remove the username and password\n                    username.val(\"\");\n                    password.val(\"\");\n\n                    // Show the success message\n                    accountCreated.removeClass(\"hidden\");\n\n                    // Hide the login form\n                    supplyCredentials.addClass(\"hidden\");\n\n                    // Fire the success event\n                    if (scope.onSuccess) {\n                        scope.onSuccess(customer);\n                    }\n\n                }, function (error) {\n\n                    scope.error = error;\n                    // Fire the error event\n                    if (scope.onError) {\n                        scope.onError(error);\n                    }\n\n                });\n            };\n        }\n    };\n}]);\n\napp.directive('selectStateProv', ['GeoService', '$timeout', function (GeoService, $timeout) {\n\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function (scope, elem, attrs, ctrl) {\n\n            scope.$watch(attrs.country, function (country, oldCountry) {\n\n                if (country) {\n                    var statesProvs = GeoService.getStatesProvs(country);\n\n                    var elemNg = angular.element(elem[0]);\n\n                    // Reset the existing options. If the value is empty, leave in place, this is the \"blank\" option in the list.\n                    var hasEmpty = false;\n                    for (var i = elemNg[0].options.length - 1; i >= 0; i--) {\n                        if (elemNg[0].options[i].value) {\n                            elemNg[0].remove(i);\n                        } else {\n                            hasEmpty = true;\n                        }\n                    }\n\n                    // If it doesn't have an empty value, add it.\n                    if (!hasEmpty) {\n                        elemNg[0].appendChild(document.createElement(\"option\"));\n                    }\n\n                    var value = ctrl.$viewValue || ctrl.$modelValue;\n                    var hasSelected = false;\n\n                    _.each(statesProvs, function (stateProv) {\n                        var option = '<option class=\"select-options-color\" value=\"' + stateProv.code + '\"';\n                        if (value == stateProv.code) {\n                            option += \" selected\";\n                            hasSelected = true;\n                        }\n                        option += '>' + stateProv.name + '</option>';\n                        elemNg.append(option);\n                    });\n\n                    // If not item was selected, then there was no match. If the control currently has a value for state, reset it.\n                    if (hasSelected == false) {\n                        ctrl.$setViewValue(null);\n                    }\n                }\n            });\n        }\n    };\n}]);\n\napp.directive('customerBackgroundSave', ['CartService', '$timeout', function (CartService, $timeout) {\n\n    // Shared scope:\n    // cart: The updated cart to save. If an existing cart does not exist, one will be created and returned.\n    // error: The error object to communicate errors.\n    // onSuccess: A function that will be called from scope when the save is successfully completed. Includes the cart as a parameter.\n\n    // Attributes\n    // params: An object that supplies a list of parameters to send to the api, such as show, hide, formatted, etc. Used to customize the response object.\n    // quiet: true / false to indicate if the loading bar should be displayed while calling the API. Default is false.\n\n    return {\n        restrict: 'A',\n        scope: {\n            cart: '=customerBackgroundSave',\n            shippingIsBilling: '=?',\n            params: '=?',\n            error: '=?',\n            onSuccess: '=?',\n    },\n        link: function (scope, elem, attrs, ctrl) {\n\n            // Find all inputs that have the attribute of customer-field\n            var fields = document.querySelectorAll(\".customer-background-save\");\n\n            // Only allow one update buffer per page.\n            var updateBuffer;\n\n            _.each(fields, function (input) {\n\n                // Bind on blur as the default, on change for select.\n                var event = \"blur\";\n                if (input.nodeName == \"SELECT\") {\n                    event = \"change\";\n                }\n                if (input.type == \"checkbox\") {\n                    event = \"click\";\n                }\n\n                var inputNg = angular.element(input);\n\n                // Track original value because blur events don't care if value has changed.\n                var originalVal = inputNg.val();\n\n                inputNg.bind(event, function () {\n                    // Ensure that value has really changed, triggering on blur event makes this needed.\n                    if (event == 'blur' && angular.equals(originalVal,inputNg.val())) return;\n                    // Reset original value so we can track later changes by user.\n                    originalVal = inputNg.val();\n\n                    if (updateBuffer) {\n                        $timeout.cancel(updateBuffer);\n                    }\n\n                    // Wrap in timeout and apply a buffer so that if a form fill agent is used you only perform one update at the end. The buffer is 25 ms, which seems to accomplish the job.\n                    updateBuffer = $timeout(function () {\n\n                        // Since this is a \"background update\", we need special handling. Angular converts required fields to undefined when they are zero-length, which means they are stripped from the api payload.\n                        // This means that if a user sets an item to blank, it will re-populate itself on update because the API didn't see it and didn't know to null it. We'll set all undefined items to null.\n                        var cartCopy = angular.copy(scope.cart);\n                        utils.undefinedToNull(cartCopy);\n\n                        // Prep the params\n                        var params = scope.params || attrs.params;\n                        params = utils.mergeParams(params, null, null);\n\n                        if (scope.cart) {\n\n                            // Use the ngModel attribute to get the property name\n                            var property = input.getAttribute(\"ng-model\");\n\n                            if (property) {\n\n                                // Strip everything before customer.\n                                property = property.split(\"customer.\")[1];\n\n                                scope.cart.customer[property] = inputNg.val();\n\n                                // If set that billing is same as shipping, set all shipping values to null so that the API doesn't receive any of the data set on the view.\n                                if (scope.shippingIsBilling) {\n                                    if (cartCopy.customer.shipping_address) {\n                                        cartCopy.customer.shipping_address.name = null;\n                                        cartCopy.customer.shipping_address.address_1 = null;\n                                        cartCopy.customer.shipping_address.address_2 = null;\n                                        cartCopy.customer.shipping_address.city = null;\n                                        cartCopy.customer.shipping_address.state_prov = null;\n                                        cartCopy.customer.shipping_address.postal_code = null;\n                                        cartCopy.customer.shipping_address.country = null;\n                                    }\n                                }\n\n                                CartService.update(cartCopy, scope.params, true).then(function (cart) {\n\n                                    // In the event that there were changes to the view between the time the call was sent and returned, we don't want to overwrite them. As a result, we won't sync the server customer values with the model.\n                                    if (scope.cart) {\n                                        cart.customer = scope.cart.customer;\n                                    }\n\n                                    // Sync the scope to the response.\n                                    scope.cart = cart;\n\n                                    // Fire the success event\n                                    if (scope.onSuccess) {\n                                        scope.onSuccess(cart);\n                                    }\n\n                                }, function (error) {\n                                    scope.error = error;\n                                });\n                            }\n                        }\n                    }, 25); // Timeout set to a value that prevents sending every value if user presses and holds down arrow on country select.\n                });\n            });\n\n        }\n    };\n}]);\n\napp.directive('creditCardImage', [function () {\n\n    return {\n        restrict: 'A',\n        link: function (scope, elem, attrs) {\n\n            scope.$watch(attrs.creditCardImage, function (creditCardImage) {\n\n                var path = \"images/\";\n                if (attrs.path) {\n                    path = attrs.path;\n                }\n\n                if (creditCardImage) {\n                    var filename = creditCardImage.replace(\" \", \"\").toLowerCase() + \".png\";\n                    var image = '<img src=\"' + path + filename + '\" />';\n                    var elemNg = angular.element(elem);\n                    elemNg.empty();\n                    elemNg.html(image);\n                }\n\n            });\n        }\n    };\n}]);\n\napp.directive('creditCards', ['CartService', function (CartService) {\n    return {\n        restrict: 'A',\n        link: function (scope, elem, attrs) {\n\n            var path = \"images/\";\n            if (attrs.path) {\n                path = attrs.path;\n            }\n\n            scope.$watch(attrs.creditCards, function (newVal) {\n                if (_.isArray(newVal)) {\n                    var images = \"\";\n                    _.each(newVal, function (item) {\n                        var filename = item.replace(\" \", \"\").toLowerCase() + \".png\";\n                        images += '<img src=\"' + path + filename + '\" title=\"' + item + '\" />';\n                    });\n\n                    var elemNg = angular.element(elem);\n                    elemNg.empty();\n                    elemNg.html(images);\n                }\n            });\n\n        }\n    };\n}]);\n\napp.directive('stateProvInput', ['GeoService', '$compile', function (GeoService, $compile) {\n\n    return {\n        restrict: 'E',\n        terminal: true,\n        link: function (scope, elem, attrs) {\n\n            attrs.$observe('country', function (country) {\n\n                if (country) {\n\n                    var statesProvs = GeoService.getStatesProvs(attrs.country);\n\n                    if (attrs.type == \"select\") {\n\n                        // The select element is the template\n                        var template = elem[0].querySelector(\"select\").outerHTML;\n\n                        if (statesProvs == null) {\n\n                            // Remove ngModel\n                            template = template.replace(\"ng-model\", \"suspend-model\");\n                            var templateEl = angular.element(template);\n                            elem.empty();\n                            elem.append(templateEl);\n                            $compile(templateEl)(scope);\n\n                        } else {\n\n                            // Add ngModel\n                            template = template.replace(\"suspend-model\", \"ng-model\");\n                            var templateEl = angular.element(template);\n                            elem.empty();\n                            elem.append(templateEl);\n                            $compile(templateEl)(scope);\n\n                        }\n\n                    }\n\n                    if (attrs.type == \"input\") {\n\n                        // The select element is the template\n                        var template = elem[0].querySelector(\"input\").outerHTML;\n\n                        if (statesProvs != null) {\n\n                            // Remove ngModel\n                            template = template.replace(\"ng-model\", \"suspend-model\");\n                            var templateEl = angular.element(template);\n                            elem.empty();\n                            elem.append(templateEl);\n                            $compile(templateEl)(scope);\n\n                        } else {\n\n                            // Add ngModel\n                            template = template.replace(\"suspend-model\", \"ng-model\");\n                            var templateEl = angular.element(template);\n                            elem.empty();\n                            elem.append(templateEl);\n                            $compile(templateEl)(scope);\n\n                        }\n\n                    }\n\n                }\n            });\n\n        }\n    };\n\n}]);\n\napp.directive('selectOnClick', function () {\n    return {\n        restrict: 'A',\n        link: function (scope, elem, attrs) {\n            elem.on('click', function () {\n                this.select();\n            });\n        }\n    };\n});\n\napp.directive('fields', ['CartService', 'InvoiceService', '$timeout', '$rootScope', 'LanguageService', function (CartService, InvoiceService, $timeout, $rootScope, LanguageService) {\n\n    return {\n        restrict: 'AE',\n        templateUrl: \"app/templates/fields.html\",\n        scope: {\n            fieldlist: '=',\n            sale: '=',\n            appSettings: '=',\n            appStyle: '='\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            // Shared scope:\n            // fieldlist: The list of field configurations\n            // sale: The cart or invoice\n            // appSettings: The app settings as delivered through settings/app.js (or .json)\n            // appStyle: The app style as delivered through settings/style.js (or .json)\n\n            // The fieldlist will be supplied as a JSON string that must be parsed into an object.\n            scope.fields = [];\n\n            var loadFields = function (fieldsJson) {\n\n                // If the fields are a string, parse to an object.\n                var fields = [];\n\n                if (typeof fieldsJson == \"string\" && utils.isNullOrEmpty(fieldsJson) == false) {\n                    // Make sure you have valid JSON\n                    try {\n                        fields = JSON.parse(fieldsJson);\n                    } catch (e) {\n                        // Set to an empty array if not.\n                        fields = [];\n                        // Log to help in debugging\n                        console.log(\"The JSON provided for custom fields is not valid JSON. As a result, no custom fields will display. Error message: \" + e);\n                    }\n                }\n\n                // Group by section.\n                fields = groupFields(fields);\n\n                // If the user's language is provided in any of the fields, use that language.\n                var language = LanguageService.getSelectedLanguage().code;\n\n                _.each(fields, function (field) {\n\n                    if (field.languages) {\n                        if (field.languages[language]) {\n\n                            if (field.languages[language].label) {\n                                field.label = field.languages[language].label;\n                            }\n\n                            if (field.languages[language].description) {\n                                field.description = field.languages[language].description;\n                            }\n\n                            if (field.languages[language].section) {\n                                field.section = field.languages[language].section;\n                            }\n\n                            if (field.languages[language].options) {\n                                field.options = field.languages[language].options;\n                            }\n\n                        }\n                    }\n\n                });\n\n                return fields;\n\n            };\n\n            var groupFields = function (fields) {\n\n                // Group the objects together by section\n                var sorted = [];\n                var processed = [];\n                _.each(fields, function (item) {\n\n                    if (processed.indexOf(item.section) == -1) {\n                        var matches = _.where(fields, { section: item.section });\n\n                        if (matches) {\n                            sorted = sorted.concat(matches);\n                            processed.push(item.section);\n                        }\n                    }\n\n                });\n\n                return sorted;\n            };\n\n            var loadDefaults = function (fields, meta) {\n\n                // Loop through the fields and set the default values if a value is not already provided.\n                for (var property in fields) {\n\n                    // Set default values for any selections that don't already have a value.\n                    if (fields.hasOwnProperty(property)) {\n                        if (scope.sale.meta[fields[property].name] == null) {\n                            scope.sale.meta[fields[property].name] = fields[property].default_value;\n                        }\n                    }\n\n                }\n\n            };\n\n            // Load the fields.           \n            scope.fields = loadFields(scope.fieldlist);\n\n            // On the first time the sale is loaded, loop through the fields and set default vaules for items that don't already have a value.\n            var cancelWatch = scope.$watch('sale.meta', function (newVal, oldValue) {\n\n                // If the sale isn't populated yet, return.\n                if (scope.sale == null) {\n                    return;\n                }\n\n                // If the current selections are null, set to an empty object.\n                if (scope.sale.meta == null) {\n                    scope.sale.meta = {};\n                }\n\n                loadDefaults(scope.fields, scope.sale.meta);\n\n                // With the initial load done, we can cancel the watcher.\n                cancelWatch();\n\n            }, true);\n\n            // If the language changes, reload the fields, which will update the display language.\n            $rootScope.$on(\"languageChanged\", function (event, language) {\n                scope.fields = loadFields(scope.fieldlist);\n            });\n\n            scope.pushToProperty = function (property, value, recordOnChange) {\n\n                // If it doesn't exist, add it. If it exists, remove it.\n                if (scope.isInProperty(property, value) == false) {\n                    if (scope.sale.meta[property] == null) {\n                        scope.sale.meta[property] = [];\n                        scope.sale.meta[property].push(value);\n                    } else {\n                        scope.sale.meta[property].push(value);\n                    }\n                } else {\n                    scope.sale.meta[property] = _.without(scope.sale.meta[property], value);\n                }\n\n                // If record, save the change\n                if (recordOnChange) {\n                    scope.record();\n                }\n\n            };\n\n            scope.isInProperty = function (property, value) {\n\n                if (scope.sale == null) {\n                    return false;\n                }\n\n                if (scope.sale.meta == null) {\n                    return false;\n                }\n\n                if (scope.sale.meta[property] != null) {\n                    if (_.indexOf(scope.sale.meta[property], value) >= 0) {\n                        return true;\n                    }\n                }\n\n                return false;\n\n            };\n\n            scope.isNewSection = function (field, index) {\n\n                // The fields come from the api grouped in sections which makes it easy to determine when sections have changed.\n\n                // The first item is always \"new\"\n                if (index == 0) {\n                    return true;\n                }\n\n                // Otherwise, select the item immediately before this item and see if it's different\n                var previous = scope.fields[index - 1];\n                if (previous != null) {\n                    if (previous.section != field.section) {\n                        return true;\n                    }\n                }\n\n                return false;\n\n            };\n\n            // Save any changes, as requested.\n            scope.record = function () {\n                // We'll only update the meta\n                var sale = { meta: scope.sale.meta };\n                if (scope.sale.object == \"invoice\") {\n                    InvoiceService.update(sale);\n                } else {\n                    CartService.update(sale);\n                }\n            };\n\n        }\n    };\n\n}]);\n\napp.directive('validateField', ['gettextCatalog', '$timeout', function (gettextCatalog, $timeout) {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        scope: {\n            field: '=validateField',\n            error: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            var error = scope.error;\n            var field = scope.field;\n\n            // If required, initialize the error with a required error message.\n            if (utils.isNullOrEmpty(elem[0].value) && field.required == true) {\n                scope.error = gettextCatalog.getString(\"Please provide a value\");\n            }\n\n            // Use a different message for boolean or toggle.\n            if (field.type == \"boolean\" && field.required == true) {\n                scope.error = gettextCatalog.getString(\"Please make a selection\");\n            }\n\n            // A toggle field with required == true means a checkbox that you must check (i.e. accept terms and conditions or something, not allowed to leave it unchecked)\n            if (field.type == \"toggle\" && field.required == true) {\n                scope.error = gettextCatalog.getString(\"Please confirm\");\n            }\n\n            ctrl.$parsers.unshift(function (viewValue) {\n\n                // Reset the error\n                var errorMsg = null;\n\n                // Do some additinal testing for decimals and numbers.\n                if (viewValue != null || field.required == true) {\n\n                    switch (field.type) {\n\n                        case \"integer\":\n\n                            if (!utils.isValidInteger(viewValue)) {\n                                errorMsg = gettextCatalog.getString(\"Please supply a number without decimals\");\n                            }\n                            break;\n\n                        case \"decimal\":\n\n                            if (!utils.isValidNumber(viewValue)) {\n                                errorMsg = gettextCatalog.getString(\"Please supply a number\");\n                            }\n                            break;\n\n                    }\n\n                    // Regardless of the above, if options is not null, change the text\n                    if (field.options != null && utils.isNullOrEmpty(viewValue)) {\n                        errorMsg = gettextCatalog.getString(\"Please make a selection\");\n                    }\n\n                    // If no error, check restraints\n                    if (errorMsg == null) {\n\n                        // If a list of options are provided, ensure the provided value is within the range.\n                        if (field.options != null) {\n                            if (_.where(field.options, { value: viewValue }) == null) {\n                                errorMsg = gettextCatalog.getString(\"Please provide one of the available options\");\n                            }\n                        }\n\n                        // Range check if a integer or decimal\n                        if (field.type == \"integer\" || field.type == \"decimal\") {\n\n                            if (field.min_value) {\n                                if (viewValue < field.min_value) {\n                                    errorMsg = gettextCatalog.getPlural(field.min_value, \"The value you provide must be greater than {{$count}}\", \"The value you provide must be greater than {{$count}}\", {});\n                                }\n                            }\n\n                            if (field.max_value) {\n                                if (viewValue > field.max_value) {\n                                    errorMsg = gettextCatalog.getPlural(field.max_value, \"The value you provide must be less than {{$count}}\", \"The value you provide must be less than {{$count}}\", {});\n                                }\n                            }\n\n                        }\n\n                        // Size check if string or text\n                        if (field.type == \"string\" || field.type == \"text\") {\n\n                            if (field.min_length) {\n                                if (viewValue.length < field.min_length) {\n                                    errorMsg = gettextCatalog.getPlural(field.min_length, \"The value must be at least one character\", \"The value must be at least {{$count}} characters\", {});\n                                }\n                            }\n\n                            if (field.max_length) {\n                                if (viewValue.length > field.max_length) {\n                                    errorMsg = gettextCatalog.getPlural(field.max_length, \"The value must be less than one character\", \"The value must be less than {{$count}} characters\", {});\n                                }\n                            }\n                        }\n\n                    }\n                }\n\n                if (errorMsg != null) {\n                    ctrl.$setValidity('field', false);\n                    scope.error = errorMsg;\n                    return undefined;\n                }\n\n                ctrl.$setValidity('field', true);\n                return viewValue;\n\n            });\n        }\n    };\n}]);\n\napp.directive('cleanPrice', [function () {\n    return {\n        restrict: 'A',\n        require: 'ngModel',\n        link: function (scope, elem, attrs, ctrl) {\n\n            var clean = function (value) {\n                if (angular.isUndefined(value)) {\n                    return;\n                }\n                var cleanedPrice = utils.cleanPrice(value);\n                if (cleanedPrice !== value) {\n                    ctrl.$setViewValue(cleanedPrice);\n                    ctrl.$render();\n                }\n                return cleanedPrice;\n            }\n\n            ctrl.$parsers.unshift(clean);\n            clean(scope[attrs.ngModel]);\n        }\n    };\n}]);\n\napp.directive('webPaymentRequestButton', ['ApiService', '$location', function (ApiService, $location) {\n\n    // Shared scope:\n    // payment_method_type:  Required. payment method type that we are working with.  Currently ApplePay, but can be expanded later for GooglePay, etc.\n    // options: Required. The cart, invoice, or payment options.\n    // onPaymentSuccess: Optional. Runs this method when payment is successful.\n    var payClicked = function(scope) {\n        var payOption = scope.options.payment_methods.filter(function(option) {return option.payment_method_type == scope.paymentMethodType;});\n        if (!payOption || payOption.length <= 0) return;\n        var payMethod = payOption[0].user_agent_payment_request;\n        if (!payMethod || Object.keys(payMethod).length <= 0) return;\n\n        var paymentRequest = new PaymentRequest(payMethod.methodData, payMethod.details, payMethod.paymentOptions);\n\n        if (payMethod.merchant_validation_url) {\n          paymentRequest.onmerchantvalidation = function(event) {\n            event.complete(new Promise(function(resolve, reject) {\n              var validation_url = payMethod.merchant_validation_url;\n              var payload = {validation_url: event.validationURL, initiative_context: $location.host()};\n              ApiService.update(payload, validation_url)\n                  .then(function(response) {\n                    resolve(response.data.data);\n                  }, function(error) {\n                    paymentRequest.abort();\n                  });\n            }));\n          };\n        }\n\n        paymentRequest.onshippingaddresschange = function(event) {\n          event.updateWith(new Promise(function(resolve, reject) {\n            var payload = {shippingAddress: paymentRequest.shippingAddress};\n            var update_url = payMethod.url;\n\n            ApiService.update(payload, update_url).then(\n              function(response) {\n                resolve(response.data.details);\n              },\n              function(error) {\n                reject(error);\n              }\n            );\n          }));\n        };\n\n        paymentRequest.onshippingoptionchange = function(event) {\n          event.updateWith(new Promise(function(resolve, reject) {\n            if (!paymentRequest.shippingOption) {\n              resolve(payMethod.details);\n              return;\n            }\n\n            var payload = {shippingOption: paymentRequest.shippingOption};\n\n            var update_url = payMethod.url;\n\n            ApiService.update(payload, update_url).then(\n              function(response) {\n                resolve(response.data.details);\n              },\n              function(error) {\n                reject(error);\n              }\n            );\n\n          }));\n        };\n\n        if (payMethod.methodData.length > 1) {\n          paymentRequest.onpaymentmethodchange = function(event) {\n            event.updateWith(\n              new Promise(function(resolve,reject) {\n                resolve(payMethod.details);\n              })\n            );\n          };\n        }\n\n        // This starts the payment sheet(s).\n        paymentRequest.show().then(function(response) {\n            var payment_url = payMethod.payment_url;\n\n            var payment_payload = {\n              \"payment_method\": {\n                \"type\": scope.paymentMethodType,\n                \"data\": {\n                  \"initiative_context\": $location.host(),\n                  \"details\": response.details\n                }\n              }\n            };\n\n            ApiService.update(payment_payload, payment_url)\n            .then(function(result) {\n                var payment = result.data;\n                var status = payment && (payment.status == \"completed\" || payment.status == \"pending\") ? \"success\" : \"fail\";\n                response.complete(status);\n                if (status == \"success\" && angular.isFunction(scope.onPaymentSuccess)) {\n                    scope.onPaymentSuccess(payment);\n                }\n            }, function(result) {\n              response.complete(\"fail\");\n            });\n\n        }, function() {});\n    };\n\n    return {\n        restrict: 'A',\n        scope: {\n            paymentMethodType: '=',\n            options: '=',\n            onPaymentSuccess: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n            elem[0].addEventListener(\"click\", function() { return payClicked(scope) } );\n        }\n    };\n}]);\n\napp.directive('amazonPayButton', ['gettextCatalog', function (gettextCatalog) {\n\n    // Shared scope:\n    // paymentMethod: Provide the payment method object that will hold the Amazon Pay settings that are returned from the Amazon Pay button and widgets.\n    // options: The cart, invoice or payment options, from which the Amazon Pay client and seller settings will be obtained.\n    // items: The cart or invoice items, if applicable, to determine if the order contains subscription products and a billing agreemement should be established for the customer.\n    // onLoaded: A function that will be called when the Amazon Pay button has been loaded.\n    // onAddressSelect: A function that will be called when the customer selects an address from their Amazon Pay address book.\n    // onPaymentMethodSelect: A function that will be called when the customer selects a payment method from their Amazon Pay wallet.\n    // onConsentChange: A function that will be called when the user toggles the Amazon Pay consent checkbox. Returns the status of the consent checkbox as a parameter.\n    // getConsentStatus: A function that is set by the directive and can be called to get the status of the Amazon Pay consent checkbox.\n    // error: The error object to communicate errors.\n    // onError: A function that will be called from scope when the payment fails. Will include the (failed) response payment object as a parameter.\n\n    // Attributes\n    // params: An object that supplies a list of parameters to send to the api, such as show, hide, formatted, etc. Used to customize the response object.\n    // amazonPayAddressId: The ID of the HTML element that will hold the Amazon Pay address widget\n    // amazonPayWalletId: The ID of the HTML element that will hold the Amazon Pay wallet widget\n    // amazonPayConsentId: The ID of the HTML element that will hold the Amazon Pay consent widget (used when the payment method will be stored)\n    // amazonPayDesignMode: Provides the Amazon Pay design mode, the only current value seems to be \"responsive\". If nothing is provided, \"responsive\" will be provided automatically. See https://pay.amazon.com/us/developer/documentation/lpwa/201952070.\n    // amazonPayType: The type of button, \"PwA\", \"Pay\", \"A\"\n    // amazonPayColor: The color of the button, \"Gold\", \"LightGray\", \"DarkGray\"\n    // amazonPayButtonSize: The size of the button, \"small\", \"medium\", \"large\", \"x-large\"\n\n    return {\n        restrict: 'A',\n        scope: {\n            paymentMethod: '=?',\n            options: '=?',\n            items: '=?',\n            params: '=?',\n            onLoaded: '=?',\n            onAddressSelect: '=?',\n            onPaymentMethodSelect: '=?',\n            onConsentChange: '=?',\n            getConsentStatus: '=?',\n            error: '=?',\n            onError: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            var client_id = null;\n            var seller_id = null;\n\n            // Watch options and set Amazon Pay parameters if provided.\n            scope.$watch(\"options\", function (newValue, oldValue) {\n\n                if (newValue) {\n\n                    // Check if it has Amazon Pay\n                    var ap = _.findWhere(newValue.payment_methods, { payment_method_type: \"amazon_pay\" });\n                    if (ap) {\n\n                        // Only create the button if the client_id or seller_id have changed.\n                        if (ap.amazon_pay_client_id != client_id || ap.amazon_pay_seller_id != seller_id) {\n\n                            // Hide any widgets and logout\n                            amazonPay.hideWidgets(attrs.amazonPayAddressId, attrs.amazonPayWalletId, attrs.amazonPayConsentId);\n\n                            // If these values currently aren't null, that means the values have changed. Log the customer out of any previous session.\n                            if (client_id || seller_id) {\n                                logout();\n                            }\n\n                            // Set the new ids.\n                            client_id = ap.amazon_pay_client_id;\n                            seller_id = ap.amazon_pay_seller_id;\n\n                            // Create the button\n                            createAmazonPayButton(client_id, seller_id);\n                        }\n\n                    } else {\n\n                        // Hide the widgets\n                        amazonPay.hideWidgets(attrs.amazonPayAddressId, attrs.amazonPayWalletId, attrs.amazonPayConsentId);\n                    }\n                }\n\n            });\n\n            // This function can be used by the user of the directive to get the consent status. It is typically passed into the submit-payment directive so it can error check the status of the checkbox.\n            scope.getConsentStatus = function () {\n                return amazonPay.getConsentStatus();\n            }\n\n            function createAmazonPayButton(client_id, seller_id) {\n\n                // Create the button\n                amazonPay.createPaymentButton(client_id, seller_id, attrs.id, attrs.amazonPayType, attrs.amazonPayColor, attrs.amazonPayButtonSize, function (error, data) {\n\n                    if (error) {\n                        setError(\"external_server_error\", \"remote_server_error\", error, 502);\n                        return;\n                    }\n\n                    // Set the data on the payment method\n                    scope.$apply(function () {\n                        setPaymentMethodData(data.access_token, data.order_reference_id, data.billing_agreement_id, seller_id);\n                    });\n\n                    // Determine if a billing agreement is required.\n                    var recurring = requiresBillingAgreement(scope.items, scope.paymentMethod.save);\n\n                    // Show the widgets\n                    amazonPay.showWidgets(attrs.amazonPayAddressId, attrs.amazonPayWalletId, attrs.amazonPayConsentId, recurring);\n\n                    amazonPay.loadWidgets(client_id, seller_id, recurring, attrs.amazonPayAddressId, attrs.amazonPayWalletId, attrs.amazonPayConsentId, scope.onAddressSelect, scope.onPaymentMethodSelect, scope.onConsentChange, attrs.amazonPayDesignMode, \"Edit\", function (error, data) {\n\n                        if (error) {\n                            setError(\"external_server_error\", \"remote_server_error\", error, 502);\n                            return;\n                        }\n\n                        // Set the data on the payment method\n                        scope.$apply(function () {\n                            setPaymentMethodData(data.access_token, data.order_reference_id, data.billing_agreement_id, data.seller_id);\n                        });\n\n                    });\n                });\n            }\n\n            function requiresBillingAgreement(items, save) {\n                var recurring = false\n                for (var item_id in scope.items) {\n                    if (scope.items[item_id].subscription_plan) {\n                        return true;\n                    }\n                }\n\n                if (scope.paymentMethod.save) {\n                    return true;\n                }\n\n                return false;\n            }\n\n            function logout() {\n                client_id = null;\n                seller_id = null;\n                setPaymentMethodData(null, null, null, null);\n                amazonPay.logout();\n            }\n\n            function setPaymentMethodData(access_token, order_reference_id, billing_agreement_id, seller_id) {\n\n                // If no access token, order reference or billing agreement, revmove the object to completely reset it.\n                if (!access_token && !order_reference_id && !billing_agreement_id) {\n                    if (scope.paymentMethod.data) {\n                        delete scope.paymentMethod.data;\n                    }\n                    return;\n                }\n\n                scope.paymentMethod.data = { access_token: access_token, order_reference_id: order_reference_id, billing_agreement_id: billing_agreement_id, seller_id: seller_id };\n            }\n\n            function setError(type, code, message, status) {\n                scope.$apply(function () {\n                    scope.error = { type: type, reference: \"MmJAvA8\", code: code, message: message, status: status };\n                    if (scope.onError) {\n                        scope.onError(error);\n                    }\n                });\n            }\n\n        }\n    };\n}]);\n\napp.directive('amazonPayReset', ['gettextCatalog', function (gettextCatalog) {\n\n    // Shared scope:\n    // paymentMethod: Provide the payment method object that will hold the Amazon Pay settings that are returned from the Amazon Pay button and widgets.\n    // onComplete: A function that is called after the reset is complete\n\n    return {\n        restrict: 'A',\n        scope: {\n            paymentMethod: '=?',\n            onComplete: '=?',\n    },\n        link: function (scope, elem, attrs, ctrl) {\n\n            elem.bind(\"click\", function () {\n\n                // Reset the payment method data\n                scope.$apply(function () {\n                    amazonPay.logout();\n\n                    if (scope.paymentMethod && scope.paymentMethod.data)\n                    delete scope.paymentMethod.data;\n\n                    if (scope.onComplete)\n                        scope.onComplete();\n                });\n\n                // Hide the widgets\n                amazonPay.hideWidgets(attrs.amazonPayAddressId, attrs.amazonPayWalletId, attrs.amazonPayConsentId);\n\n            });\n        }\n    };\n}]);\n\napp.directive('amazonPayWidgetRefresh', ['gettextCatalog', function (gettextCatalog) {\n\n    // Shared scope:\n    // paymentError: The payment object of the failed payment that requires the widgets to be refreshed.\n    // options: The cart, invoice or payment options, from which the Amazon Pay client and seller settings will be obtained.\n    // onPaymentMethodSelect: A function that will be called when the customer selects a payment method from their Amazon Pay wallet.\n    // error: The error object to communicate errors.\n    // onError: A function that will be called from scope when the payment fails. Will include the (failed) response payment object as a parameter.\n\n    // Attributes\n    // params: An object that supplies a list of parameters to send to the api, such as show, hide, formatted, etc. Used to customize the response object.\n    // amazonPayWalletId: The ID of the HTML element that will hold the Amazon Pay wallet widget\n    // amazonPayDesignMode: Provides the Amazon Pay design mode, the only current value seems to be \"responsive\". If nothing is provided, \"responsive\" will be provided automatically. See https://pay.amazon.com/us/developer/documentation/lpwa/201952070.\n\n    return {\n        restrict: 'A',\n        scope: {\n            paymentError: '=?',\n            options: '=?',\n            params: '=?',\n            onLoaded: '=?',\n            onPaymentMethodSelect: '=?',\n            error: '=?',\n            onError: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n\n            scope.$watchGroup([\"paymentError\", 'options'], function (newValues, oldValues) {\n\n                if (newValues && newValues != oldValues) {\n\n                    var paymentError = newValues[0];\n                    var options = newValues[1];\n\n                    if (paymentError && options) {\n\n                        var data = paymentError.payment_method.data;\n                        var ap = _.findWhere(options.payment_methods, { payment_method_type: \"amazon_pay\" });\n                        var recurring = data.billing_agreement_id != null;\n\n                        amazonPay.reRenderWidgets(ap.amazon_pay_client_id, ap.amazon_pay_seller_id, data.order_reference_id, data.billing_agreement_id, attrs.amazonPayWalletId, scope.onPaymentMethodSelect, attrs.amazonPayDesignMode, function (error, data) {\n\n                            if (error) {\n                                setError(\"external_server_error\", \"remote_server_error\", error, 502);\n                                return;\n                            }\n\n                            // Show the widgets\n                            amazonPay.showWidgets(null, attrs.amazonPayWalletId, null, false);\n\n                        });\n                    }\n                }\n            });\n\n            function setError(type, code, message, status) {\n                scope.$apply(function () {\n                    scope.error = { type: type, reference: \"MmJAvA8\", code: code, message: message, status: status };\n                    if (scope.onError) {\n                        scope.onError(error);\n                    }\n                });\n            }\n\n        }\n    };\n}]);\n\napp.directive('hidePlaceholder', function () {\n    return {\n        restrict: 'A',\n        scope: {\n            hidePlaceholder: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n            if (scope.hidePlaceholder && elem[0].getAttribute(\"placeholder\")) {\n                \n                elem[0].removeAttribute(\"placeholder\");\n\n                arr = elem[0].className.split(\" \");\n                var name = \"hide-placeholder\";\n                if (arr.indexOf(name) == -1) {\n                    elem[0].className += \" \" + name;\n                }\n\n                // The translation filter can replace the removed placeholder, so we are going to allow the placeholder text to be made invisible by adding a hidden-placeholder class to the element.\n                // The application will need to add the following CSS make use of the hidden-placeholder class:\n\n                //  /* WebKit, Blink, Edge */\n                //  .hide-placeholder.hidden-placeholder::-webkit-input-placeholder { color: transparent; opacity: 0 }\n\n                //  /* Mozilla Firefox 4 to 18 */\n                //  .hide-placeholder:-moz-placeholder { color: transparent; opacity: 0; }\n\n                //  /* Mozilla Firefox 19+ */\n                //  .hide-placeholder::-moz-placeholder { color: transparent; opacity: 0; }\n\n                //  /* Internet Explorer 10-11, don't include opacity with IE or it will hide input borders */\n                //  .hide-placeholder:-ms-input-placeholder { color: transparent; }\n\n                //  /* Microsoft Edge */\n                //  .hide-placeholder::-ms-input-placeholder { color: transparent; opacity: 0 }\n\n                //  /* Most modern browsers */\n                //  .hide-placeholder::placeholder { color: transparent; opacity: 0 }\n\n                // The line below is the same as the rules above, just in a single line for easy portability.\n                // .hide-placeholder::-webkit-input-placeholder{color:transparent;opacity:0}.hide-placeholder:-moz-placeholder{color:transparent;opacity:0}.hide-placeholder::-moz-placeholder{color:transparent;opacity:0}.hide-placeholder:-ms-input-placeholder{color:transparent;opacity:0}.hide-placeholder::-ms-input-placeholder{color:transparent;opacity:0}.hide-placeholder::placeholder{color:transparent;opacity:0}\n\n            }\n        }\n    };\n});\n\napp.directive('selectNumbers', ['GeoService', '$timeout', function (GeoService, $timeout) {\n\n    return {\n        restrict: 'A',\n        scope: {\n            start: '=?',\n            end: '=?'\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            // Attributes\n            // start: The starting number in the range\n            // end: The ending number in the range\n            // minLength: If less than this length, the number will be padded with leading zeros.\n\n            scope.$watchGroup(['start', 'end'], function (newValues, oldValues) {\n\n                if (newValues[0] && newValues[1]) {\n\n                    var elemNg = angular.element(elem[0]);\n\n                    // Reset the existing options. If the value is empty, leave in place, this is the \"blank\" option in the list.\n                    var hasEmpty = false;\n                    for (var i = elemNg[0].options.length - 1 ; i >= 0 ; i--) {\n                        if (elemNg[0].options[i].value) {\n                            elemNg[0].remove(i);\n                        } else {\n                            hasEmpty = true;\n                        }\n                    }\n\n                    // If it doesn't have an empty value, add it.\n                    if (!hasEmpty) {\n                        elemNg[0].appendChild(document.createElement(\"option\"));\n                    }\n\n                    for (var i = newValues[0]; i < newValues[1] + 1; i++) {\n                        var display = i;\n                        if (attrs.minLength && String(i).length < Number(attrs.minLength)) {\n                            display = utils.right((\"0\" + i), 2);\n                        }\n                        var option = '<option class=\"select-options-color\" value=\"' + i + '\">' + display + '</option>';\n                        elemNg.append(option);\n                    }\n                }\n\n            });\n        }\n    };\n}]);\n\napp.directive('crossSell', ['CartService', function (CartService) {\n\n    // Shared scope:\n    // cart: The cart.\n\n    // NOTE that the cross-sell element should have exactly one of the following attributes (and not more than one). See below for a couple of samples of usage.\n    // add: A cross sell object to add to the queue of cross sells to be added to the cart at a later time.\n    // remove: A cross sell object to remove from the queue of cross sells that would be added to the cart at a later time. Note this does not remove a cross sell item that has already been added to the cart.\n    // toggle: Add a cross-sell item if it is in the queue, remove a cross sell item if it's already in the queue.\n    // commit: Add a cross sell item to the cart. This only adds the item provided by commit and ignores any in queue.\n    // commitQueued: Add the queue of cross sells to the cart. Provide the list of cross sells to add to the cart as the value\n\n    // The 'queue' parameter is used to pass the items that have been selected for addition to the cart. It is used in combination with some of the items above.\n    // queue: An object that holds the items that have been placed in queue to be added to the cart (for example, if you are using checkboxes to select cross sell items to add to cart)\n\n    // params: An object that supplies a list of parameters to send to the api, such as show, hide, formatted, etc. Used to customize the response object when the cart API is called.\n    // onSuccess: A function that will be called when adding the cross sell(s) to the cart is successful. The cart will be included as a parameter.\n    // onError: A function that will be called when adding the cross sell(s) to the cart fails. The error will be included as a parameter.\n    // error: The error object to communicate errors.\n\n    // A simple cross-sell \"add to cart\"\n    // <div class=\"row\" ng-repeat=\"item in data.cart.cross_sells.data\">\n    //     <div>{{item.name}}</div>\n    //     <button class=\"btn btn-primary\" cross-sell cart=\"data.cart\" commit=\"item\" params=\"data.params\" error=\"data.error\">Add to Cart</button>\n    // </div>\n\n    // Using checkboxes\n    // <div class=\"row\" ng-repeat=\"item in data.cart.cross_sells.data\">\n    //     <span>{{item.name}}</span>\n    //     <input type=\"checkbox\" cross-sell cart=\"data.cart\" queue=\"data.queue\" toggle=\"item\" params=\"data.params\">\n    // </div>\n    // <div class=\"row\">\n    //     <button class=\"btn btn-primary\" cross-sell cart=\"data.cart\" commit-queued=\"data.queue\" params=\"data.params\" error=\"data.error\">Add to Cart</button>\n    // </div>\n\n    // A horrible UI but shows another methodology that might be worked into a particular use case.\n    // <div class=\"row\" ng-repeat=\"item in data.cart.cross_sells.data\">\n    //     <div>{{item.name}}</div>\n    //     <button class=\"btn btn-primary\" cross-sell cart=\"data.cart\" add=\"item\" queue=\"data.queue\" params=\"data.params\">Place in Queue</button>\n    //     <button class=\"btn btn-primary\" cross-sell cart=\"data.cart\" remove=\"item\" queue=\"data.queue\" params=\"data.params\">Remove from Queue</button>\n    // </div>\n    // <div class=\"row\">\n    //     <button class=\"btn btn-primary\" cross-sell cart=\"data.cart\" commit-queued=\"data.queue\" params=\"data.params\" error=\"data.error\">Commit Selections</button>\n    // </div>\n\n    return {\n        restrict: 'A',\n        scope: {\n            cart: '=?',\n            add: '=?',\n            remove: '=?',\n            toggle: '=?',\n            commit: '=?',\n            commitQueued: '=?',\n            queue: '=?',\n            params: '=?',\n            onSuccess: '=?',\n            onError: '=?',\n            error: '=?',\n        },\n        link: function (scope, elem, attrs, ctrl) {\n\n            elem.bind(\"click\", function () {\n\n                // Clear previous errors\n                scope.error = null;\n\n                // Set default value\n                scope.queue = scope.queue || [];\n\n                // Prep the params\n                var params = scope.params || attrs.params;\n                params = utils.mergeParams(params, null, null);\n\n                // Determine what action to take\n                if (attrs.add) {\n                    if (!isQueued(scope.add)) {\n                        scope.$apply(function () { scope.queue.push(scope.add); });\n                    }\n                    return;\n                }\n\n                if (attrs.remove) {\n                    scope.queue = _.reject(scope.queue, function (item) { item.product_id == scope.remove.product_id });\n                    for (var i = 0; i < scope.queue.length; i++) {\n                        if (scope.queue[i].product_id == scope.remove.product_id) {\n                            scope.$apply(function () {\n                                scope.queue.splice(i, 1);\n                            });\n                        }\n                    }\n                    return;\n                }\n\n                if (attrs.toggle) {\n                    if (!isQueued(scope.toggle)) {\n                        scope.$apply(function () { scope.queue.push(scope.toggle) });\n                    } else {\n                        for (var i = 0; i < scope.queue.length; i++) {\n                            if (scope.queue[i].product_id == scope.toggle.product_id) {\n                                scope.$apply(function () {\n                                    scope.queue.splice(i, 1);\n                                });\n                            }\n                        }\n                    }\n                    return;\n                }\n\n                if (attrs.commit || attrs.commitQueued) {\n\n                    var cartCopy = angular.copy(scope.cart);\n                    if (scope.commit) {\n                        cartCopy.items.push({ product_id: scope.commit.product_id, cross_sell_id: scope.commit.cross_sell_id, quantity: scope.commit.quantity || 1 });\n                    } else {\n\n                        if (scope.commitQueued.length == 0)\n                            return;\n\n                        _.each(scope.commitQueued, function (item) {\n                            cartCopy.items.push({ product_id: item.product_id, cross_sell_id: item.cross_sell_id, quantity: item.quantity || 1 });\n                        });\n                    }\n\n                    CartService.update(cartCopy, scope.params).then(function (cart) {\n                        scope.cart = cart;\n                        scope.commitQueued = [];\n                        if (scope.onSuccess)\n                            scope.onSuccess(cart);\n                    }, function (error) {\n                        scope.error = error;\n                        if (scope.onError)\n                            scope.onError(error);\n                    });\n                    return;\n                }\n\n                function isQueued(crossSell) {\n                    if (_.findWhere(scope.queue, { product_id: crossSell.product_id }) == null) {\n                        return false;\n                    }\n                    return true;\n                }\n\n            });\n\n        }\n    };\n}]);\n\n\napp.factory('appCache', ['$cacheFactory', function ($cacheFactory) {\n        return $cacheFactory('appCache');\n    }]);\napp.filter('range', function () {\n    return function (input, min, max, pad) {\n        \n        // Convert string to int\n        min = parseInt(min); \n        max = parseInt(max);\n        \n        function pad(number, length) {\n            var r = String(number);\n            if (r.length < length) {\n                r = utils.repeat(0, length - number.toString().length) + r;\n            }\n            return r;\n        }\n\n        for (var i = min; i <= max; i++)\n            if (!pad) {\n                input.push(i);\n            } else {\n                input.push(pad(i, max.toString().length));\n            }\n        return input;\n    };\n});\napp.service(\"ApiService\", ['$http', '$q', 'SettingsService', 'HelperService', 'StorageService', 'LanguageService', 'gettextCatalog', function ($http, $q, SettingsService, HelperService, StorageService, LanguageService, gettextCatalog) {\n\n    // Return public API.\n    return {\n        create: create,\n        getItem: getItem,\n        getList: getList,\n        update: update,\n        remove: remove,\n        getItemPdf: getItemPdf,\n    };\n\n    function getTokenExpiration(expiresInSeconds) {\n\n        // The header response tells us when the cookie expires. Note that the expiration date slides, we'll update the token expiration with every API call.\n        var expiresInMinutes = 360; // 6 hours, default if for some reason we didn't get a header value.\n\n        if (expiresInSeconds != null && isNaN(expiresInSeconds) == false) {\n            expiresInMinutes = expiresInSeconds / 60;\n        }\n\n        // Subtract 5 minutes to ensure we'll be less than the server.\n        expiresInMinutes = expiresInMinutes - 10;\n\n        return expiresInMinutes;\n\n    }\n\n    function getToken() {\n\n        var deferred = $q.defer();\n\n        var token = StorageService.get(\"token\");\n\n        if (token != null) {\n            deferred.resolve(token);\n            return deferred.promise;\n        }\n\n        // The account_id is only needed in development environments. The hosted environment can call this endpoint without the account_id and it will be determined on the api side from the hostname.\n        var settings = SettingsService.get();\n        var parameters = {};\n\n        // Pass in the user's language selection.\n        parameters.user_locale = LanguageService.getLocale();\n\n        // Pass in the account_id, which is required when asking for a token.\n        parameters.account_id = settings.account.account_id;\n\n        // If this is a test app, send a test flag to request a test token.\n        if (settings.account.test) {\n            parameters.test = true;\n        }\n\n        // Prepare the url\n        var endpoint = buildUrl(\"/auths/limited\", settings);\n\n        var request = $http({\n            ignoreLoadingBar: false,\n            method: \"post\",\n            url: endpoint + \"?timezone=UTC\",\n            params: parameters,\n            timeout: 15000,\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n\n        // Get the token\n        request.then(function (response) {\n\n            StorageService.set(\"token\", response.data.token, response.headers(\"X-Token-Expires-In-Seconds\"));\n\n            // If you got a new token, delete any cart_id or invoice_id cookie. The new token won't be bound to them and letting them remain will cause a conflict when the new token tries to access a cart_id that it's not associated with.\n            StorageService.remove(\"cart_id\");\n            StorageService.remove(\"invoice_id\");\n\n            deferred.resolve(response.data.token);\n        }, function (error) {\n\n            var msg = gettextCatalog.getString(\"There was a problem obtaining authorization for this session. Please reload the page to try your request again.\");\n\n            // If this is a 403 error and you are in test mode, add a note to the error message about test orders.\n            if (settings.account.test && error.data.error.status == 403 && error.data.error.code == \"insufficient_permissions\") {\n                msg = \"This app is installed in test mode and can only be run by authorized test users. To run this app, launch it from within your account while in test mode. If you would like to allow unauthenticated users to run apps in test mode, sign into your account, and enable 'Allow Public Test Orders' under Settings> Technical.\";\n            }\n\n            deferred.reject({ type: \"internal_server_error\", reference: \"6lnOOW1\", code: \"unspecified_error\", message: msg, status: error.status });\n        });\n\n        return deferred.promise;\n    }\n\n    function create(data, url, parameters, quiet) {\n\n        var deferred = $q.defer();\n\n        // Pass in the user's language selection.\n        parameters = parameters || {};\n        parameters.user_locale = LanguageService.getLocale();\n\n        getToken().then(function (token) {\n\n            if (data == null) {\n                data = undefined;\n            }\n\n            // Get the settings\n            var settings = SettingsService.get();\n\n            // Prepare the url\n            var endpoint = buildUrl(url, settings);\n\n            // Timeout is high to handle payment requests that return slowly.\n            var request = $http({\n                ignoreLoadingBar: quiet,\n                method: \"post\",\n                data: angular.toJson(data),\n                url: endpoint + \"?timezone=UTC\",\n                params: parameters,\n                timeout: 65000,\n                headers: {\n                    \"Authorization\": \"Bearer \" + token,\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n\n            request.then(function (response) { onApiSuccess(response, deferred); }, function (error) { onApiError(error, deferred); });\n\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function getItem(url, parameters, quiet) {\n\n        var deferred = $q.defer();\n\n        // Pass in the user's language selection.\n        parameters = parameters || {};\n        parameters.user_locale = LanguageService.getLocale();\n\n        getToken().then(function (token) {\n\n            // Get the settings\n            var settings = SettingsService.get();\n\n            // Prepare the url\n            var endpoint = buildUrl(url, settings);\n\n            var request = $http({\n                ignoreLoadingBar: quiet,\n                method: \"get\",\n                url: endpoint + \"?timezone=UTC\",\n                params: parameters,\n                timeout: 15000,\n                headers: {\n                    \"Authorization\": \"Bearer \" + token,\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n\n            request.then(function (response) { onApiSuccess(response, deferred); }, function (error) { onApiError(error, deferred); });\n\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function getList(url, parameters, quiet) {\n\n        var deferred = $q.defer();\n\n        // Pass in the user's language selection.\n        parameters = parameters || {};\n        parameters.user_locale = LanguageService.getLocale();\n\n        getToken().then(function (token) {\n\n            // Get the settings\n            var settings = SettingsService.get();\n\n            // Prepare the url\n            var endpoint = buildUrl(url, settings);\n\n            // Parse the query parameters in the url\n            var queryParameters = utils.getQueryParameters(url);\n\n            // Remove any query parameters that are explicitly provided in parameters\n            _.each(parameters, function (item, index) {\n                if (queryParameters[index] != null) {\n                    delete queryParameters[index];\n                }\n            });\n\n            // Remove the current query string\n            if (url.indexOf(\"?\") > 0) {\n                url = url.substring(0, url.indexOf(\"?\"));\n            }\n\n            // Append the parameters\n            url = utils.appendParams(url, queryParameters);\n\n            var request = $http({\n                ignoreLoadingBar: quiet,\n                method: \"get\",\n                url: endpoint,\n                params: parameters,\n                timeout: 25000,\n                headers: {\n                    \"Authorization\": \"Bearer \" + token,\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n\n            request.then(function (response) { onApiSuccess(response, deferred); }, function (error) { onApiError(error, deferred); });\n\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function update(data, url, parameters, quiet) {\n\n        var deferred = $q.defer();\n\n        // Pass in the user's language selection.\n        parameters = parameters || {};\n        parameters.user_locale = LanguageService.getLocale();\n\n        getToken().then(function (token) {\n\n            // Get the settings\n            var settings = SettingsService.get();\n\n            // Prepare the url\n            var endpoint = buildUrl(url, settings);\n\n            if (data == null) {\n                data = undefined;\n            }\n\n            var request = $http({\n                ignoreLoadingBar: quiet,\n                method: \"post\",\n                data: angular.toJson(slim(data)),\n                url: endpoint + \"?timezone=UTC\",\n                params: parameters,\n                timeout: 25000,\n                headers: {\n                    \"Authorization\": \"Bearer \" + token,\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n\n            request.then(function (response) { onApiSuccess(response, deferred); }, function (error) { onApiError(error, deferred); });\n\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function remove(url, parameters, quiet) {\n\n        var deferred = $q.defer();\n\n        // Pass in the user's language selection.\n        parameters = parameters || {};\n        parameters.user_locale = LanguageService.getLocale();\n\n        getToken().then(function (token) {\n\n            // Get the settings\n            var settings = SettingsService.get();\n\n            // Prepare the url\n            var endpoint = buildUrl(url, settings);\n\n            var request = $http({\n                ignoreLoadingBar: quiet,\n                method: \"delete\",\n                url: endpoint + \"?timezone=UTC\",\n                params: parameters,\n                timeout: 15000,\n                headers: {\n                    \"Authorization\": \"Bearer \" + token,\n                    \"Content-Type\": \"application/json\"\n                }\n            });\n\n            request.then(function (response) { onApiSuccess(response, deferred); }, function (error) { onApiError(error, deferred); });\n\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function getItemPdf(url, parameters, quiet) {\n\n        var deferred = $q.defer();\n\n        // Pass in the user's language selection.\n        parameters = parameters || {};\n        parameters.user_locale = LanguageService.getLocale();\n\n        getToken().then(function (token) {\n\n            // Get the settings\n            var settings = SettingsService.get();\n\n            // Prepare the url\n            var endpoint = buildUrl(url, settings);\n\n            var request = $http({\n                ignoreLoadingBar: quiet,\n                method: \"get\",\n                url: endpoint + \"?timezone=UTC\",\n                params: parameters,\n                timeout: 15000,\n                responseType: \"arraybuffer\",\n                headers: {\n                    \"Authorization\": \"Bearer \" + token,\n                    \"Accept\": \"application/pdf\"\n                }\n            });\n\n            request.then(function (response) { onApiSuccess(response, deferred); }, function (error) { onApiError(error, deferred); });\n\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function buildUrl(endpoint, settings) {\n\n        // If the url is fully qualified, just return it.\n        if (endpoint.substring(0, 7) == \"http://\" || endpoint.substring(0, 8) == \"https://\") {\n            return endpoint;\n        } else {\n            // The api prefix will contain the fully qualified URL if you are running in development mode. The prefix is defined during the app's bootstrap.\n            return settings.config.apiPrefix + endpoint;\n        }\n\n    }\n\n    function slim(data) {\n\n        // Trim down the size of the payload\n        if (data != null && typeof data === 'object') {\n            var dataCopy = JSON.parse(JSON.stringify(data));\n\n            if (dataCopy.object == \"cart\") {\n                delete dataCopy.options;\n                delete dataCopy.shipping_item;\n                delete dataCopy.payments;\n                _.each(dataCopy.items, function (item) {\n                    delete item.subscription_terms;\n                    delete item.url;\n                    delete item.date_created;\n                    delete item.date_modified;\n                    delete item.formatted;\n                    delete item.product;\n                    delete item.subscription_plan;\n                });\n                delete dataCopy.customer.url;\n                delete dataCopy.customer.payments;\n                delete dataCopy.customer.refunds;\n                delete dataCopy.customer.orders;\n                delete dataCopy.customer.subscriptions;\n                delete dataCopy.customer.invoices;\n                delete dataCopy.promotion;\n            }\n\n            delete dataCopy.date_created;\n            delete dataCopy.date_modified;\n            delete dataCopy.object;\n            delete dataCopy.url;\n            delete dataCopy.test;\n            delete dataCopy.account_id;\n            delete dataCopy.formatted;\n        }\n\n        return dataCopy;\n\n    }\n\n    function onApiSuccess(response, defer) {\n\n        // Update the token expiration date\n        if (StorageService.get(\"token\")) {\n            StorageService.set(\"token\", StorageService.get(\"token\"), response.headers(\"X-Token-Expires-In-Seconds\"));\n        }\n\n        return defer.resolve(response);\n    }\n\n    function onApiError(response, defer) {\n\n        var error = {};\n\n        if (response.data) {\n            if (response.data.error) {\n                error = response.data.error;\n            }\n        }\n\n        var type;\n        var reference;\n        var code;\n        var message;\n\n        if (error) {\n\n            if (error.type) {\n                type = error.type;\n            }\n\n            if (error.code) {\n                code = error.code;\n            }\n\n            if (error.reference) {\n                reference = error.reference;\n            }\n\n            if (error.message) {\n                message = error.message;\n            }\n\n        }\n\n        // If your error is 401, then the token has died, or a login failure.\n        if (response.status == 401) {\n\n            // If the response code is invalid_login or account_locked, then don't get a new token. This is a failed login attempt and not a bad token.\n            if (code != \"invalid_login\" && code != \"account_locked\") {\n\n                // We'll do a full reset because the token is invalid and that means any associated cart_id is now orphaned.\n                HelperService.newSessionRedirect(true, \"Performing session reset due to invalid token in the cookie / request.\");\n            }\n        }\n\n        if (response.status == 403) {\n            message = \"There was a problem establishing your session. Please reload the page to try again.\";\n        }\n\n        // If you don't have an error.message, then you didn't receive a normalized error message from the server. This should not happen rarely but prevents the application from having to consider edge cases where an unexpected response format is returned.\n        if (!message) {\n\n            switch (response.status) {\n                case 404:\n                    type = \"not_found\";\n                    reference = \"4jnJPb7\";\n                    code = \"resource_not_found\";\n                    message = gettextCatalog.getString(\"The item you are trying to access could not be found.\");\n                    break;\n                default:\n                    type = \"internal_server_error\";\n                    reference = \"XEnf9FY\";\n                    code = \"unspecified_error\";\n                    message = gettextCatalog.getString(\"An error occured while attempting to process your request. Please try your request again. If the problem persists, please contact support.\");\n            }\n\n        }\n\n        error.type = type;\n        error.reference = reference;\n        error.code = code;\n        error.message = message;\n        error.status = response.status;\n\n        defer.reject(error);\n\n    }\n\n}]);\n\napp.service(\"CartService\", ['$http', '$q', '$rootScope', 'ApiService', 'PaymentService', 'SettingsService', 'HelperService', 'StorageService', 'LanguageService', function ($http, $q, $rootScope, ApiService, PaymentService, SettingsService, HelperService, StorageService, LanguageService) {\n\n    // Return public API.\n    return {\n        create: create,\n        get: get,\n        update: update,\n        addItem: addItem,\n        getItems: getItems,\n        pay: pay,\n        login: login,\n        logout: logout,\n        fromParams: fromParams\n    };\n\n    function create(data, parameters, quiet, fromParams) {\n\n        // The fromParams parameter indicates if this call is being made with a cart created from URL parameters.\n        // This helps determine how invalid promotion codes should be handled.\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n\n        // If defined, set the currency\n        var currency = StorageService.get(\"currency\");\n        if (currency) {\n            data.currency = currency;\n        }\n\n        var url = \"/carts\";\n        ApiService.create(data, url, parameters, quiet).then(function (response) {\n            var cart = response.data;\n            // Set a cookie. The expiration date of this cookie will be the same as the token expiration, which we can get from the headers.\n            StorageService.set(\"cart_id\", cart.cart_id, response.headers(\"X-Token-Expires-In-Seconds\"));\n\n            // Set the display currency\n            syncCurrency(cart.currency);\n\n            deferred.resolve(cart);\n\n        }, function (error) {\n\n            // If the error is 400, the error code is \"invalid_promotion_code\" and the cart was built from URL parameters, replay the request without the promotion code.\n            // This allows a user to still create a cart when the URL contains an invalid embedded promotion code, although without a promotion. But it allows the order to continue.\n            if (error.code == \"invalid_promotion_code\" && fromParams) {\n                delete data.promotion_code;\n                create(data, parameters, quiet, false).then(function (response) {\n                    deferred.resolve(response);\n                }, function (error) {\n                    deferred.reject(error);\n                });\n            } else {\n                // Jus reject it\n                deferred.reject(error);\n            }\n        });\n\n        return deferred.promise;\n\n    }\n\n    function get(parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n        var cart_id = StorageService.get(\"cart_id\");\n\n        // Set up some stubs in the event of no cart or customer\n        var customerStub = { billing_address: {}, shipping_address: {} };\n        var cartStub = { items: [], customer: customerStub };\n\n        if (cart_id) {\n            var url = \"/carts/\" + cart_id;\n\n            ApiService.getItem(url, parameters, quiet).then(function (response) {\n                var cart = response.data;\n                // If the customer is null, set a stub\n                if (cart.customer == null) {\n                    cart.customer = customerStub;\n                }\n\n                // If the billing country is null, supply from the ip address\n                if (cart.customer.billing_address.country == null) {\n                    cart.customer.billing_address.country = cart.customer_ip_country;\n                }\n\n                // If the shiping country is null, supply from the ip address\n                if (cart.customer.shipping_address.country == null) {\n                    cart.customer.shipping_address.country = cart.customer_ip_country;\n                }\n\n                // In case it changed, sync the currency\n                syncCurrency(cart.currency);\n\n                deferred.resolve(cart);\n\n            }, function (error) {\n\n                // If 404, perform a session reset.\n                if (error.status == 404) {\n                    HelperService.newSessionRedirect(true, \"Performing a session reset due to an invalid cart_id in the cookie / request. (404 - cart not found)\");\n                }\n\n                deferred.reject(error);\n            });\n\n        } else {\n            // Return an empty cart. Build a stub object to make it easy to reference deep items even before a cart is created.\n            deferred.resolve(cartStub);\n        }\n\n        return deferred.promise;\n\n    }\n\n    function update(data, parameters, quiet, fromParams) {\n\n        // The fromParams parameter indicates if this call is being made with a cart created from URL parameters.\n        // This helps determine how invalid promotion codes should be handled.\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n        var cart_id = StorageService.get(\"cart_id\");\n\n        if (cart_id) {\n\n            var url = \"/carts/\" + cart_id;\n            ApiService.update(data, url, parameters, quiet).then(function (response) {\n\n                var cart = response.data;\n                // Update the cookie expiration date. The expiration date of this cookie will be the same as the token expiration, which we can get from the headers.\n                StorageService.set(\"cart_id\", cart.cart_id, response.headers(\"X-Token-Expires-In-Seconds\"));\n\n                // In case it changed, sync the currency\n                syncCurrency(cart.currency);\n\n                deferred.resolve(cart);\n\n            }, function (error) {\n\n                // If the error is 400, the error code is \"invalid_promotion_code\" and the cart was built from URL parameters, replay the request without the promotion code.\n                // This allows a user to still create a cart when the URL contains an invalid embedded promotion code, although without a promotion. But it allows the order to continue.\n                if (error.code == \"invalid_promotion_code\" && fromParams) {\n                    delete data.promotion_code;\n                    update(data, parameters, quiet, false).then(function (response) {\n                        deferred.resolve(response);\n                    }, function (error) {\n                        deferred.reject(error);\n                    });\n                } else {\n                    // If 404, perform a session reset.\n                    if (error.status == 404) {\n                        HelperService.newSessionRedirect(true, \"Performing a session reset due to an invalid cart_id in the cookie / request. (404 - cart not found)\");\n                    }\n\n                    // If invalid state, then the cart is already closed, perform a session reset.\n                    if (error.code == \"invalid_state\") {\n                        // Delete the cart_id as it can no longer be modified.\n                        StorageService.remove(\"cart_id\");\n                        HelperService.newSessionRedirect(false, \"Performing a cart_id reset due to an invalid cart_id in the cookie / request. (422 - invalid state): \" + error.message);\n                    }\n\n                    deferred.reject(error);\n\n                }\n\n            });\n\n            return deferred.promise;\n\n        } else {\n\n            // No cart exists. Create a new cart.\n            return create(data, parameters, quiet, fromParams);\n\n        }\n\n    }\n\n    function login(data, parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n        var cart_id = StorageService.get(\"cart_id\");\n\n        var url = \"/carts/\" + cart_id + \"/login\";\n        ApiService.update(data, url, parameters, quiet).then(function (response) {\n\n            var cart = response.data;\n            // Update the cookie expiration date. The expiration date of this cookie will be the same as the token expiration, which we can get from the headers.\n            StorageService.set(\"cart_id\", cart.cart_id, response.headers(\"X-Token-Expires-In-Seconds\"));\n\n            // In case it changed, sync the currency\n            syncCurrency(cart.currency);\n\n            deferred.resolve(cart);\n\n        }, function (error) {\n\n            // If 404, perform a session reset.\n            if (error.status == 404) {\n                HelperService.newSessionRedirect(true, \"Performing a session reset due to an invalid cart_id in the cookie / request. (404 - cart not found)\");\n            }\n\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function logout(parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n        var cart_id = StorageService.get(\"cart_id\");\n\n        var url = \"/carts/\" + cart_id + \"/logout\";\n        ApiService.update(null, url, parameters, quiet).then(function (response) {\n\n            var cart = response.data;\n            // Update the cookie expiration date. The expiration date of this cookie will be the same as the token expiration, which we can get from the headers.\n            StorageService.set(\"cart_id\", cart.cart_id, response.headers(\"X-Token-Expires-In-Seconds\"));\n\n            // In case it changed, sync the currency\n            syncCurrency(cart.currency);\n\n            deferred.resolve(cart);\n\n        }, function (error) {\n\n            // If 404, perform a session reset.\n            if (error.status == 404) {\n                HelperService.newSessionRedirect(true, \"Performing a session reset due to an invalid cart_id in the cookie / request. (404 - cart not found)\");\n            }\n\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function addItem(data, parameters, quiet) {\n\n        var deferred = $q.defer();\n\n        if (data == null) {\n            deferred.reject({ type: \"bad_request\", reference: \"vbVcrcF\", code: \"invalid_input\", message: \"You must supply an item to add to the cart.\", status: 400 });\n            return deferred.promise;\n        }\n\n        parameters = setDefaultParameters(parameters);\n\n        // Get the cart.\n        get(parameters).then(function (cart) {\n\n            // Check if the cart has already been created.\n            if (cart.url) {\n                // Is the item in the cart?\n                var existingItem = _.findWhere(cart.items, data);\n\n                if (existingItem != null) {\n                    ApiService.update(data, existingItem.url, parameters, quiet).then(function (response) {\n\n                        var item = response.data;\n                        // In case it changed, sync the currency\n                        syncCurrency(item.currency);\n\n                        deferred.resolve(item);\n\n                    }, function (error) {\n                        deferred.reject(error);\n                    });\n                } else {\n                    // Add it\n                    ApiService.create(data, cart.url + \"/items\", parameters, quiet).then(function (response) {\n\n                        var item = response.data;\n                        // In case it changed, sync the currency\n                        syncCurrency(item.currency);\n\n                        deferred.resolve(item);\n\n                    }, function (error) {\n                        deferred.reject(error);\n                    });\n                }\n\n            } else {\n                // No cart created yet, create a cart with this item and send it.\n                cart.items.push(data);\n                create(cart, parameters, quiet).then(function (cart) {\n                    deferred.resolve(_.findWhere(cart.items, { item_id: data.product_id }));\n                }, function (error) {\n                    deferred.reject(error);\n                });\n            }\n\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function getItems(parameters, quiet) {\n\n        get(parameters, quiet).then(function (cart) {\n\n            // In case it changed, sync the currency\n            syncCurrency(cart.currency);\n\n            deferred.resolve(cart.items);\n\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function pay(cart, payment_method, parameters, cartParameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n\n        // Define a function to send the payment, which happens after we create or update the cart.\n        var sendPayment = function (cart_id, payment_method) {\n\n            // Create the payment url\n            var url = \"/carts/\" + cart.cart_id + \"/payments\";\n\n            // Run the payment\n            PaymentService.create(payment_method, url, parameters, quiet).then(function (payment) {\n\n                // If the payment status is completed or the payment status is pending and the payment method is credit card, delete the cart_id. Attempting to interact with a closed cart (due to a successful payment) will result in errors.\n                if (payment.status == \"completed\" || payment.status == \"pending\") {\n                    StorageService.remove(\"cart_id\");\n                }\n\n                deferred.resolve(payment);\n\n            }, function (error) {\n                deferred.reject(error);\n            });\n        };\n\n        var copyObject = function (cart, newCart) {\n            for (var property in newCart) {\n                if (newCart.hasOwnProperty(property)) {\n                    cart[property] = newCart[property];\n                }\n            }\n        }\n\n        // If there currently is no cart, create it. Otherwise, update the existing cart.\n        if (!cart || cart.cart_id == null) {\n            create(cart, cartParameters, quiet).then(function (data) {\n                copyObject(cart, data);\n                sendPayment(cart.cart_id, payment_method);\n            }, function (error) {\n                deferred.reject(error);\n            });\n        } else {\n            update(cart, cartParameters, quiet).then(function (data) {\n                copyObject(cart, data);\n                sendPayment(cart.cart_id, payment_method);\n            }, function (error) {\n                deferred.reject(error);\n            });\n        }\n\n        return deferred.promise;\n\n    }\n\n    function fromParams(cart, location) {\n\n        // location should be the angular $location object\n\n        var params = location.search();\n\n        // We are looking for the following parameters. This can be exapnded at any time, as needed.\n        // product_id:xxxx, promotion_code, currency, name, email.\n\n        // If empty_cart is true, remove the items from the current cart.\n        if (utils.stringToBool(params.empty_cart)) {\n            cart.items = [];\n            location.search(\"empty_cart\", null);\n        }\n\n        // Find the product_ids\n        for (var property in params) {\n            if (params.hasOwnProperty(property)) {\n                if (utils.left(property, 11) == \"product_id:\") {\n\n                    var item = { product_id: property.substring(11) };\n                    if (utils.isValidInteger(params[property]) == false) {\n                        item.quantity = 1;\n                    } else {\n                        item.quantity = params[property];\n                    }\n\n                    // Remove the item if it already exists in the cart\n                    var existingItem = _.find(cart.items, function (i) { return i.product_id == item.product_id; });\n                    if (existingItem != null) {\n                        cart.items = _.reject(cart.items, function (i) { return i.product_id == item.product_id; });\n                    }\n\n                    // Set the item into the cart\n                    cart.items = cart.items || [];\n                    cart.items.push(item);\n                    location.search(property, null);\n\n                }\n            }\n        }\n\n        // Append the others\n        if (params.promotion_code) {\n            cart.promotion_code = params.promotion_code;\n            location.search(\"promotion_code\", null);\n        }\n\n        if (params.currency) {\n            cart.currency = params.currency;\n            location.search(\"currency\", null);\n        }\n\n        if (params.name) {\n            cart.customer.name = params.name;\n            location.search(\"name\", null);\n        }\n\n        if (params.email) {\n            if (utils.isValidEmail(params.email)) {\n                cart.customer.email = params.email;\n            }\n            location.search(\"email\", null);\n        }\n\n        if (params.referrer) {\n            cart.referrer = params.referrer;\n            location.search(\"referrer\", null);\n        }\n\n        if (params.affiliate_id) {\n            cart.affiliate_id = params.affiliate_id;\n            location.search(\"affiliate_id\", null);\n        }\n\n        // If there are no customer properties, delete the customer property\n        if (_.size(cart.customer) == 0) {\n            delete cart.customer;\n        }\n\n        if (params.language) {\n            LanguageService.setLanguage(params.language);\n            location.search(\"language\", null);\n        }\n\n        // Append any other parameters as meta\n        params = location.search();\n\n        for (var property in params) {\n            if (params.hasOwnProperty(property)) {\n                if (cart.meta == null) {\n                    cart.meta = {};\n                }\n                cart.meta[property] = params[property];\n            }\n        }\n\n\n        return cart;\n\n    }\n\n    function syncCurrency(newCurrency) {\n\n        // This makes sure that the currency in cart payload responses automatically sync the stored currency value\n        var currentCurrency = StorageService.get(\"currency\");\n\n        if (newCurrency != currentCurrency) {\n\n            StorageService.set(\"currency\", newCurrency);\n\n            // Emit the change\n            $rootScope.$emit(\"currencyChanged\", newCurrency);\n        }\n    }\n\n    function setDefaultParameters(parameters, quiet) {\n\n        var parametersCopy = angular.copy(parameters);\n\n        // Cart is a complicated object and a lot of directives interact with it at the same time. As such, we don't allow the show parameter. Too likely toes will get stepped on.\n        if (parametersCopy) {\n            parametersCopy.formatted = true;\n            delete parametersCopy.show;\n            return parametersCopy;\n        } else {\n            return { formatted: true, options: true };\n        }\n\n    }\n\n}]);\n\napp.service(\"InvoiceService\", ['$http', '$q', '$rootScope', 'ApiService', 'PaymentService', 'SettingsService', 'HelperService', 'StorageService', '$location', function ($http, $q, $rootScope, ApiService, PaymentService, SettingsService, HelperService, StorageService, $location) {\n\n    // Return public API.\n    return {\n        get: get,\n        update: update,\n        pay: pay\n    };\n\n    function get(parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n\n        // Get the invoice ID\n        var invoice_id = $location.search().invoice_id;\n        if (!invoice_id) {\n            invoice_id = StorageService.get(\"invoice_id\");\n        }\n\n        var url = \"/invoices/\" + invoice_id;\n\n        ApiService.getItem(url, parameters, quiet).then(function (response) {\n\n            var invoice = response.data;\n            StorageService.set(\"invoice_id\", invoice.invoice_id);\n\n            // In case it changed, sync the currency\n            syncCurrency(invoice.currency);\n\n            deferred.resolve(invoice);\n\n        }, function (error) {\n\n            // If 404, perform a redirect to base entry page. Don't perform a hard reset, just delete the invoice ID from storage and redirect. Also remove from the query string, if provided.\n            if (error.status == 404) {\n                $location.search(\"invoice_id\", null);\n                StorageService.remove(\"invoice_id\");\n                HelperService.newSessionRedirect(false, \"Performing a redirect due to an invalid invoice_id in the cookie / request. (404 - invoice not found)\");\n            }\n\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function update(data, parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n        var invoice_id = StorageService.get(\"invoice_id\");\n\n        var url = \"/invoices/\" + invoice_id;\n        ApiService.update(data, url, parameters, quiet).then(function (response) {\n\n            var invoice = response.data;\n            // Update the cookie expiration date. The expiration date of this cookie will be the same as the token expiration, which we can get from the headers.\n            StorageService.set(\"invoice_id\", invoice.invoice_id, response.headers(\"X-Token-Expires-In-Seconds\"));\n\n            // In case it changed, sync the currency\n            syncCurrency(invoice.currency);\n\n            deferred.resolve(invoice);\n\n        }, function (error) {\n\n            // If 404, perform a session reset.\n            if (error.status == 404) {\n                HelperService.newSessionRedirect(true, \"Performing a session reset due to an invalid invoice_id in the cookie / request. (404 - invoice not found)\");\n            }\n\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function pay(invoice, payment_method, parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n\n        var sendPayment = function (invoice_id, payment_method) {\n\n            // Create the payment url\n            var url = \"/invoices/\" + invoice.invoice_id + \"/payments\";\n\n            // Run the payment\n            PaymentService.create(payment_method, url, parameters, quiet).then(function (payment) {\n\n                // If the payment is completed or pending, remove the invoice_id from the cookie.\n                if (payment.status == \"completed\" || payment.status == \"pending\") {\n                    StorageService.remove(\"invoice_id\");\n                }\n\n                deferred.resolve(payment);\n\n            }, function (error) {\n                deferred.reject(error);\n            });\n        };\n\n        // Send the payment.\n        sendPayment(invoice.invoice_id, payment_method);\n\n        return deferred.promise;\n\n    }\n\n    function syncCurrency(newCurrency) {\n\n        // This makes sure that the currency in invoice payload responses automatically sync the stored currency value\n        var currentCurrency = StorageService.get(\"currency\");\n\n        if (newCurrency != currentCurrency) {\n\n            StorageService.set(\"currency\", newCurrency);\n\n            // Emit the change\n            $rootScope.$emit(\"currencyChanged\", newCurrency);\n        }\n    }\n\n    function setDefaultParameters(parameters, quiet) {\n\n        var parametersCopy = angular.copy(parameters);\n\n        // Invoice is a complicated object and a lot of directives interact with it at the same time. As such, we don't allow the show parameter. Too likely toes will get stepped on.\n        if (parametersCopy) {\n            parametersCopy.formatted = true;\n            delete parametersCopy.show;\n            return parametersCopy;\n        } else {\n            return { formatted: true, options: true };\n        }\n\n    }\n\n}]);\n\napp.service(\"PaymentService\", ['$http', '$q', 'ApiService', 'SettingsService', 'StorageService', 'LanguageService', function ($http, $q, ApiService, SettingsService, StorageService, LanguageService) {\n\n    // Return public API.\n    return {\n        create: create,\n        createDirect: createDirect,\n        get: get,\n        update: update,\n        getOptions: getOptions,\n        commit: commit,\n        fromParams: fromParams\n    };\n\n    function create(payment_method, url, parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n\n        // Build the payment method object\n        var data = { payment_method: payment_method };\n\n        ApiService.create(data, url, parameters, quiet).then(function (response) {\n            var payment = response.data;\n            deferred.resolve(payment);\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function update(data, parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n\n        ApiService.update(data, \"/payments/\" + data.payment_id, parameters, quiet).then(function (response) {\n            var payment = response.data;\n            deferred.resolve(payment);\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function createDirect(payment, parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n        var url = \"/payments\";\n\n        ApiService.create(payment, url, parameters, quiet).then(function (response) {\n            var result = response.data;\n            deferred.resolve(result);\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function get(payment_id, parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n\n        if (payment_id) {\n            var url = \"/payments/\" + payment_id;\n\n            ApiService.getItem(url, parameters, quiet).then(function (response) {\n                var payment = response.data;\n                deferred.resolve(payment);\n            }, function (error) {\n                deferred.reject(error);\n            });\n\n        } else {\n            deferred.reject({ \"type\": \"bad_request\", reference: \"HdPWrih\", code: \"invalid_input\", message: \"You request contained invalid data and could not be processed.\", status: 400 });\n            console.log(\"Your request for a payment must include a payment_id.\");\n        }\n\n        return deferred.promise;\n\n    }\n\n    function getOptions(parameters, quiet) {\n\n        var deferred = $q.defer();\n\n        var url = \"/payments/options\";\n        ApiService.getItem(url, parameters, quiet).then(function (response) {\n            var options = response.data;\n            deferred.resolve(options);\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function commit(payment_id, parameters, quiet) {\n\n        // This is used for payment methods such as PayPal and Amazon Pay that need to be tiggered for completion after they have been reviewed by the customer.\n\n        var url = \"/payments/\" + payment_id + \"/commit\";\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n\n        ApiService.create(null, url, parameters, quiet).then(function (response) {\n            var payment = response.data;\n\n            // If the payment status is completed or pending, delete the cart_id and / or invoice_id. Attempting to interact with a closed cart or invoice (due to a successful payment) will result in errors.\n            if (payment.status == \"completed\" || payment.status == \"pending\") {\n                StorageService.remove(\"cart_id\");\n                StorageService.remove(\"invoice_id\");\n            }\n\n            deferred.resolve(payment);\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n    function fromParams(payment, location) {\n\n        // Set payment as an object if null\n        payment = payment || {}\n\n        // location should be the angular $location object\n\n        // Make a copy so we can modify without changing the original params\n        var params = angular.copy(location.search());\n\n        // This is designed to be used for a \"hosted payment page\", where the customer makes an arbitrary payment not associated with a cart or invoice. Parameters such as amount, currency, description, reference and customer details can be passed as URL params.\n\n        if (params.currency) {\n            payment.currency = params.currency;\n            delete params.currency;\n            location.search(\"currency\", null);\n        }\n\n        if (params.total && utils.isValidNumber(params.total)) {\n            payment.total = params.total;\n            delete params.total;\n            location.search(\"total\", null);\n        }\n\n        // If the total is not supplied, look for subtotal, shipping, tax.\n        if (!payment.total) {\n\n            if (params.subtotal && utils.isValidNumber(params.subtotal)) {\n                payment.subtotal = params.subtotal;\n                delete params.subtotal;\n                location.search(\"subtotal\", null);\n            }\n\n            if (params.shipping && utils.isValidNumber(params.shipping)) {\n                payment.shipping = params.shipping;\n                delete params.shipping;\n                location.search(\"shipping\", null);\n            }\n\n            if (params.tax && utils.isValidNumber(params.tax)) {\n                payment.tax = params.tax;\n                delete params.tax;\n                location.search(\"tax\", null);\n            }\n\n        }\n\n        if (params.reference) {\n            payment.reference = params.reference;\n            delete params.reference;\n            location.search(\"reference\", null);\n        }\n\n        if (params.description) {\n            payment.description = params.description;\n            delete params.description;\n            location.search(\"description\", null);\n        }\n\n        payment.customer = payment.customer || {};\n\n        if (params.company_name) {\n            payment.customer.company_name = params.company_name;\n            delete params.company_name;\n        }\n\n        if (params.name) {\n            payment.customer.name = params.name;\n            delete params.name;\n        }\n\n        if (params.email) {\n            if (utils.isValidEmail(params.email)) {\n                payment.customer.email = params.email;\n            }\n            delete params.email;\n        }\n\n        if (params.referrer) {\n            payment.referrer = params.referrer;\n            delete params.referrer;\n        }\n\n        if (params.language) {\n            LanguageService.setLanguage(params.language);\n            location.search(\"language\", null);\n        }\n\n        // Append any other parameters as meta\n        for (var property in params) {\n            if (params.hasOwnProperty(property)) {\n                if (payment.meta == null) {\n                    payment.meta = {};\n                }\n                payment.meta[property] = params[property];\n            }\n        }\n\n        return payment;\n\n    }\n\n    function setDefaultParameters(parameters, quiet) {\n\n        // Make sure the response data and payment method is expanded.\n        if (parameters) {\n\n            parameters.formatted = true;\n\n            if (parameters.expand == null) {\n                parameters.expand = \"response_data,payment_method\";\n            } else {\n                if (parameters.expand.indexOf(\"response_data\") == \"-1\") {\n                    parameters.expand += \",response_data\";\n                }\n                if (parameters.expand.indexOf(\"payment_method\") == \"-1\") {\n                    parameters.expand += \",payment_method\";\n                }\n            }\n\n            return parameters;\n\n        } else {\n\n            return { formatted: true, expand: \"response_data,payment_method\" };\n\n        }\n\n    }\n\n}]);\n\napp.service(\"OrderService\", ['$http', '$q', 'ApiService', function ($http, $q, ApiService) {\n\n    // Return public API.\n    return {\n        get: get\n    };\n\n    function get(order_id, parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n\n        if (order_id) {\n            var url = \"/orders/\" + order_id;\n\n            ApiService.getItem(url, parameters, quiet).then(function (response) {\n                var payment = response.data;\n                deferred.resolve(payment);\n            }, function (error) {\n                deferred.reject(error);\n            });\n\n        } else {\n            deferred.reject({ \"type\": \"bad_request\", reference: \"HdPWrih\", code: \"invalid_input\", message: \"The order you are trying to view cannot be found.\", status: 400 });\n            console.log(\"The order_id was not provided.\");\n        }\n\n        return deferred.promise;\n\n    }\n\n    function setDefaultParameters(parameters, quiet) {\n\n        if (parameters) {\n            parameters.formatted = true;\n            return parameters;\n        } else {\n            return { formatted: true };\n        }\n\n    }\n\n}]);\n\napp.service(\"CustomerService\", ['$http', '$q', 'ApiService', function ($http, $q, ApiService) {\n\n    // Return public API.\n    return {\n        createAccount: createAccount,\n        login: login\n    };\n\n    function createAccount(customer, parameters, quiet) {\n\n        var deferred = $q.defer();\n\n        if (customer.customer_id) {\n            var url = \"/customers/\" + customer.customer_id;\n\n            ApiService.update(customer, url, parameters, quiet).then(function (response) {\n                deferred.resolve(response.data);\n            }, function (error) {\n                deferred.reject(error);\n            });\n\n        } else {\n            deferred.reject({ \"type\": \"bad_request\", reference: \"8b1oMYs\", code: \"invalid_input\", message: \"The request could not be completed.\", status: 400 });\n            console.log(\"The customer object in the account creation request did not contain a customer_id.\");\n        }\n\n        return deferred.promise;\n\n    }\n\n    function login(data, parameters, quiet) {\n\n        var deferred = $q.defer();\n\n        var url = \"/customers/login\";\n        ApiService.create(data, url, parameters, quiet).then(function (response) {\n\n            var customer = response.data;\n            deferred.resolve(customer);\n\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n\n    }\n\n}]);\n\napp.service(\"ProductService\", ['$http', '$q', 'ApiService', 'CurrencyService', function ($http, $q, ApiService, CurrencyService) {\n\n    // Return public API.\n    return {\n        get: get,\n        getList: getList\n    };\n\n    function get(product_id, parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n\n        if (product_id) {\n            var url = \"/products/\" + product_id;\n\n            ApiService.getItem(url, parameters, quiet).then(function (response) {\n                var product = response.data;\n                // If the currency is not currently set, set it to the value of the returned product.\n                if (CurrencyService.getCurrency() == null) {\n                    CurrencyService.setCurrency(product.currency);\n                }\n\n                deferred.resolve(product);\n            }, function (error) {\n                deferred.reject(error);\n            });\n\n        } else {\n            deferred.reject({ \"type\": \"bad_request\", reference: \"IrUQTRv\", code: \"invalid_input\", message: \"The product you are trying to view cannot be found.\", status: 400 });\n            console.log(\"The product_id was not provided.\");\n        }\n\n        return deferred.promise;\n\n    }\n\n    function getList(parameters, quiet) {\n\n        var deferred = $q.defer();\n        parameters = setDefaultParameters(parameters);\n        var url = \"/products\";\n\n        ApiService.getList(url, parameters, quiet).then(function (response) {\n            var products = response.data;\n            // If the currency is not currently set, set it to the value of the returned product.\n            if (CurrencyService.getCurrency() == null) {\n                if (products.data[0]) {\n                    CurrencyService.setCurrency(products.data[0].currency);\n                }\n            }\n\n            deferred.resolve(products);\n        }, function (error) {\n            deferred.reject(error);\n        });\n\n        return deferred.promise;\n    }\n\n    function setDefaultParameters(parameters, quiet) {\n\n        if (parameters) {\n            parameters.formatted = true;\n            return parameters;\n        } else {\n            return { formatted: true };\n        }\n\n    }\n\n}]);\n\napp.service(\"GeoService\", [function () {\n\n    // Return public API.\n    return {\n        getData: getData,\n        getStatesProvs: getStatesProvs,\n        isEu: isEu,\n        getCurrencySymbol: getCurrencySymbol\n    };\n\n    function getData() {\n\n        var geo = {};\n\n        geo.countries = [{ name: 'Afghanistan', code: 'AF' }, { name: 'Albania', code: 'AL' }, { name: 'Algeria', code: 'DZ' }, { name: 'American Samoa', code: 'AS' }, { name: 'Andorra', code: 'AD' }, { name: 'Angola', code: 'AO' }, { name: 'Anguilla', code: 'AI' }, { name: 'Antarctica', code: 'AQ' }, { name: 'Antigua and Barbuda', code: 'AG' }, { name: 'Argentina', code: 'AR' }, { name: 'Armenia', code: 'AM' }, { name: 'Aruba', code: 'AW' }, { name: 'Australia', code: 'AU' }, { name: 'Austria', code: 'AT' }, { name: 'Azerbaijan', code: 'AZ' }, { name: 'Bahamas', code: 'BS' }, { name: 'Bahrain', code: 'BH' }, { name: 'Bangladesh', code: 'BD' }, { name: 'Barbados', code: 'BB' }, { name: 'Belarus', code: 'BY' }, { name: 'Belgium', code: 'BE' }, { name: 'Belize', code: 'BZ' }, { name: 'Benin', code: 'BJ' }, { name: 'Bermuda', code: 'BM' }, { name: 'Bhutan', code: 'BT' }, { name: 'Bolivia, Plurinational State of', code: 'BO' }, { name: 'Bonaire, Sint Eustatius and Saba', code: 'BQ' }, { name: 'Bosnia and Herzegovina', code: 'BA' }, { name: 'Botswana', code: 'BW' }, { name: 'Bouvet Island', code: 'BV' }, { name: 'Brazil', code: 'BR' }, { name: 'British Indian Ocean Territory', code: 'IO' }, { name: 'Brunei Darussalam', code: 'BN' }, { name: 'Bulgaria', code: 'BG' }, { name: 'Burkina Faso', code: 'BF' }, { name: 'Burundi', code: 'BI' }, { name: 'Cambodia', code: 'KH' }, { name: 'Cameroon', code: 'CM' }, { name: 'Canada', code: 'CA' }, { name: 'Cape Verde', code: 'CV' }, { name: 'Cayman Islands', code: 'KY' }, { name: 'Central African Republic', code: 'CF' }, { name: 'Chad', code: 'TD' }, { name: 'Chile', code: 'CL' }, { name: 'China', code: 'CN' }, { name: 'Christmas Island', code: 'CX' }, { name: 'Cocos (Keeling) Islands', code: 'CC' }, { name: 'Colombia', code: 'CO' }, { name: 'Comoros', code: 'KM' }, { name: 'Congo', code: 'CG' }, { name: 'Congo, the Democratic Republic of the', code: 'CD' }, { name: 'Cook Islands', code: 'CK' }, { name: 'Costa Rica', code: 'CR' }, { name: 'Cote d Ivoire', code: 'CI' }, { name: 'Croatia', code: 'HR' }, { name: 'Cuba', code: 'CU' }, { name: 'Curacao', code: 'CW' }, { name: 'Cyprus', code: 'CY' }, { name: 'Czech Republic', code: 'CZ' }, { name: 'Denmark', code: 'DK' }, { name: 'Djibouti', code: 'DJ' }, { name: 'Dominica', code: 'DM' }, { name: 'Dominican Republic', code: 'DO' }, { name: 'Ecuador', code: 'EC' }, { name: 'Egypt', code: 'EG' }, { name: 'El Salvador', code: 'SV' }, { name: 'Equatorial Guinea', code: 'GQ' }, { name: 'Eritrea', code: 'ER' }, { name: 'Estonia', code: 'EE' }, { name: 'Ethiopia', code: 'ET' }, { name: 'Falkland Islands', code: 'AX' }, { name: 'Falkland Islands (Malvinas)', code: 'FK' }, { name: 'Faroe Islands', code: 'FO' }, { name: 'Fiji', code: 'FJ' }, { name: 'Finland', code: 'FI' }, { name: 'France', code: 'FR' }, { name: 'French Guiana', code: 'GF' }, { name: 'French Polynesia', code: 'PF' }, { name: 'French Southern Territories', code: 'TF' }, { name: 'Gabon', code: 'GA' }, { name: 'Gambia', code: 'GM' }, { name: 'Georgia', code: 'GE' }, { name: 'Germany', code: 'DE' }, { name: 'Ghana', code: 'GH' }, { name: 'Gibraltar', code: 'GI' }, { name: 'Greece', code: 'GR' }, { name: 'Greenland', code: 'GL' }, { name: 'Grenada', code: 'GD' }, { name: 'Guadeloupe', code: 'GP' }, { name: 'Guam', code: 'GU' }, { name: 'Guatemala', code: 'GT' }, { name: 'Guernsey', code: 'GG' }, { name: 'Guinea', code: 'GN' }, { name: 'Guine Bissau', code: 'GW' }, { name: 'Guyana', code: 'GY' }, { name: 'Haiti', code: 'HT' }, { name: 'Heard Island and McDonald Islands', code: 'HM' }, { name: 'Holy See (Vatican City State)', code: 'VA' }, { name: 'Honduras', code: 'HN' }, { name: 'Hong Kong', code: 'HK' }, { name: 'Hungary', code: 'HU' }, { name: 'Iceland', code: 'IS' }, { name: 'India', code: 'IN' }, { name: 'Indonesia', code: 'ID' }, { name: 'Iran', code: 'IR' }, { name: 'Iraq', code: 'IQ' }, { name: 'Ireland', code: 'IE' }, { name: 'Isle of Man', code: 'IM' }, { name: 'Israel', code: 'IL' }, { name: 'Italy', code: 'IT' }, { name: 'Jamaica', code: 'JM' }, { name: 'Japan', code: 'JP' }, { name: 'Jersey', code: 'JE' }, { name: 'Jordan', code: 'JO' }, { name: 'Kazakhstan', code: 'KZ' }, { name: 'Kenya', code: 'KE' }, { name: 'Kiribati', code: 'KI' }, { name: 'Korea', code: 'KR' }, { name: 'Kuwait', code: 'KW' }, { name: 'Kyrgyzstan', code: 'KG' }, { name: 'Lao Peoples Democratic Republic', code: 'LA' }, { name: 'Latvia', code: 'LV' }, { name: 'Lebanon', code: 'LB' }, { name: 'Lesotho', code: 'LS' }, { name: 'Liberia', code: 'LR' }, { name: 'Libya', code: 'LY' }, { name: 'Liechtenstein', code: 'LI' }, { name: 'Lithuania', code: 'LT' }, { name: 'Luxembourg', code: 'LU' }, { name: 'Macao', code: 'MO' }, { name: 'Macedonia', code: 'MK' }, { name: 'Madagascar', code: 'MG' }, { name: 'Malawi', code: 'MW' }, { name: 'Malaysia', code: 'MY' }, { name: 'Maldives', code: 'MV' }, { name: 'Mali', code: 'ML' }, { name: 'Malta', code: 'MT' }, { name: 'Marshall Islands', code: 'MH' }, { name: 'Martinique', code: 'MQ' }, { name: 'Mauritania', code: 'MR' }, { name: 'Mauritius', code: 'MU' }, { name: 'Mayotte', code: 'YT' }, { name: 'Mexico', code: 'MX' }, { name: 'Micronesia', code: 'FM' }, { name: 'Moldova', code: 'MD' }, { name: 'Monaco', code: 'MC' }, { name: 'Mongolia', code: 'MN' }, { name: 'Montenegro', code: 'ME' }, { name: 'Montserrat', code: 'MS' }, { name: 'Morocco', code: 'MA' }, { name: 'Mozambique', code: 'MZ' }, { name: 'Myanmar', code: 'MM' }, { name: 'Namibia', code: 'NA' }, { name: 'Nauru', code: 'NR' }, { name: 'Nepal', code: 'NP' }, { name: 'Netherlands', code: 'NL' }, { name: 'New Caledonia', code: 'NC' }, { name: 'New Zealand', code: 'NZ' }, { name: 'Nicaragua', code: 'NI' }, { name: 'Niger', code: 'NE' }, { name: 'Nigeria', code: 'NG' }, { name: 'Niue', code: 'NU' }, { name: 'Norfolk Island', code: 'NF' }, { name: 'Northern Mariana Islands', code: 'MP' }, { name: 'Norway', code: 'NO' }, { name: 'Oman', code: 'OM' }, { name: 'Pakistan', code: 'PK' }, { name: 'Palau', code: 'PW' }, { name: 'Panama', code: 'PA' }, { name: 'Papua New Guinea', code: 'PG' }, { name: 'Paraguay', code: 'PY' }, { name: 'Peru', code: 'PE' }, { name: 'Philippines', code: 'PH' }, { name: 'Pitcairn', code: 'PN' }, { name: 'Poland', code: 'PL' }, { name: 'Portugal', code: 'PT' }, { name: 'Puerto Rico', code: 'PR' }, { name: 'Qatar', code: 'QA' }, { name: 'Reunion', code: 'RE' }, { name: 'Romania', code: 'RO' }, { name: 'Russian Federation', code: 'RU' }, { name: 'Rwanda', code: 'RW' }, { name: 'Saint Barthélemy', code: 'BL' }, { name: 'Saint Helena', code: 'SH' }, { name: 'Saint Kitts and Nevis', code: 'KN' }, { name: 'Saint Lucia', code: 'LC' }, { name: 'Saint Martin French', code: 'MF' }, { name: 'Saint Pierre and Miquelon', code: 'PM' }, { name: 'Saint Vincent and the Grenadines', code: 'VC' }, { name: 'Samoa', code: 'WS' }, { name: 'San Marino', code: 'SM' }, { name: 'Sao Tome and Principe', code: 'ST' }, { name: 'Saudi Arabia', code: 'SA' }, { name: 'Senegal', code: 'SN' }, { name: 'Serbia', code: 'RS' }, { name: 'Seychelles', code: 'SC' }, { name: 'Sierra Leone', code: 'SL' }, { name: 'Singapore', code: 'SG' }, { name: 'Sint Maarten Dutch', code: 'SX' }, { name: 'Slovakia', code: 'SK' }, { name: 'Slovenia', code: 'SI' }, { name: 'Solomon Islands', code: 'SB' }, { name: 'Somalia', code: 'SO' }, { name: 'South Africa', code: 'ZA' }, { name: 'South Sudan', code: 'SS' }, { name: 'Spain', code: 'ES' }, { name: 'Sri Lanka', code: 'LK' }, { name: 'Sudan', code: 'SD' }, { name: 'Suriname', code: 'SR' }, { name: 'Svalbard and Jan Mayen', code: 'SJ' }, { name: 'Swaziland', code: 'SZ' }, { name: 'Sweden', code: 'SE' }, { name: 'Switzerland', code: 'CH' }, { name: 'Syrian Arab Republic', code: 'SY' }, { name: 'Taiwan', code: 'TW' }, { name: 'Tajikistan', code: 'TJ' }, { name: 'Tanzania', code: 'TZ' }, { name: 'Thailand', code: 'TH' }, { name: 'Timor Leste', code: 'TL' }, { name: 'Togo', code: 'TG' }, { name: 'Tokelau', code: 'TK' }, { name: 'Tonga', code: 'TO' }, { name: 'Trinidad and Tobago', code: 'TT' }, { name: 'Tunisia', code: 'TN' }, { name: 'Turkey', code: 'TR' }, { name: 'Turkmenistan', code: 'TM' }, { name: 'Turks and Caicos Islands', code: 'TC' }, { name: 'Tuvalu', code: 'TV' }, { name: 'Uganda', code: 'UG' }, { name: 'Ukraine', code: 'UA' }, { name: 'United Arab Emirates', code: 'AE' }, { name: 'United Kingdom', code: 'GB' }, { name: 'United States', code: 'US' }, { name: 'United States Minor Outlying Islands', code: 'UM' }, { name: 'Uruguay', code: 'UY' }, { name: 'Uzbekistan', code: 'UZ' }, { name: 'Vanuatu', code: 'VU' }, { name: 'Venezuela', code: 'VE' }, { name: 'Viet Nam', code: 'VN' }, { name: 'Virgin Islands British', code: 'VG' }, { name: 'Virgin Islands U.S.', code: 'VI' }, { name: 'Wallis and Futuna', code: 'WF' }, { name: 'Western Sahara', code: 'EH' }, { name: 'Yemen', code: 'YE' }, { name: 'Zambia', code: 'ZM' }, { name: 'Zimbabwe', code: 'ZW' }];\n        geo.usStates = [{ name: \"Alabama\", code: \"AL\" }, { name: \"Alaska\", code: \"AK\" }, { name: \"American Samoa\", code: \"AS\" }, { name: \"Arizona\", code: \"AZ\" }, { name: \"Arkansas\", code: \"AR\" }, { name: \"California\", code: \"CA\" }, { name: \"Colorado\", code: \"CO\" }, { name: \"Connecticut\", code: \"CT\" }, { name: \"Delaware\", code: \"DE\" }, { name: \"District Of Columbia\", code: \"DC\" }, { name: \"Federated States Of Micronesia\", code: \"FM\" }, { name: \"Florida\", code: \"FL\" }, { name: \"Georgia\", code: \"GA\" }, { name: \"Guam\", code: \"GU\" }, { name: \"Hawaii\", code: \"HI\" }, { name: \"Idaho\", code: \"ID\" }, { name: \"Illinois\", code: \"IL\" }, { name: \"Indiana\", code: \"IN\" }, { name: \"Iowa\", code: \"IA\" }, { name: \"Kansas\", code: \"KS\" }, { name: \"Kentucky\", code: \"KY\" }, { name: \"Louisiana\", code: \"LA\" }, { name: \"Maine\", code: \"ME\" }, { name: \"Marshall Islands\", code: \"MH\" }, { name: \"Maryland\", code: \"MD\" }, { name: \"Massachusetts\", code: \"MA\" }, { name: \"Michigan\", code: \"MI\" }, { name: \"Minnesota\", code: \"MN\" }, { name: \"Mississippi\", code: \"MS\" }, { name: \"Missouri\", code: \"MO\" }, { name: \"Montana\", code: \"MT\" }, { name: \"Nebraska\", code: \"NE\" }, { name: \"Nevada\", code: \"NV\" }, { name: \"New Hampshire\", code: \"NH\" }, { name: \"New Jersey\", code: \"NJ\" }, { name: \"New Mexico\", code: \"NM\" }, { name: \"New York\", code: \"NY\" }, { name: \"North Carolina\", code: \"NC\" }, { name: \"North Dakota\", code: \"ND\" }, { name: \"Northern Mariana Islands\", code: \"MP\" }, { name: \"Ohio\", code: \"OH\" }, { name: \"Oklahoma\", code: \"OK\" }, { name: \"Oregon\", code: \"OR\" }, { name: \"Palau\", code: \"PW\" }, { name: \"Pennsylvania\", code: \"PA\" }, { name: \"Puerto Rico\", code: \"PR\" }, { name: \"Rhode Island\", code: \"RI\" }, { name: \"South Carolina\", code: \"SC\" }, { name: \"South Dakota\", code: \"SD\" }, { name: \"Tennessee\", code: \"TN\" }, { name: \"Texas\", code: \"TX\" }, { name: \"Utah\", code: \"UT\" }, { name: \"Vermont\", code: \"VT\" }, { name: \"Virgin Islands\", code: \"VI\" }, { name: \"Virginia\", code: \"VA\" }, { name: \"Washington\", code: \"WA\" }, { name: \"West Virginia\", code: \"WV\" }, { name: \"Wisconsin\", code: \"WI\" }, { name: \"Wyoming\", code: \"WY\" }, { name: \"U.S. Armed Forces Americas\", code: \"AA\" }, { name: \"U.S. Armed Forces Europe\", code: \"AE\" }, { name: \"U.S. Armed Forces Pacific\", code: \"AP\" }];\n        geo.caProvinces = [{ code: \"AB\", name: \"Alberta\" }, { code: \"BC\", name: \"British Columbia\" }, { code: \"MB\", name: \"Manitoba\" }, { code: \"NB\", name: \"New Brunswick\" }, { code: \"NL\", name: \"Newfoundland\" }, { code: \"NS\", name: \"Nova Scotia\" }, { code: \"NU\", name: \"Nunavut\" }, { code: \"NT\", name: \"Northwest Territories\" }, { code: \"ON\", name: \"Ontario\" }, { code: \"PE\", name: \"Prince Edward Island\" }, { code: \"QC\", name: \"Quebec\" }, { code: \"SK\", name: \"Saskatchewen\" }, { code: \"YT\", name: \"Yukon\" }];\n\n        return geo;\n    }\n\n    function getStatesProvs(country) {\n\n        var data = getData();\n\n        if (country == \"US\") {\n            return data.usStates;\n        }\n\n        if (country == \"CA\") {\n            return data.caProvinces;\n        }\n\n        return null;\n\n    }\n\n    function isEu(country) {\n\n        var euCountries = [\"AT\", \"BE\", \"BG\", \"HR\", \"CY\", \"CZ\", \"DK\", \"EE\", \"FI\", \"FR\", \"DE\", \"GR\", \"HU\", \"IE\", \"IT\", \"LV\", \"LT\", \"LU\", \"MT\", \"NL\", \"PL\", \"PT\", \"RO\", \"SK\", \"SI\", \"ES\", \"SE\", \"GB\"];\n\n        if (euCountries.indexOf(country) > -1) {\n            return true;\n        }\n\n        return false;\n\n    }\n\n    function getCurrencySymbol(code) {\n\n        var currencies = { \"AED\": \"د.إ\", \"AFN\": \"؋\", \"ALL\": \"L\", \"AMD\": \"֏\", \"ANG\": \"ƒ\", \"AOA\": \"Kz\", \"ARS\": \"$\", \"AUD\": \"$\", \"AWG\": \"ƒ\", \"AZN\": \"ман\", \"BAM\": \"KM\", \"BBD\": \"$\", \"BDT\": \"৳\", \"BGN\": \"лв\", \"BHD\": \".د.ب\", \"BIF\": \"FBu\", \"BMD\": \"$\", \"BND\": \"$\", \"BOB\": \"$b\", \"BRL\": \"R$\", \"BSD\": \"$\", \"BTC\": \"฿\", \"BTN\": \"Nu.\", \"BWP\": \"P\", \"BYR\": \"p.\", \"BZD\": \"BZ$\", \"CAD\": \"$\", \"CDF\": \"FC\", \"CHF\": \"CHF\", \"CLP\": \"$\", \"CNY\": \"¥\", \"COP\": \"$\", \"CRC\": \"₡\", \"CUC\": \"$\", \"CUP\": \"₱\", \"CVE\": \"$\", \"CZK\": \"Kč\", \"DJF\": \"Fdj\", \"DKK\": \"kr\", \"DOP\": \"RD$\", \"DZD\": \"دج\", \"EEK\": \"kr\", \"EGP\": \"£\", \"ERN\": \"Nfk\", \"ETB\": \"Br\", \"ETH\": \"Ξ\", \"EUR\": \"€\", \"FJD\": \"$\", \"FKP\": \"£\", \"GBP\": \"£\", \"GEL\": \"₾\", \"GGP\": \"£\", \"GHC\": \"₵\", \"GHS\": \"GH₵\", \"GIP\": \"£\", \"GMD\": \"D\", \"GNF\": \"FG\", \"GTQ\": \"Q\", \"GYD\": \"$\", \"HKD\": \"$\", \"HNL\": \"L\", \"HRK\": \"kn\", \"HTG\": \"G\", \"HUF\": \"Ft\", \"IDR\": \"Rp\", \"ILS\": \"₪\", \"IMP\": \"£\", \"INR\": \"₹\", \"IQD\": \"ع.د\", \"IRR\": \"﷼\", \"ISK\": \"kr\", \"JEP\": \"£\", \"JMD\": \"J$\", \"JOD\": \"JD\", \"JPY\": \"¥\", \"KES\": \"KSh\", \"KGS\": \"лв\", \"KHR\": \"៛\", \"KMF\": \"CF\", \"KPW\": \"₩\", \"KRW\": \"₩\", \"KWD\": \"KD\", \"KYD\": \"$\", \"KZT\": \"лв\", \"LAK\": \"₭\", \"LBP\": \"£\", \"LKR\": \"₨\", \"LRD\": \"$\", \"LSL\": \"M\", \"LTC\": \"Ł\", \"LTL\": \"Lt\", \"LVL\": \"Ls\", \"LYD\": \"LD\", \"MAD\": \"MAD\", \"MDL\": \"lei\", \"MGA\": \"Ar\", \"MKD\": \"ден\", \"MMK\": \"K\", \"MNT\": \"₮\", \"MOP\": \"MOP$\", \"MRO\": \"UM\", \"MUR\": \"₨\", \"MVR\": \"Rf\", \"MWK\": \"MK\", \"MXN\": \"$\", \"MYR\": \"RM\", \"MZN\": \"MT\", \"NAD\": \"$\", \"NGN\": \"₦\", \"NIO\": \"C$\", \"NOK\": \"kr\", \"NPR\": \"₨\", \"NZD\": \"$\", \"OMR\": \"﷼\", \"PAB\": \"B/.\", \"PEN\": \"S/.\", \"PGK\": \"K\", \"PHP\": \"₱\", \"PKR\": \"₨\", \"PLN\": \"zł\", \"PYG\": \"Gs\", \"QAR\": \"﷼\", \"RMB\": \"￥\", \"RON\": \"lei\", \"RSD\": \"Дин.\", \"RUB\": \"₽\", \"RWF\": \"R₣\", \"SAR\": \"﷼\", \"SBD\": \"$\", \"SCR\": \"₨\", \"SDG\": \"ج.س.\", \"SEK\": \"kr\", \"SGD\": \"$\", \"SHP\": \"£\", \"SLL\": \"Le\", \"SOS\": \"S\", \"SRD\": \"$\", \"SSP\": \"£\", \"STD\": \"Db\", \"SVC\": \"$\", \"SYP\": \"£\", \"SZL\": \"E\", \"THB\": \"฿\", \"TJS\": \"SM\", \"TMT\": \"T\", \"TND\": \"د.ت\", \"TOP\": \"T$\", \"TRL\": \"₤\", \"TRY\": \"₺\", \"TTD\": \"TT$\", \"TVD\": \"$\", \"TWD\": \"NT$\", \"TZS\": \"TSh\", \"UAH\": \"₴\", \"UGX\": \"USh\", \"USD\": \"$\", \"UYU\": \"$U\", \"UZS\": \"лв\", \"VEF\": \"Bs\", \"VND\": \"₫\", \"VUV\": \"VT\", \"WST\": \"WS$\", \"XAF\": \"FCFA\", \"XBT\": \"Ƀ\", \"XCD\": \"$\", \"XOF\": \"CFA\", \"XPF\": \"₣\", \"YER\": \"﷼\", \"ZAR\": \"R\", \"ZWD\": \"Z$\" }\n\n        return currencies[code] || \"\";\n    }\n\n}]);\n\napp.service(\"CurrencyService\", ['$q', '$rootScope', 'SettingsService', 'CartService', 'InvoiceService', 'StorageService', 'ApiService', function ($q, $rootScope, SettingsService, CartService, InvoiceService, StorageService, ApiService) {\n\n    // Return public API.\n    return {\n        getCurrency: getCurrency,\n        getCurrencyName: getCurrencyName,\n        setCurrency: setCurrency\n    };\n\n    function getCurrency() {\n        return StorageService.get(\"currency\");\n    }\n\n    function getCurrencyName() {\n\n        var code = getCurrency();\n        var settings = SettingsService.get();\n\n        var name = null;\n        _.each(settings.account.currencies, function (item) {\n            if (item.code == code) {\n                name = item.name;\n            }\n        });\n\n        return name;\n\n    }\n\n    function setCurrency(newValue) {\n\n        // Store in a cookie to persist page refreshes\n        StorageService.set(\"currency\", newValue);\n\n        // Emit the change\n        $rootScope.$emit(\"currencyChanged\", newValue);\n\n    }\n\n}]);\n\napp.service(\"LanguageService\", ['$q', '$rootScope', 'SettingsService', 'StorageService', 'gettextCatalog', function ($q, $rootScope, SettingsService, StorageService, gettextCatalog) {\n\n    // Angular gettext https://angular-gettext.rocketeer.be/ Used to provide application translations. Translation files are located in the languages folder.\n\n    // Return public API.\n    return {\n        getSelectedLanguage: getSelectedLanguage,\n        getLanguages: getLanguages,\n        setLanguage: setLanguage,\n        establishLanguage: establishLanguage,\n        getLocale: getLocale\n    };\n\n    function getLanguages() {\n\n        // The supported languages are defined in rootScope. This allows the setting to be changed by apps that use kit don't want to modify kit's source.\n        if ($rootScope.languages) {\n            return $rootScope.languages;\n        } else {\n            // Return the default language\n            return [{ code: \"en\", name: \"English\" }];\n        }\n\n    }\n\n    function getSelectedLanguage() {\n\n        var languages = getLanguages();\n        var language = StorageService.get(\"language\");\n\n        // Only return if the value is valid.\n        language = _.findWhere(languages, { code: language });\n        if (language) {\n            return language;\n        }\n\n        // Return empty.\n        return { name: null, code: null };\n\n    }\n\n    function isSupportedLanguage(language) {\n\n        var languages = getLanguages();\n        return !(_.findWhere(languages, { code: language }) == null);\n\n    }\n\n    function setLanguage(language, languagesPath) {\n\n        // Only attempt to set the language if the supplied value is valid.\n        if (isSupportedLanguage(language) == false) {\n            return;\n        }\n\n        StorageService.set(\"language\", language);\n\n        var languages = getLanguages();\n        $rootScope.language = _.find(languages, function (l) { return l.code == language });\n\n        gettextCatalog.setCurrentLanguage(language);\n\n        // Emit the change\n        $rootScope.$emit(\"languageChanged\", language);\n\n        // English does not need to be loaded since it's embedded in the HTML.\n        if (language != \"en\") {\n            // Load the language configuration file.\n            gettextCatalog.loadRemote((languagesPath || \"languages/\") + language + \"/\" + language + \".json\");\n        }\n\n    }\n\n    function establishLanguage(languagesPath) {\n\n        // If a language has already been selected, use it.\n        var selectedLanguage = getSelectedLanguage();\n        if (selectedLanguage.code && isSupportedLanguage(selectedLanguage.code)) {\n            setLanguage(selectedLanguage.code, languagesPath);\n            return;\n        }\n\n        var locale = null, language = null;\n        if (SettingsService.get().account.browser_info) {\n\n            // Check for an exact match on the locale, such as fr-CA.\n            locale = SettingsService.get().account.browser_info.locale;\n            if (isSupportedLanguage(locale)) {\n                setLanguage(locale, languagesPath);\n                return;\n            }\n\n            // Check for an exact match on the langauge, such as fr.\n            language = SettingsService.get().account.browser_info.language;\n            if (isSupportedLanguage(language)) {\n                setLanguage(language, languagesPath);\n                return;\n            }\n\n            // Check for a language that starts with the same language as the user language\n            // This is helpful in cases where the user's language is zh and we don't have zh but we do have zh-CN.\n            var result = _.find(getLanguages(), function (i) { return i.code.substring(0, 2) == language });\n            if (result) {\n                setLanguage(result.code, languagesPath);\n                return;\n            }\n\n        }\n\n    }\n\n    function getLocale() {\n\n        // If the language portion of the user's locale (for example: fr-ca, es-MX) is the same as the selected app language (for example: fr, es), use the full locale.\n        // Otherwise, if there is a mismatch between the language portion of the user's locale and the selected app language (for example: en-US, es), use the language code as the locale.\n\n        // The locale determines things such as number formatting, so if it important to send in the full locale, if possible. Otherwise the user will end up with default number formatting for the language, rather than for the specific locale.\n        // However, if the selected app language conflicts with the user locale, you can't send it or the API response text will be returned in the locale's language.\n\n        var locale = null;\n        if (SettingsService.get().account.browser_info) {\n            locale = SettingsService.get().account.browser_info.locale;\n        }\n\n        var language = getSelectedLanguage().code;\n\n        if (locale && locale.length >= 2 && language && language.length >= 2) {\n            if (locale.substring(0, 2).toLowerCase() == language.substring(0, 2).toLowerCase()) {\n                return locale;\n            }\n        }\n\n        return language;\n\n    }\n\n}]);\n\napp.service(\"SettingsService\", [function ($http, $q) {\n\n    // Return public API.\n    return {\n        get: get\n    };\n\n    function get() {\n\n        // The embedded settings/app.js and settings/account.js set the values within the __settings global variable.\n\n        // Get account settings\n        var getAccountSettings = function () {\n\n            var accountSettings = {};\n\n            if (window.__settings) {\n                if (window.__settings.account) {\n                    accountSettings = window.__settings.account;\n                }\n            }\n\n            // If accountSettings doesn't have the property \"date_utc\", inject the current client-side date.\n            // The purpose is to provide the current server date to the app when running in the hosted environment. It is not designed to give precise time (because the settings file may be cached for minutes) \n            // Therefore, it always returns a date with the time at midnight, but will provide a reliable date \"seed\" in the application for things like credit card expiration date lists and copyright dates. Useful when you don't want to rely on a client-side clock.\n            if (!accountSettings.date_utc) {\n                // No value provided in the settings file, which is likely in development environments. Inject the client-side date so the app doesn't have to consider null values.\n                accountSettings.date_utc = utils.getCurrentIsoDate(true);\n            }\n\n            // Split the date into parts for easy access\n            var date = new Date(accountSettings.date_utc);\n            accountSettings.year = date.getFullYear();\n            accountSettings.month = date.getMonth();\n            accountSettings.date = date.getDate();\n\n            return accountSettings;\n        };\n\n        // Get app settings\n        var getAppSettings = function () {\n\n            var appSettings = {};\n\n            if (window.__settings) {\n                if (window.__settings.app) {\n                    appSettings = window.__settings.app;\n                }\n            }\n\n            return appSettings;\n        };\n\n        // Get style settings\n        var getStyleSettings = function () {\n\n            var styleSettings = {};\n\n            if (window.__settings) {\n                if (window.__settings.style) {\n                    styleSettings = window.__settings.style;\n                }\n            }\n\n            return styleSettings;\n        };\n\n        // Build and return the settings object\n        var settings = { account: getAccountSettings(), app: getAppSettings(), style: getStyleSettings(), config: {} };\n\n        // Define the api prefix\n        settings.config.apiPrefix = \"/api/v1\";\n\n        settings.config.development = false;\n\n        // For convenience, if you place a development flag in either one of the settings stubs (during local development), the app will be marked as running in development mode.\n        if (settings.account.development || settings.app.development || settings.style.development) {\n\n            settings.config.development = true;\n\n            var apiHost = settings.account.api_host || settings.app.api_host || settings.style.api_host || \"api.comecero.com\";\n            apiHost = \"https://\" + apiHost;\n\n            // Make the apiPrefix a fully qualified url since requests in development mode don't have access to the reverse proxy.\n            settings.config.apiPrefix = apiHost + settings.config.apiPrefix;\n        }\n\n        return settings;\n\n    }\n\n}]);\n\napp.service(\"HelperService\", ['SettingsService', 'StorageService', '$location', function (SettingsService, StorageService, $location) {\n\n    // Return public API.\n    return {\n        isRequiredCustomerField: isRequiredCustomerField,\n        isOptionalCustomerField: isOptionalCustomerField,\n        isCustomerField: isCustomerField,\n        hasRequiredFields: hasRequiredFields,\n        hasShippingAddress: hasShippingAddress,\n        newSessionRedirect: newSessionRedirect,\n        getShoppingUrl: getShoppingUrl,\n        hasSubscription: hasSubscription,\n        hasPhysical: hasPhysical,\n        supportsPaymentMethod: supportsPaymentMethod\n    };\n\n    function isRequiredCustomerField(field, options, shippingIsBilling) {\n\n        if (!field || !options) {\n            return false;\n        }\n\n        // If shippingIsBilling == false and the field is a shipping address, swap shipping_address in the field name with billing_address before you compare.\n        var isShippingField = false;\n        if (field.substring(0, 17) == \"shipping_address.\") {\n            field = \"billing_address.\" + field.substring(17);\n            isShippingField = true;\n        }\n\n        if (field == \"billing_address.name\") {\n            field = \"name\";\n        }\n\n        if (shippingIsBilling === true) {\n            return false;\n        }\n\n        if (!options.customer_required_fields) {\n            return false;\n        }\n\n        if (options.customer_required_fields.indexOf(field) >= 0) {\n            return true;\n        }\n\n        return false;\n\n    }\n\n    function isOptionalCustomerField(field, options, shippingIsBilling) {\n\n        if (!field || !options) {\n            return false;\n        }\n\n        // If shippingIsBilling == false and the field is a shipping address, swap shipping_address in the field name with billing_address before you compare.\n        var isShippingField = false;\n        if (field.substring(0, 17) == \"shipping_address.\") {\n            field = \"billing_address.\" + field.substring(17);\n            isShippingField = true;\n        }\n        if (field == \"billing_address.name\") {\n            field = \"name\";\n        }\n\n        if (shippingIsBilling === true) {\n            return false;\n        }\n\n        if (!options.customer_optional_fields) {\n            return false;\n        }\n\n        if (options.customer_optional_fields.indexOf(field) >= 0) {\n            return true;\n        }\n\n        return false;\n\n    }\n\n    function isCustomerField(field, options, shippingIsBilling) {\n\n        if (!field || !options) {\n            return false;\n        }\n\n        if (options.customer_required_fields) {\n            if (isRequiredCustomerField(field, options, shippingIsBilling)) {\n                return true;\n            }\n        }\n\n        if (options.customer_optional_fields) {\n            if (isOptionalCustomerField(field, options, shippingIsBilling)) {\n                return true;\n            }\n        }\n\n        return false;\n\n    }\n\n    function hasRequiredFields(customer, options) {\n\n        for (i = 0; i < options.customer_required_fields.length; i++) {\n            if (options.customer_required_fields[i].substring(0, 16) == \"billing_address.\") {\n                if (!customer.billing_address[options.customer_required_fields[i].substring(16)]) {\n                    return false;\n                }\n            } else {\n                if (!customer[options.customer_required_fields[i]]) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n\n    }\n\n    function hasShippingAddress(customer) {\n\n        if (customer) {\n            if (customer.shipping_address) {\n                if (customer.shipping_address.address_1) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n\n    }\n\n    function newSessionRedirect(reset, debug) {\n\n        // This redirects the user to the base location of a new session, which may be an external URL.\n        // If reset == true, then it flushes the cart_id and token before performing the redirect.\n\n        // In the case of a bad token, invalid cart id or other unfortunate situation, this resets the user's session and redirects them to the desired URL.\n\n        console.log(debug);\n\n        if (reset === true) {\n            StorageService.remove(\"cart_id\");\n            StorageService.remove(\"invoice_id\");\n            StorageService.remove(\"token\");\n        }\n\n        var settings = SettingsService.get().app;\n\n        if (settings.main_shopping_url) {\n\n            // If a main shopping URL has been provided, redirect to it.\n            window.location.replace(settings.main_shopping_url);\n\n        } else {\n\n            // Otherwise, redirect to the app root. If the destination is the same page they're on, the location.replace won't do anything. Reload the current page in that case.\n            if ($location.path() != \"/\") {\n                $location.path(\"/\");\n                $location.replace();\n            } else {\n                window.location.reload();\n            }\n\n        }\n    }\n\n    function getShoppingUrl() {\n\n        var settings = SettingsService.get().app;\n\n        if (settings.main_shopping_url == null) {\n            return window.location.href.substring(0, window.location.href.indexOf(\"#\")) + \"#/\";\n        } else {\n            return settings.main_shopping_url;\n        }\n\n    }\n\n    function hasSubscription(items) {\n\n        if (_.find(items, function (item) { return item.subscription_plan != null; }) != null) {\n            return true;\n        }\n\n        return false;\n\n    }\n\n    function hasPhysical(items) {\n\n        if (_.find(items, function (item) { return item.type == \"physical\"; }) != null) {\n            return true;\n        }\n\n        return false;\n\n    }\n\n    function supportsPaymentMethod(type, options) {\n\n        if (!type || !options) {\n            return false;\n        }\n\n        if (type == 'apple_pay') {\n          if (!window.PaymentRequest || !window.ApplePaySession || !ApplePaySession.canMakePayments()) return false;\n        }\n\n        if (_.find(options.payment_methods, function (item) { return item.payment_method_type == type; }) != null) {\n            return true;\n        }\n\n        return false;\n\n    }\n\n}]);\n\napp.service(\"StorageService\", ['appCache', function (appCache) {\n\n    // Return public API.\n    return {\n        get: get,\n        set: set,\n        remove: remove\n    };\n\n    function get(key) {\n\n        var value = appCache.get(key);\n\n        if (value == null) {\n            // Look to to cookie for a backup\n            value = utils.getCookie(key);\n        }\n\n        return value;\n\n    }\n\n    function set(key, value, expiresInSeconds) {\n\n        appCache.put(key, value);\n\n        // If expiresInSeconds is not defined, we'll use 14 days as the default\n        if (expiresInSeconds == null) {\n            expiresInSeconds = 1209600;\n        }\n\n        // Backup to a cookie\n        utils.setCookie(key, value, expiresInSeconds / 60);\n\n    }\n\n    function remove(key) {\n\n        appCache.remove(key);\n\n        // Remove the associated cookie\n        utils.deleteCookie(key);\n\n    }\n\n}]);\n"],"file":"kit.js"}